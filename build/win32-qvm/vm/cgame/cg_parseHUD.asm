code
proc HUD_AmmoSoftLimit 4 0
file "..\..\..\..\code\cgame\cg_parsehud.c"
line 31
;1:#include "cg_local.h"
;2:#ifdef NEOHUD
;3:
;4:#include "../ui/menudef.h"			// for the voice chats
;5:
;6:#define HASH_TABLE_SIZE		2048
;7:#define MEM_POOL_SIZE		128 * 1024 // 1024 * 1024 in UI_GAME
;8:#define KEYWORDHASH_SIZE	512
;9:
;10:#define SPEED_SOFT_LIMIT	500
;11:#define HOLDABLE_ITEM_SOFT_LIMIT	60 //GUNNM fixme: find a correct limitt
;12:
;13:const char * loadedHUDfilePath;
;14:
;15:extern cgs_t cgs;
;16:extern cg_t cg;
;17:
;18:vec4_t health_colors[4];
;19:vec4_t armor_colors[4];
;20:vec4_t ammo_colors[4];
;21:vec4_t teams_colors[4];
;22:
;23:static char	memoryPool[MEM_POOL_SIZE];
;24:static int	allocPoint, outOfMemory;
;25:
;26:int FPS;
;27:
;28:// Choose some arbitrary values more realistic
;29:// as weapon soft limit, because AMMO_HARD_LIMIT,
;30:// 200, is too much for most weapons
;31:static int HUD_AmmoSoftLimit(int weapon) {
line 32
;32:	switch (weapon)
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $78
ADDRLP4 0
INDIRI4
CNSTI4 10
GTI4 $78
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $89
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $89
address $88
address $88
address $80
address $81
address $82
address $83
address $84
address $85
address $86
address $87
address $88
code
line 33
;33:	{
LABELV $80
line 35
;34:	case WP_MACHINEGUN:
;35:		return 100;
CNSTI4 100
RETI4
ADDRGP4 $77
JUMPV
line 36
;36:		break;
LABELV $81
line 38
;37:	case WP_SHOTGUN:
;38:		return 10;
CNSTI4 10
RETI4
ADDRGP4 $77
JUMPV
line 39
;39:		break;
LABELV $82
line 41
;40:	case WP_GRENADE_LAUNCHER:
;41:		return 10;
CNSTI4 10
RETI4
ADDRGP4 $77
JUMPV
line 42
;42:		break;
LABELV $83
line 44
;43:	case WP_ROCKET_LAUNCHER:
;44:		return 10;
CNSTI4 10
RETI4
ADDRGP4 $77
JUMPV
line 45
;45:		break;
LABELV $84
line 47
;46:	case WP_LIGHTNING:
;47:		return 100;
CNSTI4 100
RETI4
ADDRGP4 $77
JUMPV
line 48
;48:		break;
LABELV $85
line 50
;49:	case WP_RAILGUN:
;50:		return 20;
CNSTI4 20
RETI4
ADDRGP4 $77
JUMPV
line 51
;51:		break;
LABELV $86
line 53
;52:	case WP_PLASMAGUN:
;53:		return 50;
CNSTI4 50
RETI4
ADDRGP4 $77
JUMPV
line 54
;54:		break;
LABELV $87
line 56
;55:	case WP_BFG:
;56:		return 20;
CNSTI4 20
RETI4
ADDRGP4 $77
JUMPV
line 57
;57:		break;
LABELV $88
LABELV $78
line 74
;58:#ifdef MISSIONPACK
;59:		//TODO check values in Mission Pack
;60:	case WP_NAILGUN:
;61:		return 100;
;62:		break;
;63:	case WP_PROX_LAUNCHER:
;64:		return 100;
;65:		break;
;66:	case WP_CHAINGUN:
;67:		return 100;
;68:		break;
;69:#endif
;70:	case WP_NONE:
;71:	case WP_GRAPPLING_HOOK:
;72:	case WP_GAUNTLET:
;73:	default:
;74:		return 0;
CNSTI4 0
RETI4
line 75
;75:		break;
LABELV $77
endproc HUD_AmmoSoftLimit 4 0
proc HUD_SoftLimit 48 4
line 81
;76:	}
;77:}
;78:
;79://get soft limit for Health | Armor | Ammo | Weapon | Score | Time | HoldableItem | FPS | Speed | Fraglimit | Timelimit
;80://in order to draw a gradient texture, or select according color
;81:static int HUD_SoftLimit(int property, int param) {
line 82
;82:	switch (property)
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 1024
EQI4 $100
ADDRLP4 0
INDIRI4
CNSTI4 1024
GTI4 $119
LABELV $118
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32
EQI4 $99
ADDRLP4 4
INDIRI4
CNSTI4 32
GTI4 $121
LABELV $120
ADDRLP4 8
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 8
EQI4 $93
ADDRLP4 8
INDIRI4
CNSTI4 8
GTI4 $123
LABELV $122
ADDRFP4 0
INDIRI4
CNSTI4 4
EQI4 $97
ADDRGP4 $91
JUMPV
LABELV $123
ADDRFP4 0
INDIRI4
CNSTI4 16
EQI4 $95
ADDRGP4 $91
JUMPV
LABELV $121
ADDRLP4 12
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 128
EQI4 $114
ADDRLP4 12
INDIRI4
CNSTI4 128
GTI4 $125
LABELV $124
ADDRFP4 0
INDIRI4
CNSTI4 64
EQI4 $113
ADDRGP4 $91
JUMPV
LABELV $125
ADDRLP4 16
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 256
EQI4 $111
ADDRLP4 16
INDIRI4
CNSTI4 256
LTI4 $91
LABELV $126
ADDRFP4 0
INDIRI4
CNSTI4 512
EQI4 $115
ADDRGP4 $91
JUMPV
LABELV $119
ADDRLP4 20
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 16384
EQI4 $111
ADDRLP4 20
INDIRI4
CNSTI4 16384
GTI4 $128
LABELV $127
ADDRLP4 24
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 4096
EQI4 $107
ADDRLP4 24
INDIRI4
CNSTI4 4096
GTI4 $130
LABELV $129
ADDRFP4 0
INDIRI4
CNSTI4 2048
EQI4 $100
ADDRGP4 $91
JUMPV
LABELV $130
ADDRFP4 0
INDIRI4
CNSTI4 8192
EQI4 $109
ADDRGP4 $91
JUMPV
LABELV $128
ADDRLP4 28
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65536
EQI4 $117
ADDRLP4 28
INDIRI4
CNSTI4 65536
GTI4 $132
LABELV $131
ADDRFP4 0
INDIRI4
CNSTI4 32768
EQI4 $117
ADDRGP4 $91
JUMPV
LABELV $132
ADDRLP4 32
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 131072
EQI4 $117
ADDRLP4 32
INDIRI4
CNSTI4 131072
LTI4 $91
LABELV $133
ADDRFP4 0
INDIRI4
CNSTI4 262144
EQI4 $116
ADDRGP4 $91
JUMPV
line 83
;83:	{
LABELV $93
line 85
;84:	case VAL_HEALTH:
;85:		return cg.snap->ps.stats[STAT_MAX_HEALTH];
ADDRGP4 cg+36
INDIRP4
CNSTI4 252
ADDP4
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $95
line 87
;86:	case VAL_ARMOR:
;87:		return cg.snap->ps.stats[STAT_MAX_HEALTH];
ADDRGP4 cg+36
INDIRP4
CNSTI4 252
ADDP4
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $97
line 89
;88:	case VAL_AMMO:
;89:	{
line 91
;90:		// AMMO_HARD_LIMIT (200) is too much for most weapons
;91:		centity_t *cent = &cg_entities[cg.snap->ps.clientNum];
ADDRLP4 36
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 740
MULI4
ADDRGP4 cg_entities
ADDP4
ASGNP4
line 92
;92:		int weapon = cent->currentState.weapon;
ADDRLP4 40
ADDRLP4 36
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
ASGNI4
line 93
;93:		return HUD_AmmoSoftLimit(weapon);
ADDRLP4 40
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $99
line 96
;94:	}
;95:	case VAL_WEAPON:
;96:		return HUD_AmmoSoftLimit(param);
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $100
line 99
;97:	case VAL_SCORE:
;98:	case VAL_CAPFRAG_LIMIT:
;99:		return (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
LTI4 $105
ADDRLP4 40
ADDRGP4 cgs+31496
INDIRI4
ASGNI4
ADDRGP4 $106
JUMPV
LABELV $105
ADDRLP4 40
ADDRGP4 cgs+31492
INDIRI4
ASGNI4
LABELV $106
ADDRLP4 40
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $107
line 101
;100:	case VAL_FRAG_LIMIT:
;101:		return cgs.fraglimit;
ADDRGP4 cgs+31492
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $109
line 103
;102:	case VAL_CAPTURE_LIMIT:
;103:		return cgs.capturelimit;
ADDRGP4 cgs+31496
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $111
line 106
;104:	case VAL_TIMER:
;105:	case VAL_TIME_LIMIT:
;106:		return cgs.timelimit;
ADDRGP4 cgs+31500
INDIRI4
RETI4
ADDRGP4 $90
JUMPV
LABELV $113
line 108
;107:	case VAL_HOLDABLE_ITEM:
;108:		return HOLDABLE_ITEM_SOFT_LIMIT;
CNSTI4 60
RETI4
ADDRGP4 $90
JUMPV
LABELV $114
line 110
;109:	case VAL_FPS:
;110:	{
line 113
;111:		//int com_maxfps = Cvar_Get( "com_maxfps", "125", 0 );
;112:		//return com_maxfps; //GUNNM TODO
;113:		return 240;
CNSTI4 240
RETI4
ADDRGP4 $90
JUMPV
LABELV $115
line 116
;114:	}
;115:	case VAL_SPEED:
;116:		return SPEED_SOFT_LIMIT;
CNSTI4 500
RETI4
ADDRGP4 $90
JUMPV
LABELV $116
line 118
;117:	case VAL_PLAYERS_NB_TEAM:
;118:		return TEAM_MAXOVERLAY; //MAX_CLIENTS; //not really TEAM_MAXOVERLAY. What is the maximum player in a team?
CNSTI4 32
RETI4
ADDRGP4 $90
JUMPV
LABELV $117
LABELV $91
line 124
;119:	//those are string, so return 0
;120:	case VAL_FOLLOW_NAME:
;121:	case VAL_SNAPSHOT:
;122:	case VAL_LOCATION:
;123:	default:
;124:		return 0;
CNSTI4 0
RETI4
LABELV $90
endproc HUD_SoftLimit 48 4
proc GetTeamPlayerstat 4 0
line 128
;125:	}
;126:}
;127:
;128:static int GetTeamPlayerstat(item_t *itm, statIndex_t STAT_X) {
line 129
;129:	if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $135
line 130
;130:		if (!itm->team_player) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
NEI4 $137
line 131
;131:			return cg.snap->ps.stats[STAT_X];
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $134
JUMPV
LABELV $137
line 133
;132:		}
;133:		if (itm->team_player < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
GEI4 $140
line 134
;134:			if (cg_currentSelectedPlayer.integer == cg.snap->ps.clientNum)
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $142
line 135
;135:				return cg.snap->ps.stats[STAT_X];
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $134
JUMPV
LABELV $142
line 136
;136:			else {
line 139
;137:				// for team players
;138:				clientInfo_t	*ci;
;139:				ci = &cgs.clientinfo[cg_currentSelectedPlayer.integer];
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 140
;140:				if (STAT_X == STAT_ARMOR)
ADDRFP4 4
INDIRI4
CNSTI4 3
NEI4 $149
line 141
;141:					return ci->armor;
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
RETI4
ADDRGP4 $134
JUMPV
LABELV $149
line 142
;142:				else if (STAT_X == STAT_HEALTH)
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $141
line 143
;143:					return ci->health;
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
RETI4
ADDRGP4 $134
JUMPV
line 144
;144:			}
line 145
;145:		}
LABELV $140
line 146
;146:		else if (itm->team_player >= 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1
LTI4 $153
line 149
;147:			// if a team player is explicitely asked
;148:			clientInfo_t	*ci;
;149:			ci = &cgs.clientinfo[itm->team_player];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 150
;150:			if (STAT_X == STAT_ARMOR)
ADDRFP4 4
INDIRI4
CNSTI4 3
NEI4 $156
line 151
;151:				return ci->armor;
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
RETI4
ADDRGP4 $134
JUMPV
LABELV $156
line 152
;152:			else if (STAT_X == STAT_HEALTH)
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $158
line 153
;153:				return ci->health;
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
RETI4
ADDRGP4 $134
JUMPV
LABELV $158
line 154
;154:		}
LABELV $153
LABELV $141
line 155
;155:	}
LABELV $135
line 156
;156:	return cg.snap->ps.stats[STAT_X];
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
ADDP4
INDIRI4
RETI4
LABELV $134
endproc GetTeamPlayerstat 4 0
proc CG_getScore 0 0
line 159
;157:}
;158:
;159:static int CG_getScore(int param) {
line 161
;160:	// Red score
;161:	if (param == 1) {
ADDRFP4 0
INDIRI4
CNSTI4 1
NEI4 $162
line 162
;162:		return cgs.scores1;
ADDRGP4 cgs+34824
INDIRI4
RETI4
ADDRGP4 $161
JUMPV
LABELV $162
line 165
;163:	}
;164:	// Blue score
;165:	else if (param == 2) {
ADDRFP4 0
INDIRI4
CNSTI4 2
NEI4 $165
line 166
;166:		return cgs.scores2;
ADDRGP4 cgs+34828
INDIRI4
RETI4
ADDRGP4 $161
JUMPV
LABELV $165
line 169
;167:	}
;168:	// Enemy score
;169:	else if (param == 3) {
ADDRFP4 0
INDIRI4
CNSTI4 3
NEI4 $168
line 170
;170:		if (cg.snap->ps.persistant[PERS_SCORE] == cgs.scores1)
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
ADDRGP4 cgs+34824
INDIRI4
NEI4 $170
line 171
;171:			return cgs.scores2;
ADDRGP4 cgs+34828
INDIRI4
RETI4
ADDRGP4 $161
JUMPV
LABELV $170
line 173
;172:		else
;173:			return cgs.scores1;
ADDRGP4 cgs+34824
INDIRI4
RETI4
ADDRGP4 $161
JUMPV
LABELV $168
line 176
;174:	}
;175:	// Player score	
;176:	else {
line 177
;177:		return cg.snap->ps.persistant[PERS_SCORE];
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
RETI4
LABELV $161
endproc CG_getScore 0 0
proc CG_getPleayersNumber 8 0
line 181
;178:	}
;179:}
;180:
;181:static int CG_getPleayersNumber(int param) {
line 182
;182:	int nbPlyr = cg.numScores;//this is surely not the better way of having opposite team member. 
ADDRLP4 0
ADDRGP4 cg+110476
INDIRI4
ASGNI4
line 184
;183:
;184:	int team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 4
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 186
;185:	// Red team players number
;186:	if (param == 1) {
ADDRFP4 0
INDIRI4
CNSTI4 1
NEI4 $180
line 187
;187:		if (team == TEAM_RED)
ADDRLP4 4
INDIRI4
CNSTI4 1
NEI4 $182
line 188
;188:			return numSortedTeamPlayers;
ADDRGP4 numSortedTeamPlayers
INDIRI4
RETI4
ADDRGP4 $177
JUMPV
LABELV $182
line 189
;189:		else if (nbPlyr <= 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $184
line 190
;190:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $177
JUMPV
LABELV $184
line 192
;191:		else
;192:			return nbPlyr - numSortedTeamPlayers;
ADDRLP4 0
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
SUBI4
RETI4
ADDRGP4 $177
JUMPV
LABELV $180
line 195
;193:	}
;194:	// Blue team players number
;195:	else if (param == 2) {
ADDRFP4 0
INDIRI4
CNSTI4 2
NEI4 $186
line 196
;196:		if (team == TEAM_BLUE)
ADDRLP4 4
INDIRI4
CNSTI4 2
NEI4 $188
line 197
;197:			return numSortedTeamPlayers;
ADDRGP4 numSortedTeamPlayers
INDIRI4
RETI4
ADDRGP4 $177
JUMPV
LABELV $188
line 198
;198:		else if (nbPlyr <= 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $190
line 199
;199:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $177
JUMPV
LABELV $190
line 201
;200:		else
;201:			return nbPlyr - numSortedTeamPlayers;
ADDRLP4 0
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
SUBI4
RETI4
ADDRGP4 $177
JUMPV
LABELV $186
line 204
;202:	}
;203:	// Opposing team players number
;204:	else if (param == 3) {
ADDRFP4 0
INDIRI4
CNSTI4 3
NEI4 $192
line 205
;205:		if (nbPlyr <= 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $194
line 206
;206:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $177
JUMPV
LABELV $194
line 207
;207:		else if (cgs.gametype < GT_TEAM)
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
GEI4 $196
line 208
;208:			return nbPlyr - 1;
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
RETI4
ADDRGP4 $177
JUMPV
LABELV $196
line 210
;209:		else
;210:			return nbPlyr - numSortedTeamPlayers;
ADDRLP4 0
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
SUBI4
RETI4
ADDRGP4 $177
JUMPV
LABELV $192
line 213
;211:	}
;212:	// Own team players number	
;213:	else {
line 214
;214:		if (cgs.gametype < GT_TEAM)
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
GEI4 $199
line 215
;215:			return 1;
CNSTI4 1
RETI4
ADDRGP4 $177
JUMPV
LABELV $199
line 217
;216:		else
;217:			return numSortedTeamPlayers;
ADDRGP4 numSortedTeamPlayers
INDIRI4
RETI4
LABELV $177
endproc CG_getPleayersNumber 8 0
proc CG_getTimer 8 0
line 221
;218:	}
;219:}
;220:
;221:static int CG_getTimer( void ) {
line 223
;222:	int msec, seconds;
;223:	msec = cg.time - cgs.levelStartTime;
ADDRLP4 0
ADDRGP4 cg+107604
INDIRI4
ADDRGP4 cgs+34820
INDIRI4
SUBI4
ASGNI4
line 224
;224:	seconds = msec / 1000;
ADDRLP4 4
ADDRLP4 0
INDIRI4
CNSTI4 1000
DIVI4
ASGNI4
line 225
;225:	return seconds;
ADDRLP4 4
INDIRI4
RETI4
LABELV $202
endproc CG_getTimer 8 0
proc CG_getAmmo 4 0
line 228
;226:}
;227:
;228:static int CG_getAmmo( void ) {
line 230
;229:	centity_t *cent;
;230:	cent = &cg_entities[cg.snap->ps.clientNum];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 740
MULI4
ADDRGP4 cg_entities
ADDP4
ASGNP4
line 231
;231:	if (cent->currentState.weapon) {
ADDRLP4 0
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $207
line 232
;232:		return cg.snap->ps.ammo[cent->currentState.weapon];
ADDRLP4 0
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $205
JUMPV
LABELV $207
line 234
;233:	}
;234:	return 0;
CNSTI4 0
RETI4
LABELV $205
endproc CG_getAmmo 4 0
proc HUD_PropValue 64 8
line 238
;235:}
;236:
;237://get value for Health | Armor | Ammo | Weapon | Score | Time | HoldableItem | FPS | Speed | Fraglimit | Timelimit
;238:static int HUD_PropValue(item_t *itm, int oneFlag, int param) {
line 239
;239:	switch (oneFlag)
ADDRLP4 0
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 1024
EQI4 $218
ADDRLP4 0
INDIRI4
CNSTI4 1024
GTI4 $241
LABELV $240
ADDRLP4 4
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32
EQI4 $216
ADDRLP4 4
INDIRI4
CNSTI4 32
GTI4 $243
LABELV $242
ADDRLP4 8
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 8
EQI4 $213
ADDRLP4 8
INDIRI4
CNSTI4 8
GTI4 $245
LABELV $244
ADDRFP4 4
INDIRI4
CNSTI4 4
EQI4 $215
ADDRGP4 $211
JUMPV
LABELV $245
ADDRFP4 4
INDIRI4
CNSTI4 16
EQI4 $214
ADDRGP4 $211
JUMPV
LABELV $243
ADDRLP4 12
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 128
EQI4 $223
ADDRLP4 12
INDIRI4
CNSTI4 128
GTI4 $247
LABELV $246
ADDRFP4 4
INDIRI4
CNSTI4 64
EQI4 $221
ADDRGP4 $211
JUMPV
LABELV $247
ADDRLP4 16
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 256
EQI4 $220
ADDRLP4 16
INDIRI4
CNSTI4 256
LTI4 $211
LABELV $248
ADDRFP4 4
INDIRI4
CNSTI4 512
EQI4 $224
ADDRGP4 $211
JUMPV
LABELV $241
ADDRLP4 20
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 16384
EQI4 $237
ADDRLP4 20
INDIRI4
CNSTI4 16384
GTI4 $250
LABELV $249
ADDRLP4 24
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 4096
EQI4 $233
ADDRLP4 24
INDIRI4
CNSTI4 4096
GTI4 $252
LABELV $251
ADDRFP4 4
INDIRI4
CNSTI4 2048
EQI4 $226
ADDRGP4 $211
JUMPV
LABELV $252
ADDRFP4 4
INDIRI4
CNSTI4 8192
EQI4 $235
ADDRGP4 $211
JUMPV
LABELV $250
ADDRLP4 28
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65536
EQI4 $239
ADDRLP4 28
INDIRI4
CNSTI4 65536
GTI4 $254
LABELV $253
ADDRFP4 4
INDIRI4
CNSTI4 32768
EQI4 $239
ADDRGP4 $211
JUMPV
LABELV $254
ADDRLP4 32
ADDRFP4 4
INDIRI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 131072
EQI4 $239
ADDRLP4 32
INDIRI4
CNSTI4 131072
LTI4 $211
LABELV $255
ADDRFP4 4
INDIRI4
CNSTI4 262144
EQI4 $219
ADDRGP4 $211
JUMPV
line 240
;240:	{
LABELV $213
line 242
;241:	case VAL_HEALTH:
;242:		return GetTeamPlayerstat(itm, STAT_HEALTH);
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 36
ADDRGP4 GetTeamPlayerstat
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $214
line 244
;243:	case VAL_ARMOR:
;244:		return GetTeamPlayerstat(itm, STAT_ARMOR);
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 40
ADDRGP4 GetTeamPlayerstat
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $215
line 246
;245:	case VAL_AMMO:
;246:		return CG_getAmmo();
ADDRLP4 44
ADDRGP4 CG_getAmmo
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $216
line 248
;247:	case VAL_WEAPON:
;248:		return cg.snap->ps.ammo[param];
ADDRFP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $218
line 250
;249:	case VAL_SCORE:
;250:		return CG_getScore(param);
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 48
ADDRGP4 CG_getScore
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $219
line 252
;251:	case VAL_PLAYERS_NB_TEAM:
;252:		return CG_getPleayersNumber(param);
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 CG_getPleayersNumber
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $220
line 254
;253:	case VAL_TIMER:
;254:		return CG_getTimer();
ADDRLP4 56
ADDRGP4 CG_getTimer
CALLI4
ASGNI4
ADDRLP4 56
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $221
line 256
;255:	case VAL_HOLDABLE_ITEM:
;256:		return cg.snap->ps.stats[STAT_HOLDABLE_ITEM];
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $223
line 258
;257:	case VAL_FPS:
;258:		return FPS;
ADDRGP4 FPS
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $224
line 260
;259:	case VAL_SPEED:
;260:		return (int)cg.xyspeed;
ADDRGP4 cg+117976
INDIRF4
CVFI4 4
RETI4
ADDRGP4 $210
JUMPV
LABELV $226
line 262
;261:	case VAL_CAPFRAG_LIMIT:
;262:		return (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
LTI4 $231
ADDRLP4 60
ADDRGP4 cgs+31496
INDIRI4
ASGNI4
ADDRGP4 $232
JUMPV
LABELV $231
ADDRLP4 60
ADDRGP4 cgs+31492
INDIRI4
ASGNI4
LABELV $232
ADDRLP4 60
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $233
line 264
;263:	case VAL_FRAG_LIMIT:
;264:		return cgs.fraglimit;
ADDRGP4 cgs+31492
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $235
line 266
;265:	case VAL_CAPTURE_LIMIT:
;266:		return cgs.capturelimit;
ADDRGP4 cgs+31496
INDIRI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $237
line 269
;267:	case VAL_TIME_LIMIT:
;268:		//seconds only
;269:		return ((cgs.timelimit) * 60);
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 60
MULI4
RETI4
ADDRGP4 $210
JUMPV
LABELV $239
line 274
;270:	// those are string
;271:	case VAL_LOCATION:
;272:	case VAL_FOLLOW_NAME:
;273:	case VAL_SNAPSHOT:
;274:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $210
JUMPV
LABELV $211
line 276
;275:	default:
;276:		return 0;
CNSTI4 0
RETI4
LABELV $210
endproc HUD_PropValue 64 8
export HUD_ItemCaptionValue
proc HUD_ItemCaptionValue 112 12
line 280
;277:	}
;278:}
;279:
;280:int HUD_ItemCaptionValue(item_t *itm) {
line 282
;281:
;282:	if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $257
line 286
;283:		clientInfo_t *ci;
;284:		int clientNum;
;285:
;286:		if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $259
line 287
;287:			if (!itm->team_player)
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
NEI4 $261
line 288
;288:				clientNum = cg.snap->ps.clientNum;
ADDRLP4 4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $262
JUMPV
LABELV $261
line 289
;289:			else if (itm->team_player < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
GEI4 $264
line 290
;290:				clientNum = cg_currentSelectedPlayer.integer;
ADDRLP4 4
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ASGNI4
line 291
;291:			}
ADDRGP4 $265
JUMPV
LABELV $264
line 292
;292:			else if (itm->team_player >= 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1
LTI4 $267
line 293
;293:				clientNum = itm->team_player;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ASGNI4
line 294
;294:			}
LABELV $267
LABELV $265
LABELV $262
line 295
;295:		}
LABELV $259
line 296
;296:		ci = cgs.clientinfo + sortedTeamPlayers[clientNum];
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 298
;297:
;298:		if (ci->infoValid && ci->team == cg.snap->ps.persistant[PERS_TEAM]) {
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRI4
CNSTI4 0
EQI4 $270
ADDRLP4 8
INDIRP4
CNSTI4 36
ADDP4
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
NEI4 $270
line 299
;299:			if (itm->text.flags & VAL_HEALTH)		return ci->health;
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $273
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $273
line 300
;300:			else if (itm->text.flags & VAL_ARMOR)	return ci->armor;
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $275
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $275
line 301
;301:		}
LABELV $270
line 302
;302:	}
LABELV $257
line 304
;303:
;304:	if (itm->text.flags & VAL_HEALTH)				return HUD_PropValue(itm, VAL_HEALTH, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $277
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 8
ARGI4
ADDRLP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $277
line 305
;305:	else if (itm->text.flags & VAL_FPS)				return HUD_PropValue(itm, VAL_FPS, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $279
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 128
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $279
line 306
;306:	else if (itm->text.flags & VAL_ARMOR)			return HUD_PropValue(itm, VAL_ARMOR, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $281
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $281
line 307
;307:	else if (itm->text.flags & VAL_AMMO)			return HUD_PropValue(itm, VAL_AMMO, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $283
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
ARGP4
CNSTI4 4
ARGI4
ADDRLP4 24
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $283
line 308
;308:	else if (itm->text.flags & VAL_WEAPON)			return HUD_PropValue(itm, VAL_WEAPON, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $285
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
ARGP4
CNSTI4 32
ARGI4
ADDRLP4 32
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $285
line 309
;309:	else if (itm->text.flags & VAL_SCORE)			return HUD_PropValue(itm, VAL_SCORE, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $287
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ARGP4
CNSTI4 1024
ARGI4
ADDRLP4 40
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $287
line 310
;310:	else if (itm->text.flags & VAL_TIMER)			return HUD_PropValue(itm, VAL_TIMER, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $289
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 48
INDIRP4
ARGP4
CNSTI4 256
ARGI4
ADDRLP4 48
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $289
line 311
;311:	else if (itm->text.flags & VAL_SPEED)			return HUD_PropValue(itm, VAL_SPEED, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $291
ADDRLP4 56
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 56
INDIRP4
ARGP4
CNSTI4 512
ARGI4
ADDRLP4 56
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 60
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 60
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $291
line 312
;312:	else if (itm->text.flags & VAL_CAPFRAG_LIMIT)	return HUD_PropValue(itm, VAL_CAPFRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $293
ADDRLP4 64
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 64
INDIRP4
ARGP4
CNSTI4 2048
ARGI4
ADDRLP4 64
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 68
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 68
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $293
line 313
;313:	else if (itm->text.flags & VAL_FRAG_LIMIT)		return HUD_PropValue(itm, VAL_FRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $295
ADDRLP4 72
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 72
INDIRP4
ARGP4
CNSTI4 4096
ARGI4
ADDRLP4 72
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 76
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 76
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $295
line 314
;314:	else if (itm->text.flags & VAL_CAPTURE_LIMIT)	return HUD_PropValue(itm, VAL_CAPTURE_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $297
ADDRLP4 80
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 80
INDIRP4
ARGP4
CNSTI4 8192
ARGI4
ADDRLP4 80
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 84
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 84
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $297
line 315
;315:	else if (itm->text.flags & VAL_TIME_LIMIT)		return HUD_PropValue(itm, VAL_TIME_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $299
ADDRLP4 88
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 88
INDIRP4
ARGP4
CNSTI4 16384
ARGI4
ADDRLP4 88
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 92
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 92
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $299
line 316
;316:	else if (itm->text.flags & VAL_HOLDABLE_ITEM)	return HUD_PropValue(itm, VAL_HOLDABLE_ITEM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $301
ADDRLP4 96
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 96
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 96
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 100
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 100
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $301
line 317
;317:	else if (itm->text.flags & VAL_PLAYERS_NB_TEAM)	return HUD_PropValue(itm, VAL_PLAYERS_NB_TEAM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 262144
BANDU4
CNSTU4 0
EQU4 $303
ADDRLP4 104
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 104
INDIRP4
ARGP4
CNSTI4 262144
ARGI4
ADDRLP4 104
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 108
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 108
INDIRI4
RETI4
ADDRGP4 $256
JUMPV
LABELV $303
line 322
;318:	// Those are string, no need to send them
;319:	//else if (itm->text.flags & VAL_FOLLOW_NAME)	return HUD_PropValue(itm, VAL_FOLLOW_NAME, itm->param);
;320:	//else if (itm->text.flags & VAL_SNAPSHOT)		return HUD_PropValue(itm, VAL_SNAPSHOT, itm->param);
;321:	//else if (itm->text.flags & VAL_LOCATION)		return HUD_PropValue(itm, VAL_LOCATION, itm->param);
;322:	else return 0;
CNSTI4 0
RETI4
LABELV $256
endproc HUD_ItemCaptionValue 112 12
proc HUD_ItemSoftLimit 56 8
line 325
;323:}
;324:
;325:static int HUD_ItemSoftLimit(item_t *itm) {
line 326
;326:	if (itm->text.flags & VAL_HEALTH)				return HUD_SoftLimit(VAL_HEALTH, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $306
CNSTI4 8
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 0
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $306
line 327
;327:	else if (itm->text.flags & VAL_FPS)				return HUD_SoftLimit(VAL_FPS, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $308
CNSTI4 128
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $308
line 328
;328:	else if (itm->text.flags & VAL_ARMOR)			return HUD_SoftLimit(VAL_ARMOR, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $310
CNSTI4 16
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $310
line 329
;329:	else if (itm->text.flags & VAL_AMMO)			return HUD_SoftLimit(VAL_AMMO, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $312
CNSTI4 4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $312
line 330
;330:	else if (itm->text.flags & VAL_WEAPON)			return HUD_SoftLimit(VAL_WEAPON, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $314
CNSTI4 32
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $314
line 331
;331:	else if (itm->text.flags & VAL_SCORE)			return HUD_SoftLimit(VAL_SCORE, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $316
CNSTI4 1024
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $316
line 332
;332:	else if (itm->text.flags & VAL_TIMER)			return HUD_SoftLimit(VAL_TIMER, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $318
CNSTI4 256
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 24
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $318
line 333
;333:	else if (itm->text.flags & VAL_SPEED)			return HUD_SoftLimit(VAL_SPEED, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $320
CNSTI4 512
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $320
line 334
;334:	else if (itm->text.flags & VAL_CAPFRAG_LIMIT)	return HUD_SoftLimit(VAL_CAPFRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $322
CNSTI4 2048
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 32
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $322
line 335
;335:	else if (itm->text.flags & VAL_FRAG_LIMIT)		return HUD_SoftLimit(VAL_FRAG_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $324
CNSTI4 4096
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $324
line 336
;336:	else if (itm->text.flags & VAL_CAPTURE_LIMIT)	return HUD_SoftLimit(VAL_CAPTURE_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $326
CNSTI4 8192
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 40
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $326
line 337
;337:	else if (itm->text.flags & VAL_TIME_LIMIT)		return HUD_SoftLimit(VAL_TIME_LIMIT, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $328
CNSTI4 16384
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $328
line 338
;338:	else if (itm->text.flags & VAL_HOLDABLE_ITEM)	return HUD_SoftLimit(VAL_HOLDABLE_ITEM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $330
CNSTI4 64
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 48
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $330
line 339
;339:	else if (itm->text.flags & VAL_PLAYERS_NB_TEAM)	return HUD_SoftLimit(VAL_PLAYERS_NB_TEAM, itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 262144
BANDU4
CNSTU4 0
EQU4 $332
CNSTI4 262144
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
RETI4
ADDRGP4 $305
JUMPV
LABELV $332
line 343
;340:	//else if (itm->text.flags & VAL_FOLLOW_NAME)	return HUD_SoftLimit(VAL_FOLLOW_NAME, itm->param);
;341:	//else if (itm->text.flags & VAL_SNAPSHOT)		return HUD_SoftLimit(VAL_SNAPSHOT, itm->param);
;342:	//else if (itm->text.flags & VAL_LOCATION)		return HUD_SoftLimit(VAL_LOCATION, itm->param);
;343:	else return 0;
CNSTI4 0
RETI4
LABELV $305
endproc HUD_ItemSoftLimit 56 8
proc cvarTest 0 0
line 346
;344:}
;345:
;346:static qboolean cvarTest(int flag) {
line 347
;347:	if (flag & CV_cg_drawStatus			&& !cg_drawStatus.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $335
ADDRGP4 cg_drawStatus+12
INDIRI4
CNSTI4 0
NEI4 $335
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $335
line 348
;348:	if (flag & CV_cg_drawWeaponSelect	&& !cg_drawWeaponSelect.integer)	return qfalse;//without the ! ?
ADDRFP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $338
ADDRGP4 cg_drawWeaponSelect+12
INDIRI4
CNSTI4 0
NEI4 $338
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $338
line 349
;349:	if (flag & CV_cg_drawAttacker		&& !cg_drawAttacker.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $341
ADDRGP4 cg_drawAttacker+12
INDIRI4
CNSTI4 0
NEI4 $341
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $341
line 350
;350:	if (flag & CV_cg_drawTeamOverlay	&& !cg_drawTeamOverlay.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $344
ADDRGP4 cg_drawTeamOverlay+12
INDIRI4
CNSTI4 0
NEI4 $344
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $344
line 351
;351:	if (flag & CV_cg_drawCrosshairNames && !cg_drawCrosshairNames.integer)	return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $347
ADDRGP4 cg_drawCrosshairNames+12
INDIRI4
CNSTI4 0
NEI4 $347
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $347
line 352
;352:	if (flag & CV_cg_drawIcons			&& !cg_drawIcons.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $350
ADDRGP4 cg_drawIcons+12
INDIRI4
CNSTI4 0
NEI4 $350
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $350
line 353
;353:	if (flag & CV_cg_draw3dIcons		&& !cg_draw3dIcons.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
EQI4 $353
ADDRGP4 cg_draw3dIcons+12
INDIRI4
CNSTI4 0
NEI4 $353
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $353
line 354
;354:	if (flag & CV_cg_drawFPS			&& !cg_drawFPS.integer)				return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 128
BANDI4
CNSTI4 0
EQI4 $356
ADDRGP4 cg_drawFPS+12
INDIRI4
CNSTI4 0
NEI4 $356
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $356
line 355
;355:	if (flag & CV_cg_drawSpeed			&& !cg_drawSpeed.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
EQI4 $359
ADDRGP4 cg_drawSpeed+12
INDIRI4
CNSTI4 0
NEI4 $359
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $359
line 356
;356:	if (flag & CV_cg_drawTimer			&& !cg_drawTimer.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $362
ADDRGP4 cg_drawTimer+12
INDIRI4
CNSTI4 0
NEI4 $362
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $362
line 357
;357:	if (flag & CV_cg_lagometer			&& !cg_lagometer.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 1024
BANDI4
CNSTI4 0
EQI4 $365
ADDRGP4 cg_lagometer+12
INDIRI4
CNSTI4 0
NEI4 $365
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $365
line 358
;358:	if (flag & CV_cg_drawPing			&& !cg_drawPing.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $368
ADDRGP4 cg_drawPing+12
INDIRI4
CNSTI4 0
NEI4 $368
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $368
line 359
;359:	if (flag & CV_cg_drawSnapshot		&& !cg_drawSnapshot.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $371
ADDRGP4 cg_drawSnapshot+12
INDIRI4
CNSTI4 0
NEI4 $371
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $371
line 360
;360:	if (flag & CV_cg_drawStatus			&& !cg_drawStatus.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $374
ADDRGP4 cg_drawStatus+12
INDIRI4
CNSTI4 0
NEI4 $374
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $374
line 361
;361:	if (flag & CV_cg_drawRewards		&& !cg_drawRewards.integer)			return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $377
ADDRGP4 cg_drawRewards+12
INDIRI4
CNSTI4 0
NEI4 $377
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $377
line 362
;362:	if (flag & CV_cg_drawAmmoWarning	&& !cg_drawAmmoWarning.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $380
ADDRGP4 cg_drawAmmoWarning+12
INDIRI4
CNSTI4 0
NEI4 $380
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $380
line 363
;363:	if (flag & CV_cg_drawCrosshair		&& !cg_drawCrosshair.integer)		return qfalse;
ADDRFP4 0
INDIRI4
CNSTI4 32768
BANDI4
CNSTI4 0
EQI4 $383
ADDRGP4 cg_drawCrosshair+12
INDIRI4
CNSTI4 0
NEI4 $383
CNSTI4 0
RETI4
ADDRGP4 $334
JUMPV
LABELV $383
line 364
;364:	return qtrue;
CNSTI4 1
RETI4
LABELV $334
endproc cvarTest 0 0
export isDisconnect
proc isDisconnect 36 8
line 369
;365:}
;366:
;367:// Allow the drawing of the phone jack
;368:// if we are completely past our buffers
;369:qboolean isDisconnect() {
line 372
;370:	int			cmdNum;
;371:	usercmd_t	cmd;
;372:	cmdNum = trap_GetCurrentCmdNumber() - CMD_BACKUP + 1;
ADDRLP4 28
ADDRGP4 trap_GetCurrentCmdNumber
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 28
INDIRI4
CNSTI4 64
SUBI4
CNSTI4 1
ADDI4
ASGNI4
line 373
;373:	trap_GetUserCmd(cmdNum, &cmd);
ADDRLP4 24
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRGP4 trap_GetUserCmd
CALLI4
pop
line 374
;374:	if (cmd.serverTime <= cg.snap->ps.commandTime
ADDRLP4 32
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 32
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 44
ADDP4
INDIRI4
LEI4 $391
ADDRLP4 32
INDIRI4
ADDRGP4 cg+107604
INDIRI4
LEI4 $387
LABELV $391
line 375
;375:		|| cmd.serverTime > cg.time) {	// special check for map_restart // bk 0102165 - FIXME
line 376
;376:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $386
JUMPV
LABELV $387
line 378
;377:	}
;378:	return qfalse;
CNSTI4 0
RETI4
LABELV $386
endproc isDisconnect 36 8
proc check_vis_gen_cases 28 0
line 381
;379:}
;380:
;381:static qboolean check_vis_gen_cases(const unsigned int visArray[2], int arrayIdx) {
line 383
;382:	qboolean isCFT, inMenu;
;383:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 385
;384:
;385:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $394
ADDRLP4 16
CNSTI4 1
ASGNI4
ADDRGP4 $395
JUMPV
LABELV $394
ADDRLP4 16
CNSTI4 0
ASGNI4
LABELV $395
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
line 388
;386:
;387:	// never show item
;388:	if (visible && flags & VIS_NEVER)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $396
ADDRLP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $396
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $396
line 391
;389:
;390:	//showScores
;391:	if (cg.showScores) {
ADDRGP4 cg+115356
INDIRI4
CNSTI4 0
EQI4 $398
line 392
;392:		if (visible && !(flags & VIS_IN_SCORE))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $401
ADDRLP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
NEI4 $401
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $401
line 393
;393:		if (!visible && flags & VIS_IN_SCORE)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $403
ADDRLP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $403
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $403
line 394
;394:	}
LABELV $398
line 397
;395:
;396:	//inMenu
;397:	inMenu = (cg.snap->ps.eFlags & EF_TALK);
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 4096
BANDI4
ASGNI4
line 398
;398:	if (inMenu) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $406
line 400
;399:		//if (visible && !(flags & VIS_IN_MENU))	return qfalse; // deactivated: easier to choose a HUD file
;400:		if (!visible && (flags & VIS_IN_MENU))		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $408
ADDRLP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $408
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $408
line 401
;401:	}
LABELV $406
line 404
;402:
;403:	//follow
;404:	if (flags & VIS_PMF_FOLLOW) {
ADDRLP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $410
line 405
;405:		if (visible && !(cg.snap->ps.pm_flags & PMF_FOLLOW))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $412
ADDRGP4 cg+36
INDIRP4
CNSTI4 56
ADDP4
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
NEI4 $412
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $412
line 406
;406:		if (!visible && cg.snap->ps.pm_flags & PMF_FOLLOW)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $415
ADDRGP4 cg+36
INDIRP4
CNSTI4 56
ADDP4
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $415
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $415
line 407
;407:	}
LABELV $410
line 410
;408:
;409:	//low ammo
;410:	if (flags & VIS_LOW_AMMO_WARNING) {
ADDRLP4 0
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $418
line 411
;411:		if (visible && !(cg.lowAmmoWarning == 1))						return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $420
ADDRGP4 cg+117544
INDIRI4
CNSTI4 1
EQI4 $420
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $420
line 412
;412:		if (!visible && cg.lowAmmoWarning && cg.lowAmmoWarning != 2)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $423
ADDRGP4 cg+117544
INDIRI4
CNSTI4 0
EQI4 $423
ADDRGP4 cg+117544
INDIRI4
CNSTI4 2
EQI4 $423
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $423
line 413
;413:	}
LABELV $418
line 416
;414:
;415:	// out of ammo
;416:	if (flags & VIS_OUT_OF_AMMO) {
ADDRLP4 0
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
EQI4 $427
line 417
;417:		if (visible && !(cg.lowAmmoWarning == 2))						return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $429
ADDRGP4 cg+117544
INDIRI4
CNSTI4 2
EQI4 $429
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $429
line 418
;418:		if (!visible && cg.lowAmmoWarning && cg.lowAmmoWarning == 2)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $432
ADDRGP4 cg+117544
INDIRI4
CNSTI4 0
EQI4 $432
ADDRGP4 cg+117544
INDIRI4
CNSTI4 2
NEI4 $432
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $432
line 419
;419:	}
LABELV $427
line 422
;420:
;421:	//warmup
;422:	if (flags & VIS_WARMUP) {
ADDRLP4 0
INDIRI4
CNSTI4 128
BANDI4
CNSTI4 0
EQI4 $436
line 423
;423:		if (visible && !(cg.warmup))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $438
ADDRGP4 cg+117848
INDIRI4
CNSTI4 0
NEI4 $438
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $438
line 424
;424:		if (!visible && cg.warmup)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $441
ADDRGP4 cg+117848
INDIRI4
CNSTI4 0
EQI4 $441
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $441
line 425
;425:	}
LABELV $436
line 428
;426:
;427:	// local server
;428:	if (flags & VIS_LOCAL_SERVER) {
ADDRLP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $444
line 429
;429:		if (visible && !cgs.localServer)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $446
ADDRGP4 cgs+31476
INDIRI4
CNSTI4 0
NEI4 $446
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $446
line 430
;430:		if (!visible && cgs.localServer)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $449
ADDRGP4 cgs+31476
INDIRI4
CNSTI4 0
EQI4 $449
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $449
line 431
;431:	}
LABELV $444
line 434
;432:
;433:	// disconnect
;434:	if (flags & VIS_DISCONNECTED) {
ADDRLP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $452
line 435
;435:		if (visible && isDisconnect())		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $454
ADDRLP4 20
ADDRGP4 isDisconnect
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $454
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $454
line 436
;436:		if (!visible && !isDisconnect())	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $456
ADDRLP4 24
ADDRGP4 isDisconnect
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $456
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $456
line 437
;437:	}
LABELV $452
line 440
;438:
;439:	//blink the 'Connection Interrupted' message & icon
;440:	if (flags & VIS_BLINK) {
ADDRLP4 0
INDIRI4
CNSTI4 1024
BANDI4
CNSTI4 0
EQI4 $458
line 441
;441:		if (visible && (cg.time >> 9) & 1)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $460
ADDRGP4 cg+107604
INDIRI4
CNSTI4 9
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $460
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $460
line 442
;442:		if (!visible && !((cg.time >> 9) & 1))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $463
ADDRGP4 cg+107604
INDIRI4
CNSTI4 9
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
NEI4 $463
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $463
line 443
;443:	}
LABELV $458
line 446
;444:
;445:	//powerup
;446:	if (flags & VIS_POWERUP_1) {
ADDRLP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $466
line 447
;447:		if (visible && !cg.snap->ps.powerups[1])	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $468
ADDRGP4 cg+36
INDIRP4
CNSTI4 360
ADDP4
INDIRI4
CNSTI4 0
NEI4 $468
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $468
line 448
;448:		if (!visible && cg.snap->ps.powerups[1])	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $471
ADDRGP4 cg+36
INDIRP4
CNSTI4 360
ADDP4
INDIRI4
CNSTI4 0
EQI4 $471
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $471
line 449
;449:	}
LABELV $466
line 452
;450:
;451:	//ItemPickup really worked
;452:	if (flags & VIS_PICKUP_ITEM) {
ADDRLP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $474
line 453
;453:		if (visible && !cg.itemPickup)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $476
ADDRGP4 cg+117860
INDIRI4
CNSTI4 0
NEI4 $476
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $476
line 454
;454:		if (!visible && cg.itemPickup)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $479
ADDRGP4 cg+117860
INDIRI4
CNSTI4 0
EQI4 $479
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $479
line 455
;455:	}
LABELV $474
line 458
;456:
;457:	//firing
;458:	if (flags & VIS_FIRING) {
ADDRLP4 0
INDIRI4
CNSTI4 32768
BANDI4
CNSTI4 0
EQI4 $482
line 459
;459:		if (visible && !(cg.snap->ps.eFlags & EF_FIRING))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $484
ADDRGP4 cg+36
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
NEI4 $484
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $484
line 460
;460:		if (!visible && cg.snap->ps.eFlags & EF_FIRING)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $487
ADDRGP4 cg+36
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
EQI4 $487
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $487
line 461
;461:	}
LABELV $482
line 464
;462:
;463:	// VIS_BLUE_FLAG_TAKEN
;464:	isCFT = (cgs.gametype == GT_CTF);
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
NEI4 $492
ADDRLP4 20
CNSTI4 1
ASGNI4
ADDRGP4 $493
JUMPV
LABELV $492
ADDRLP4 20
CNSTI4 0
ASGNI4
LABELV $493
ADDRLP4 8
ADDRLP4 20
INDIRI4
ASGNI4
line 469
;465:#ifdef MISSIONPACK
;466:	isCFT = (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF)
;467:#endif
;468:
;469:	if (isCFT && (flags & VIS_BLUE_FLAG_TAKEN)) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $494
ADDRLP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $494
line 470
;470:		if (visible && !cgs.blueflag)	return qfalse; // blue flag is not at base
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $496
ADDRGP4 cgs+34836
INDIRI4
CNSTI4 0
NEI4 $496
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $496
line 471
;471:		if (!visible && cgs.blueflag)	return qfalse; // blue flag at base
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $499
ADDRGP4 cgs+34836
INDIRI4
CNSTI4 0
EQI4 $499
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $499
line 472
;472:	}
LABELV $494
line 475
;473:
;474:	// VIS_RED_FLAG_TAKEN
;475:	if (isCFT && (flags & VIS_RED_FLAG_TAKEN)) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $502
ADDRLP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $502
line 476
;476:		if (visible && !cgs.redflag)	return qfalse; // red flag is not at base
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $504
ADDRGP4 cgs+34832
INDIRI4
CNSTI4 0
NEI4 $504
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $504
line 477
;477:		if (!visible && cgs.redflag)	return qfalse; // red flag at base
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $507
ADDRGP4 cgs+34832
INDIRI4
CNSTI4 0
EQI4 $507
CNSTI4 0
RETI4
ADDRGP4 $392
JUMPV
LABELV $507
line 478
;478:	}
LABELV $502
line 480
;479:
;480:	return qtrue;
CNSTI4 1
RETI4
LABELV $392
endproc check_vis_gen_cases 28 0
proc check_vis_GT_cases 40 0
line 483
;481:}
;482:
;483:static qboolean check_vis_GT_cases(const unsigned int visArray[2], int arrayIdx) {
line 486
;484:	qboolean solo, isCFT;
;485:	int team;
;486:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 488
;487:
;488:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $512
ADDRLP4 20
CNSTI4 1
ASGNI4
ADDRGP4 $513
JUMPV
LABELV $512
ADDRLP4 20
CNSTI4 0
ASGNI4
LABELV $513
ADDRLP4 4
ADDRLP4 20
INDIRI4
ASGNI4
line 491
;489:
;490:	// check game type
;491:	solo = (cgs.gametype < GT_TEAM);
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
GEI4 $516
ADDRLP4 24
CNSTI4 1
ASGNI4
ADDRGP4 $517
JUMPV
LABELV $516
ADDRLP4 24
CNSTI4 0
ASGNI4
LABELV $517
ADDRLP4 12
ADDRLP4 24
INDIRI4
ASGNI4
line 492
;492:	if (flags & VIS_TEAM_PLAY) {
ADDRLP4 0
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $518
line 493
;493:		if (visible && solo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $520
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $520
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $520
line 494
;494:		if (!visible && !solo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $522
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $522
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $522
line 495
;495:	}
LABELV $518
line 498
;496:
;497:	// blue team
;498:	team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 8
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 499
;499:	if (flags & VIS_TEAM_BLUE) {
ADDRLP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $525
line 500
;500:		if (visible && team != TEAM_BLUE)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $527
ADDRLP4 8
INDIRI4
CNSTI4 2
EQI4 $527
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $527
line 501
;501:		if (!visible && team == TEAM_BLUE)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $529
ADDRLP4 8
INDIRI4
CNSTI4 2
NEI4 $529
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $529
line 502
;502:	}
LABELV $525
line 505
;503:
;504:	// red team
;505:	if (flags & VIS_TEAM_RED) {
ADDRLP4 0
INDIRI4
CNSTI4 1024
BANDI4
CNSTI4 0
EQI4 $531
line 506
;506:		if (visible && team != TEAM_RED)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $533
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $533
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $533
line 507
;507:		if (!visible && team == TEAM_RED)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $535
ADDRLP4 8
INDIRI4
CNSTI4 1
NEI4 $535
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $535
line 508
;508:	}
LABELV $531
line 511
;509:
;510:	//spectator team
;511:	if (flags & VIS_TEAM_SPECTATOR) {
ADDRLP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $537
line 512
;512:		if (visible && team != TEAM_SPECTATOR)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $539
ADDRLP4 8
INDIRI4
CNSTI4 3
EQI4 $539
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $539
line 513
;513:		if (!visible && team == TEAM_SPECTATOR)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $541
ADDRLP4 8
INDIRI4
CNSTI4 3
NEI4 $541
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $541
line 514
;514:	}
LABELV $537
line 517
;515:
;516:	// in a team (bue or red)
;517:	if (flags & VIS_TEAM_BLUE_OR_RED) {
ADDRLP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $543
line 518
;518:		if (visible && (team != TEAM_BLUE && team != TEAM_RED))	 return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $545
ADDRLP4 8
INDIRI4
CNSTI4 2
EQI4 $545
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $545
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $545
line 519
;519:		if (!visible && (team == TEAM_BLUE || team == TEAM_RED)) return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $547
ADDRLP4 8
INDIRI4
CNSTI4 2
EQI4 $549
ADDRLP4 8
INDIRI4
CNSTI4 1
NEI4 $547
LABELV $549
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $547
line 520
;520:	}
LABELV $543
line 523
;521:
;522:	//Tournament
;523:	if (flags & VIS_GT_TOURNAMENT) {
ADDRLP4 0
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $550
line 524
;524:		if (visible && cgs.gametype != GT_TOURNAMENT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $552
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 1
EQI4 $552
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $552
line 525
;525:		if (!visible && cgs.gametype == GT_TOURNAMENT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $555
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 1
NEI4 $555
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $555
line 526
;526:	}
LABELV $550
line 529
;527:
;528:	//free for all
;529:	if (flags & VIS_GT_FFA) {
ADDRLP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $558
line 530
;530:		if (visible && cgs.gametype != GT_FFA)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $560
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 0
EQI4 $560
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $560
line 531
;531:		if (!visible && cgs.gametype == GT_FFA)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $563
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 0
NEI4 $563
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $563
line 532
;532:	}
LABELV $558
line 535
;533:
;534:	//team deathmatch
;535:	if (flags & VIS_GT_TDM) {
ADDRLP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $566
line 536
;536:		if (visible && cgs.gametype != GT_TEAM)		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $568
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
EQI4 $568
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $568
line 537
;537:		if (!visible && cgs.gametype == GT_TEAM)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $571
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
NEI4 $571
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $571
line 538
;538:	}
LABELV $566
line 541
;539:
;540:	//capture the flag
;541:	isCFT = (cgs.gametype == GT_CTF);
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
NEI4 $576
ADDRLP4 28
CNSTI4 1
ASGNI4
ADDRGP4 $577
JUMPV
LABELV $576
ADDRLP4 28
CNSTI4 0
ASGNI4
LABELV $577
ADDRLP4 16
ADDRLP4 28
INDIRI4
ASGNI4
line 546
;542:#ifdef MISSIONPACK
;543:	isCFT = (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF)
;544:#endif
;545:
;546:	if (flags & VIS_GT_CTF) {
ADDRLP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $578
line 547
;547:		if (visible && !isCFT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $580
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $580
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $580
line 548
;548:		if (!visible && isCFT)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $582
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $582
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $582
line 549
;549:	}
LABELV $578
line 572
;550:
;551:	//Obelisk
;552:#ifdef MISSIONPACK
;553:	if (flags & VIS_GT_OBELISK) {
;554:		if (visible && cgs.gametype != GT_OBELISK)	return qfalse;
;555:		if (!visible && cgs.gametype == GT_OBELISK)	return qfalse;
;556:	}
;557:
;558:	//Harvester
;559:	if (flags & VIS_GT_HARVESTER) {
;560:		if (visible && cgs.gametype != GT_HARVESTER)	return qfalse;
;561:		if (!visible && cgs.gametype == GT_HARVESTER)	return qfalse;
;562:	}
;563:#endif
;564:
;565://GUNNM TODO
;566:/*
;567:	if (flags & VIS_GT_FREEZE) {
;568:		if (visible && cgs.gametype != GT_FREEZE)	return qfalse;
;569:		if (!visible && cgs.gametype == GT_FREEZE)	return qfalse;
;570:	}
;571:*/
;572:	if (flags & VIS_SHOW_TEAMINFO) {
ADDRLP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $584
line 573
;573:		qboolean teamInfo = (cg_currentSelectedPlayer.integer == numSortedTeamPlayers);
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
NEI4 $588
ADDRLP4 36
CNSTI4 1
ASGNI4
ADDRGP4 $589
JUMPV
LABELV $588
ADDRLP4 36
CNSTI4 0
ASGNI4
LABELV $589
ADDRLP4 32
ADDRLP4 36
INDIRI4
ASGNI4
line 574
;574:		if (visible && !teamInfo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $590
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $590
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $590
line 575
;575:		if (!visible && teamInfo)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $592
ADDRLP4 32
INDIRI4
CNSTI4 0
EQI4 $592
CNSTI4 0
RETI4
ADDRGP4 $510
JUMPV
LABELV $592
line 576
;576:	}
LABELV $584
line 584
;577:
;578:#ifdef MISSIONPACK
;579:	if (flags & CG_SHOW_IF_PLAYER_HAS_FLAG) {
;580:		if (visible && !(cg.snap->ps.powerups[PW_REDFLAG] || cg.snap->ps.powerups[PW_BLUEFLAG] || cg.snap->ps.powerups[PW_NEUTRALFLAG]))	return qfalse;
;581:		if (!visible && (cg.snap->ps.powerups[PW_REDFLAG] || cg.snap->ps.powerups[PW_BLUEFLAG] || cg.snap->ps.powerups[PW_NEUTRALFLAG]))	return false;
;582:	}
;583:#endif
;584:	return qtrue;
CNSTI4 1
RETI4
LABELV $510
endproc check_vis_GT_cases 40 0
proc check_vis_val_cases 24 0
ADDRFP4 8
ADDRFP4 8
INDIRI4
ASGNI4
line 587
;585:}
;586:
;587:static qboolean check_vis_val_cases(const unsigned int visArray[2], int arrayIdx, const int param) {
line 588
;588:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 590
;589:
;590:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $596
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRGP4 $597
JUMPV
LABELV $596
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $597
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 593
;591:
;592:	//health
;593:	if (flags & VAL_HEALTH) {
ADDRLP4 0
INDIRI4
CNSTI4 8
BANDI4
CNSTI4 0
EQI4 $598
line 594
;594:		if (visible  && !(cg.snap->ps.stats[STAT_HEALTH]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $600
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
INDIRI4
CNSTI4 0
NEI4 $600
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $600
line 595
;595:		if (!visible && (cg.snap->ps.stats[STAT_HEALTH]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $603
ADDRGP4 cg+36
INDIRP4
CNSTI4 228
ADDP4
INDIRI4
CNSTI4 0
EQI4 $603
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $603
line 596
;596:	}
LABELV $598
line 599
;597:
;598:	//armor
;599:	if (flags & VAL_ARMOR) {
ADDRLP4 0
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $606
line 600
;600:		if (visible && !(cg.snap->ps.stats[STAT_ARMOR]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $608
ADDRGP4 cg+36
INDIRP4
CNSTI4 240
ADDP4
INDIRI4
CNSTI4 0
NEI4 $608
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $608
line 601
;601:		if (!visible && (cg.snap->ps.stats[STAT_ARMOR]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $611
ADDRGP4 cg+36
INDIRP4
CNSTI4 240
ADDP4
INDIRI4
CNSTI4 0
EQI4 $611
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $611
line 602
;602:	}
LABELV $606
line 605
;603:
;604:	//holdable item
;605:	if (flags & VAL_HOLDABLE_ITEM) {
ADDRLP4 0
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
EQI4 $614
line 606
;606:		if (visible && !(cg.snap->ps.stats[STAT_HOLDABLE_ITEM]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $616
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
CNSTI4 0
NEI4 $616
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $616
line 607
;607:		if (!visible && !(cg.snap->ps.stats[STAT_HOLDABLE_ITEM]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $619
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
CNSTI4 0
NEI4 $619
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $619
line 608
;608:	}
LABELV $614
line 611
;609:
;610:	//weapon
;611:	if (flags & VAL_WEAPON) { // param: WeaponNb
ADDRLP4 0
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $622
line 612
;612:		if (visible && !(cg.snap->ps.ammo[param]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $624
ADDRFP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
NEI4 $624
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $624
line 613
;613:		if (!visible && (cg.snap->ps.ammo[param]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $627
ADDRFP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
EQI4 $627
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $627
line 614
;614:	}
LABELV $622
line 617
;615:
;616:	//speed
;617:	if (flags & VAL_SPEED) {
ADDRLP4 0
INDIRI4
CNSTI4 512
BANDI4
CNSTI4 0
EQI4 $630
line 618
;618:		if (visible && !((int)cg.xyspeed))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $632
ADDRGP4 cg+117976
INDIRF4
CVFI4 4
CNSTI4 0
NEI4 $632
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $632
line 619
;619:		if (!visible && ((int)cg.xyspeed))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $635
ADDRGP4 cg+117976
INDIRF4
CVFI4 4
CNSTI4 0
EQI4 $635
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $635
line 620
;620:	}
LABELV $630
line 623
;621:
;622:	//time limit
;623:	if (flags & VAL_TIME_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $638
line 624
;624:		if (visible && !(cgs.timelimit > 0))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $640
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 0
GTI4 $640
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $640
line 625
;625:		if (!visible && (cgs.timelimit > 0))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $643
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 0
LEI4 $643
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $643
line 626
;626:	}
LABELV $638
line 629
;627:
;628:	//frag limit
;629:	if (flags & VAL_FRAG_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 4096
BANDI4
CNSTI4 0
EQI4 $646
line 630
;630:		if (visible && !(cgs.fraglimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $648
ADDRGP4 cgs+31492
INDIRI4
CNSTI4 0
NEI4 $648
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $648
line 631
;631:		if (!visible && (cgs.fraglimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $651
ADDRGP4 cgs+31492
INDIRI4
CNSTI4 0
EQI4 $651
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $651
line 632
;632:	}
LABELV $646
line 635
;633:
;634:	//capture limit
;635:	if (flags & VAL_CAPTURE_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 8192
BANDI4
CNSTI4 0
EQI4 $654
line 636
;636:		if (visible && !(cgs.capturelimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $656
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 0
NEI4 $656
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $656
line 637
;637:		if (!visible && (cgs.capturelimit))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $659
ADDRGP4 cgs+31496
INDIRI4
CNSTI4 0
EQI4 $659
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $659
line 638
;638:	}
LABELV $654
line 641
;639:
;640:	//capture limit / frag limit depending of game type
;641:	if (flags & VAL_CAPFRAG_LIMIT) {
ADDRLP4 0
INDIRI4
CNSTI4 2048
BANDI4
CNSTI4 0
EQI4 $662
line 642
;642:		int slimit = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
LTI4 $668
ADDRLP4 16
ADDRGP4 cgs+31496
INDIRI4
ASGNI4
ADDRGP4 $669
JUMPV
LABELV $668
ADDRLP4 16
ADDRGP4 cgs+31492
INDIRI4
ASGNI4
LABELV $669
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 643
;643:		if (visible && !slimit)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $670
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $670
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $670
line 644
;644:		if (!visible && slimit)	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $672
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $672
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $672
line 645
;645:	}
LABELV $662
line 648
;646:
;647:	// selected Weapon ammo
;648:	if (flags & VAL_AMMO) {
ADDRLP4 0
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $674
line 649
;649:		centity_t *cent = &cg_entities[cg.snap->ps.clientNum];
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 740
MULI4
ADDRGP4 cg_entities
ADDP4
ASGNP4
line 650
;650:		if (visible && (!cent->currentState.weapon || !cg.snap->ps.ammo[cent->currentState.weapon]))	return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $677
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $680
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
NEI4 $677
LABELV $680
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $677
line 651
;651:		if (!visible && cent->currentState.weapon && cg.snap->ps.ammo[cent->currentState.weapon])		return qfalse;
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $681
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $681
ADDRLP4 12
INDIRP4
CNSTI4 192
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 420
ADDP4
ADDP4
INDIRI4
CNSTI4 0
EQI4 $681
CNSTI4 0
RETI4
ADDRGP4 $594
JUMPV
LABELV $681
line 652
;652:	}
LABELV $674
line 663
;653:
;654:	// those visibility flags would make no sense
;655:	/*if (flags & VAL_SCORE ||
;656:		flags & VAL_TIMER ||
;657:		flags & VAL_FPS ||
;658:		flags & VAL_SNAPSHOT ||
;659:		flags & VAL_FOLLOW_NAME ||
;660:		flags & VAL_LOCATION) {
;661:		return qtrue;
;662:	}*/
;663:	return qtrue;
CNSTI4 1
RETI4
LABELV $594
endproc check_vis_val_cases 24 0
proc check_vis_teamPlayer_cases 24 0
ADDRFP4 8
ADDRFP4 8
INDIRI4
ASGNI4
line 666
;664:}
;665:
;666:static qboolean check_vis_teamPlayer_cases(const unsigned int visArray[2], int arrayIdx, const int param) {
line 667
;667:	int flags = visArray[arrayIdx];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
line 669
;668:
;669:	qboolean visible = (arrayIdx == 0);
ADDRFP4 4
INDIRI4
CNSTI4 0
NEI4 $686
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRGP4 $687
JUMPV
LABELV $686
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $687
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 677
;670:	int clientNum;
;671:
;672:	//visibility flags of team player related item
;673:	//if (visible && !(flags & VIS_TEAM_PLAYER)/* && (flags & VIS_TEAM_PLAYER)*/)	return qtrue;
;674:	//if (!visible && (flags & VIS_TEAM_PLAYER))	return qtrue;//not usefull
;675:	//if (visible && (flags & VIS_TEAM_PLAYER) && (cgs.gametype < GT_TEAM)) return qfalse;
;676:
;677:	if (visible && (flags & VIS_TEAM_PLAYER)) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $688
ADDRLP4 0
INDIRI4
CNSTI4 16384
BANDI4
CNSTI4 0
EQI4 $688
line 678
;678:		if (cgs.gametype < GT_TEAM) return qfalse;
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
GEI4 $690
CNSTI4 0
RETI4
ADDRGP4 $684
JUMPV
LABELV $690
line 680
;679:
;680:		if (!param)
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $693
line 681
;681:			clientNum = cg.snap->ps.clientNum;
ADDRLP4 8
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $694
JUMPV
LABELV $693
line 682
;682:		else if (param < 0)
ADDRFP4 8
INDIRI4
CNSTI4 0
GEI4 $696
line 683
;683:			clientNum = cg_currentSelectedPlayer.integer;
ADDRLP4 8
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ASGNI4
ADDRGP4 $697
JUMPV
LABELV $696
line 684
;684:		else if (param >= 1)
ADDRFP4 8
INDIRI4
CNSTI4 1
LTI4 $699
line 685
;685:			clientNum = param;
ADDRLP4 8
ADDRFP4 8
INDIRI4
ASGNI4
LABELV $699
LABELV $697
LABELV $694
line 687
;686:
;687:		if (sortedTeamPlayers[clientNum] == cg.snap->ps.clientNum)
ADDRLP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $701
line 688
;688:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $684
JUMPV
LABELV $701
line 689
;689:		else {
line 691
;690:			clientInfo_t *ci;
;691:			ci = cgs.clientinfo + sortedTeamPlayers[clientNum];
ADDRLP4 16
ADDRLP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 692
;692:			if (!ci || !ci->infoValid)
ADDRLP4 20
ADDRLP4 16
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $707
ADDRLP4 20
INDIRP4
INDIRI4
CNSTI4 0
NEI4 $705
LABELV $707
line 693
;693:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $684
JUMPV
LABELV $705
line 694
;694:		}
line 695
;695:	}
LABELV $688
line 696
;696:	return qtrue;
CNSTI4 1
RETI4
LABELV $684
endproc check_vis_teamPlayer_cases 24 0
export CG_HUDItemVisible
proc CG_HUDItemVisible 44 12
line 700
;697:}
;698:
;699:// items in the HUD file are visible, unless specified
;700:qboolean CG_HUDItemVisible(const item_t * itm) {
line 701
;701:	if (itm->visible_prop_flags[0] & VIS_NEVER) {
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $709
line 702
;702:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $709
line 704
;703:	}
;704:	else {
line 708
;705:		// 0: visible cases / 1: hidden cases
;706:
;707:		// general visibility flags
;708:		if (!check_vis_gen_cases(itm->visible_prop_flags, 0))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 0
ADDRGP4 check_vis_gen_cases
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $711
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $711
line 709
;709:		if (!check_vis_gen_cases(itm->visible_prop_flags, 1))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 4
ADDRGP4 check_vis_gen_cases
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $713
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $713
line 712
;710:
;711:		// team play visibility flags
;712:		if (!check_vis_GT_cases(itm->visible_GT_flags, 0))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1076
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 8
ADDRGP4 check_vis_GT_cases
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $715
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $715
line 713
;713:		if (!check_vis_GT_cases(itm->visible_GT_flags, 1))	return qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 1076
ADDP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 12
ADDRGP4 check_vis_GT_cases
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $717
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $717
line 716
;714:
;715:		// value visibility flags
;716:		if (!check_vis_val_cases(itm->visible_val_flags, 0, itm->param))	return qfalse;
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
CNSTI4 1068
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 check_vis_val_cases
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $719
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $719
line 717
;717:		if (!check_vis_val_cases(itm->visible_val_flags, 1, itm->param))	return qfalse;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
CNSTI4 1068
ADDP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 24
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 check_vis_val_cases
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $721
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $721
line 720
;718:
;719:		// team player item visibility
;720:		if (!check_vis_teamPlayer_cases(itm->visible_GT_flags, 0, itm->team_player))	return qfalse;
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI4 1076
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 32
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 36
ADDRGP4 check_vis_teamPlayer_cases
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $723
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $723
line 723
;721:		//if (!check_vis_teamPlayer_cases(itm->visible_GT_flags, 1, itm->team_player))	return qfalse;
;722:
;723:		if (!cvarTest(itm->cvarTest_flags))
ADDRFP4 0
INDIRP4
CNSTI4 1084
ADDP4
INDIRU4
CVUI4 4
ARGI4
ADDRLP4 40
ADDRGP4 cvarTest
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $725
line 724
;724:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $708
JUMPV
LABELV $725
line 725
;725:	}
line 726
;726:	return qtrue;
CNSTI4 1
RETI4
LABELV $708
endproc CG_HUDItemVisible 44 12
export createScoreRatio
proc createScoreRatio 4 0
line 730
;727:}
;728:
;729:// TODO create a ratio score1 / score2 depending of itm->param
;730:float createScoreRatio(int param) {
line 732
;731:	// player's score, or player team
;732:	if (param == 1) {
ADDRFP4 0
INDIRI4
CNSTI4 1
NEI4 $728
line 733
;733:		return (cgs.scores1 > cgs.scores2) ? 1.0f : 0.0f;
ADDRGP4 cgs+34824
INDIRI4
ADDRGP4 cgs+34828
INDIRI4
LEI4 $733
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $734
JUMPV
LABELV $733
ADDRLP4 0
CNSTF4 0
ASGNF4
LABELV $734
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $727
JUMPV
LABELV $728
line 736
;734:	}
;735:	// other's score
;736:	else if (param == 2) {
ADDRFP4 0
INDIRI4
CNSTI4 2
NEI4 $735
line 737
;737:		return (cgs.scores2 > cgs.scores1) ? 1.0f : 0.0f;
ADDRGP4 cgs+34828
INDIRI4
ADDRGP4 cgs+34824
INDIRI4
LEI4 $740
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $741
JUMPV
LABELV $740
ADDRLP4 0
CNSTF4 0
ASGNF4
LABELV $741
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $727
JUMPV
LABELV $735
line 739
;738:	}
;739:	return 1.0f;
CNSTF4 1065353216
RETF4
LABELV $727
endproc createScoreRatio 4 0
export HUD_GradientValue
proc HUD_GradientValue 32 12
line 743
;740:}
;741:
;742://get gradient value for Health | Armor | Ammo | Weapon | Score | Time | HoldableItem | FPS | Speed | Fraglimit | Timelimit
;743:float HUD_GradientValue(item_t *itm) {
line 744
;744:	if (itm->gradientFlags & VAL_HEALTH) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $743
line 747
;745:		int				health;
;746:		int				maxHealth;
;747:		health = HUD_PropValue(itm, VAL_HEALTH, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 8
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 748
;748:		maxHealth = HUD_SoftLimit(VAL_HEALTH, itm->param);
CNSTI4 8
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
line 749
;749:		if (itm->param == 2) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 2
NEI4 $745
line 751
;750:			// show health below the soft limit
;751:			if (health > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $747
line 752
;752:				return ((float)(health - maxHealth) / (float)maxHealth);
ADDRLP4 20
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
CVIF4 4
ADDRLP4 20
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $747
line 754
;753:			else
;754:				return 0;
CNSTF4 0
RETF4
ADDRGP4 $742
JUMPV
LABELV $745
line 756
;755:		}
;756:		else {
line 758
;757:			// show health above the soft limit
;758:			if (health > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $749
line 759
;759:				return 1.0f;
CNSTF4 1065353216
RETF4
ADDRGP4 $742
JUMPV
LABELV $749
line 761
;760:			else
;761:				return ((float)health / (float)maxHealth);
ADDRLP4 4
INDIRI4
CVIF4 4
ADDRLP4 0
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $743
line 764
;762:		}
;763:	}
;764:	else if (itm->gradientFlags & VAL_ARMOR) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $751
line 767
;765:		int				armor;
;766:		int				maxHealth;
;767:		armor = HUD_PropValue(itm, VAL_ARMOR, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 768
;768:		maxHealth = HUD_SoftLimit(VAL_ARMOR, itm->param);
CNSTI4 16
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
line 770
;769:
;770:		if (itm->param == 2) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 2
NEI4 $753
line 772
;771:			// show health below the soft limit
;772:			if (armor > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $755
line 773
;773:				return ((float)(armor - maxHealth) / (float)maxHealth);
ADDRLP4 20
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
CVIF4 4
ADDRLP4 20
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $755
line 775
;774:			else
;775:				return 0;
CNSTF4 0
RETF4
ADDRGP4 $742
JUMPV
LABELV $753
line 777
;776:		}
;777:		else {
line 779
;778:			// show health above the soft limit
;779:			if (armor > maxHealth)
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LEI4 $757
line 780
;780:				return 1.0f;
CNSTF4 1065353216
RETF4
ADDRGP4 $742
JUMPV
LABELV $757
line 782
;781:			else
;782:				return ((float)armor / (float)maxHealth);
ADDRLP4 4
INDIRI4
CVIF4 4
ADDRLP4 0
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $751
line 785
;783:		}
;784:	}
;785:	else if (itm->gradientFlags & VAL_AMMO) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $759
line 788
;786:		int				weapon;
;787:		int				ammoSoftLimit;
;788:		weapon = HUD_PropValue(itm, VAL_AMMO, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 4
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
line 789
;789:		ammoSoftLimit = HUD_AmmoSoftLimit(weapon);
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
line 790
;790:		if (ammoSoftLimit > 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
LEI4 $760
line 791
;791:			return (float)weapon / (float)ammoSoftLimit;
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
line 793
;792:		}
;793:	}
LABELV $759
line 794
;794:	else if (itm->gradientFlags & VAL_WEAPON) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $763
line 797
;795:		int				weapon;
;796:		int				ammoSoftLimit;
;797:		weapon = HUD_PropValue(itm, VAL_WEAPON, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 32
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
line 798
;798:		ammoSoftLimit = HUD_AmmoSoftLimit(weapon);
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_AmmoSoftLimit
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 16
INDIRI4
ASGNI4
line 799
;799:		if (ammoSoftLimit>0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
LEI4 $764
line 800
;800:			return (float)weapon / (float)ammoSoftLimit;
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
line 802
;801:		}
;802:	}
LABELV $763
line 803
;803:	else if (itm->gradientFlags & VAL_SCORE || itm->gradientFlags & VAL_CAPFRAG_LIMIT) {
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
NEU4 $769
ADDRLP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $767
LABELV $769
line 804
;804:		int slimit = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
LTI4 $774
ADDRLP4 8
ADDRGP4 cgs+31496
INDIRI4
ASGNI4
ADDRGP4 $775
JUMPV
LABELV $774
ADDRLP4 8
ADDRGP4 cgs+31492
INDIRI4
ASGNI4
LABELV $775
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 805
;805:		if (slimit > 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
LEI4 $776
line 806
;806:			int itmVal = HUD_PropValue(itm, VAL_SCORE, itm->param);
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ARGP4
CNSTI4 1024
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 20
INDIRI4
ASGNI4
line 807
;807:			return (float)itmVal / (float)slimit;
ADDRLP4 12
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $776
line 809
;808:		}
;809:		else {
line 810
;810:			return createScoreRatio(itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 createScoreRatio
CALLF4
ASGNF4
ADDRLP4 12
INDIRF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $767
line 814
;811:		}
;812:	}
;813:
;814:	else if (itm->gradientFlags & VAL_FRAG_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $778
line 815
;815:		if (cgs.fraglimit > 0) {
ADDRGP4 cgs+31492
INDIRI4
CNSTI4 0
LEI4 $780
line 816
;816:			return (float)cg.snap->ps.persistant[PERS_SCORE] / (float)cgs.fraglimit;
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
CVIF4 4
ADDRGP4 cgs+31492
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $780
line 818
;817:		}
;818:		else {
line 819
;819:			return createScoreRatio(itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 createScoreRatio
CALLF4
ASGNF4
ADDRLP4 4
INDIRF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $778
line 822
;820:		}
;821:	}
;822:	else if (itm->gradientFlags & VAL_CAPTURE_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $785
line 823
;823:		if (cgs.fraglimit > 0) {
ADDRGP4 cgs+31492
INDIRI4
CNSTI4 0
LEI4 $787
line 824
;824:			return (float)cg.snap->ps.persistant[PERS_SCORE] / (float)cgs.capturelimit;
ADDRGP4 cg+36
INDIRP4
CNSTI4 292
ADDP4
INDIRI4
CVIF4 4
ADDRGP4 cgs+31496
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $787
line 826
;825:		}
;826:		else {
line 827
;827:			return createScoreRatio(itm->param);
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 createScoreRatio
CALLF4
ASGNF4
ADDRLP4 4
INDIRF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $785
line 831
;828:		}
;829:	}
;830:
;831:	else if (itm->gradientFlags & VAL_TIMER || itm->gradientFlags & VAL_TIME_LIMIT) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
NEU4 $794
ADDRLP4 4
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $792
LABELV $794
line 832
;832:		if (cgs.timelimit > 0) {
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 0
LEI4 $795
line 835
;833:			int time_sec;
;834:			int timelimit_secs;
;835:			time_sec = HUD_PropValue(itm, VAL_TIMER, itm->param);
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ARGP4
CNSTI4 256
ARGI4
ADDRLP4 16
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 20
INDIRI4
ASGNI4
line 836
;836:			timelimit_secs = HUD_PropValue(itm, VAL_TIME_LIMIT, itm->param);
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
ARGP4
CNSTI4 16384
ARGI4
ADDRLP4 24
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 28
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 28
INDIRI4
ASGNI4
line 837
;837:			return (float)time_sec / (float)timelimit_secs;
ADDRLP4 8
INDIRI4
CVIF4 4
ADDRLP4 12
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $795
line 839
;838:		}
;839:		else {
line 840
;840:			return 1;
CNSTF4 1065353216
RETF4
ADDRGP4 $742
JUMPV
LABELV $792
line 843
;841:		}
;842:	}
;843:	else if (itm->gradientFlags & VAL_HOLDABLE_ITEM) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $798
line 844
;844:		return (float)HUD_PropValue(itm, VAL_HOLDABLE_ITEM, itm->param) / (float)HOLDABLE_ITEM_SOFT_LIMIT;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CVIF4 4
CNSTF4 1015580809
MULF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $798
line 846
;845:	}
;846:	else if (itm->gradientFlags & VAL_FPS) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $800
line 847
;847:		return (float)FPS / (float)HUD_SoftLimit(VAL_FPS, itm->param);
CNSTI4 128
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 HUD_SoftLimit
CALLI4
ASGNI4
ADDRGP4 FPS
INDIRI4
CVIF4 4
ADDRLP4 8
INDIRI4
CVIF4 4
DIVF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $800
line 849
;848:	}
;849:	else if (itm->gradientFlags & VAL_SPEED) {
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $802
line 850
;850:		return cg.xyspeed / (float)SPEED_SOFT_LIMIT;
ADDRGP4 cg+117976
INDIRF4
CNSTF4 990057071
MULF4
RETF4
ADDRGP4 $742
JUMPV
LABELV $802
LABELV $764
LABELV $760
line 852
;851:	}
;852:	return 1.0f;
CNSTF4 1065353216
RETF4
LABELV $742
endproc HUD_GradientValue 32 12
proc HUD_ColorIdx 16 4
line 855
;853:}
;854:
;855:static int HUD_ColorIdx(item_t *itm, int value) {
line 859
;856:	int	col_id;
;857:	int softLimit;
;858:
;859:	if (!(itm->forecolor.colorflags & C_COLOR_RGBA) ) {
ADDRFP4 0
INDIRP4
CNSTI4 1168
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
NEU4 $806
line 861
;860:
;861:		softLimit = HUD_ItemSoftLimit(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 HUD_ItemSoftLimit
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 863
;862:
;863:		if (value > softLimit - 1) {
ADDRFP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 1
SUBI4
LEI4 $808
line 864
;864:			col_id = 3; // white
ADDRLP4 0
CNSTI4 3
ASGNI4
line 865
;865:		}
ADDRGP4 $809
JUMPV
LABELV $808
line 866
;866:		else if (value > (softLimit / 4)) {
ADDRFP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 4
DIVI4
LEI4 $810
line 867
;867:			col_id = 0; // yellow
ADDRLP4 0
CNSTI4 0
ASGNI4
line 868
;868:		}
ADDRGP4 $811
JUMPV
LABELV $810
line 869
;869:		else if (value > 0) {
ADDRFP4 4
INDIRI4
CNSTI4 0
LEI4 $812
line 870
;870:			if (itm->propFlags & PROP_BLINK_WHEN_LOW) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $814
line 871
;871:				col_id = ((cg.time >> 8) & 1) ? 1 : 0; // red / yellow flashing
ADDRGP4 cg+107604
INDIRI4
CNSTI4 8
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $818
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRGP4 $819
JUMPV
LABELV $818
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $819
ADDRLP4 0
ADDRLP4 12
INDIRI4
ASGNI4
line 872
;872:			}
ADDRGP4 $813
JUMPV
LABELV $814
line 874
;873:			else
;874:				col_id = 1; // red
ADDRLP4 0
CNSTI4 1
ASGNI4
line 875
;875:		}
ADDRGP4 $813
JUMPV
LABELV $812
line 876
;876:		else {
line 877
;877:			col_id = 1; // red
ADDRLP4 0
CNSTI4 1
ASGNI4
line 878
;878:		}
LABELV $813
LABELV $811
LABELV $809
line 879
;879:	}
LABELV $806
line 880
;880:	return col_id;
ADDRLP4 0
INDIRI4
RETI4
LABELV $805
endproc HUD_ColorIdx 16 4
export copyColor
proc copyColor 0 0
line 883
;881:}
;882:
;883:void copyColor(vec4_t colSource, vec4_t *colDest) {
line 884
;884:	(*colDest)[0] = colSource[0];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
INDIRF4
ASGNF4
line 885
;885:	(*colDest)[1] = colSource[1];
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ASGNF4
line 886
;886:	(*colDest)[2] = colSource[2];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ASGNF4
line 887
;887:	(*colDest)[3] = colSource[3];
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ASGNF4
line 888
;888:}
LABELV $820
endproc copyColor 0 0
export HUD_color
proc HUD_color 20 8
line 890
;889:
;890:void HUD_color(item_t *itm, color_Def_t *colDef, vec4_t *colDest, vec4_t defaultCol) {
line 891
;891:	if (colDef->colorflags & C_COLOR_RGBA) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $822
line 892
;892:		copyColor(colDef->color, colDest);
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 893
;893:	}
ADDRGP4 $823
JUMPV
LABELV $822
line 894
;894:	else {
line 895
;895:		if (colDef->colorflags & C_COLORS_HEALTH || colDef->colorflags & C_COLORS_ARMOR ||
ADDRLP4 0
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
NEU4 $828
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
NEU4 $828
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
NEU4 $828
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $824
LABELV $828
line 896
;896:			colDef->colorflags & C_COLORS_AMMO || colDef->colorflags & C_COLORS_TEAMS) {
line 897
;897:			int value = HUD_ItemCaptionValue(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 HUD_ItemCaptionValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 898
;898:			int idx = HUD_ColorIdx(itm, value);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 HUD_ColorIdx
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 16
INDIRI4
ASGNI4
line 899
;899:			if (colDef->colorflags & C_COLORS_HEALTH) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $829
line 900
;900:				copyColor(health_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 health_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 901
;901:			}
ADDRGP4 $825
JUMPV
LABELV $829
line 902
;902:			else if (colDef->colorflags & C_COLORS_ARMOR) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $831
line 903
;903:				copyColor(armor_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 armor_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 904
;904:			}
ADDRGP4 $825
JUMPV
LABELV $831
line 905
;905:			else if (colDef->colorflags & C_COLORS_AMMO) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $833
line 906
;906:				copyColor(ammo_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 ammo_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 907
;907:			}
ADDRGP4 $825
JUMPV
LABELV $833
line 908
;908:			else if (colDef->colorflags & C_COLORS_TEAMS) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $825
line 909
;909:				copyColor(teams_colors[idx], colDest);
ADDRLP4 8
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 teams_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 910
;910:			}
line 911
;911:		}
ADDRGP4 $825
JUMPV
LABELV $824
line 912
;912:		else if (colDef->colorflags & C_COLOR_TEAM) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $837
line 913
;913:			copyColor(teams_colors[playerTeam], colDest);
ADDRGP4 playerTeam
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 teams_colors
ADDP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 914
;914:		}
ADDRGP4 $838
JUMPV
LABELV $837
line 915
;915:		else if (colDef->colorflags & C_COLOR_BLUE_TEAM) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $839
line 916
;916:			copyColor(teams_colors[HUD_TEAM_BLUE], colDest);
ADDRGP4 teams_colors+32
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 917
;917:		}
ADDRGP4 $840
JUMPV
LABELV $839
line 918
;918:		else if (colDef->colorflags & C_COLOR_RED_TEAM) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $842
line 919
;919:			copyColor(teams_colors[HUD_TEAM_RED], colDest);
ADDRGP4 teams_colors+16
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 920
;920:		}
ADDRGP4 $843
JUMPV
LABELV $842
line 921
;921:		else if (colDef->colorflags & C_COLOR_NME) {
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $845
line 923
;922:			// use opposite team color
;923:			if (playerTeam == HUD_TEAM_RED) {
ADDRGP4 playerTeam
INDIRI4
CNSTI4 1
NEI4 $847
line 924
;924:				copyColor(teams_colors[HUD_TEAM_BLUE], colDest);
ADDRGP4 teams_colors+32
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 925
;925:			}
ADDRGP4 $846
JUMPV
LABELV $847
line 926
;926:			else {
line 927
;927:				copyColor(teams_colors[HUD_TEAM_RED], colDest);
ADDRGP4 teams_colors+16
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 928
;928:			}
line 929
;929:		}
ADDRGP4 $846
JUMPV
LABELV $845
line 930
;930:		else {
line 931
;931:			copyColor(defaultCol, colDest);
ADDRFP4 12
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 copyColor
CALLV
pop
line 932
;932:		}
LABELV $846
LABELV $843
LABELV $840
LABELV $838
LABELV $825
line 934
;933:
;934:		if (/*colDef->colorflags & C_COLOR_FORCE_ALPHA*/ colDef->alpha)
ADDRFP4 4
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
CNSTF4 0
EQF4 $851
line 935
;935:			(*colDest)[3] = colDef->alpha;
ADDRFP4 8
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 4
INDIRP4
CNSTI4 20
ADDP4
INDIRF4
ASGNF4
LABELV $851
line 936
;936:	}
LABELV $823
line 937
;937:}
LABELV $821
endproc HUD_color 20 8
export HUD_DrawGradientBackground
proc HUD_DrawGradientBackground 36 40
line 939
;938:
;939:void HUD_DrawGradientBackground(item_t *itm, rectangle_t *r) {
line 946
;940:	qboolean	orientationInv;
;941:	qhandle_t	shader;
;942:	float		value;
;943:	float		size;
;944:
;945:	//invert the gradient direction
;946:	orientationInv = (itm->propFlags & PROP_GRADIENT_INVERT);
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CVUI4 4
ASGNI4
line 949
;947:
;948:	// allow color gradient when background not provided
;949:	shader = CG_HUDShader(itm, cgs.media.whiteShader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 cgs+148752+16
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 CG_HUDShader
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 951
;950:
;951:	value = HUD_GradientValue(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 HUD_GradientValue
CALLF4
ASGNF4
ADDRLP4 4
ADDRLP4 20
INDIRF4
ASGNF4
line 953
;952:
;953:	if (itm->propFlags & PROP_VERTICALBAR) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $856
line 955
;954:
;955:		if (orientationInv) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $858
line 957
;956:			// vertical top -> bottom
;957:			size = value;
ADDRLP4 0
ADDRLP4 4
INDIRF4
ASGNF4
line 958
;958:			CG_DrawGradientPic(itm, r->x, r->y, r->w, (r->h*size), 0, 0, 1, size, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 959
;959:		}
ADDRGP4 $857
JUMPV
LABELV $858
line 960
;960:		else {
line 961
;961:			int invSize = 1 - value;
ADDRLP4 24
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
SUBF4
CVFI4 4
ASGNI4
line 963
;962:			// vertical bottom -> top
;963:			size = 1 - value;
ADDRLP4 0
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
SUBF4
ASGNF4
line 965
;964:
;965:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $860
line 966
;966:				r->x += r->w;
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 967
;967:				r->w = -r->w;
ADDRLP4 32
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 32
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 968
;968:			}
LABELV $860
line 969
;969:			CG_DrawGradientPic(itm, r->x, r->y + (r->h*size), r->w, r->h - (r->h*size), 0, size, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
INDIRF4
ARGF4
ADDRLP4 28
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDF4
ARGF4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 28
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
SUBF4
ARGF4
CNSTF4 0
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 970
;970:		}
line 971
;971:	}
ADDRGP4 $857
JUMPV
LABELV $856
line 972
;972:	else {
line 973
;973:		if (orientationInv) {
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $862
line 975
;974:			// horizontal right -> left
;975:			size = 1 - value;
ADDRLP4 0
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
SUBF4
ASGNF4
line 976
;976:			CG_DrawGradientPic(itm, r->x + (r->w*size), r->y, r->w - (r->w*size), r->h, size, 0, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
INDIRF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
SUBF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 977
;977:		}
ADDRGP4 $863
JUMPV
LABELV $862
line 978
;978:		else {
line 980
;979:			// horizontal left -> right
;980:			size = value;
ADDRLP4 0
ADDRLP4 4
INDIRF4
ASGNF4
line 981
;981:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $864
line 982
;982:				r->x += (r->w*size);
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ADDF4
ASGNF4
line 983
;983:				r->w = -r->w;
ADDRLP4 28
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 28
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 984
;984:			}
LABELV $864
line 986
;985:
;986:			CG_DrawGradientPic(itm, r->x, r->y, (r->w*size), r->h, 0, 0, size, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDRLP4 0
INDIRF4
MULF4
ARGF4
ADDRLP4 24
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
ADDRLP4 0
INDIRF4
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 987
;987:		}
LABELV $863
line 988
;988:	}
LABELV $857
line 989
;989:}
LABELV $853
endproc HUD_DrawGradientBackground 36 40
export CG_CheckOrderPending
proc CG_CheckOrderPending 28 12
line 992
;990:
;991:// from cg_newdraw.c
;992:void CG_CheckOrderPending() {
line 997
;993:	// order pending was only CTF in Team Arena
;994:	/*if (cgs.gametype < GT_CTF) {
;995:		return;
;996:	}*/
;997:	if (cgs.gametype < GT_TEAM) {
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 3
GEI4 $867
line 998
;998:		return;
ADDRGP4 $866
JUMPV
LABELV $867
line 1001
;999:	}
;1000:
;1001:	if (cgs.orderPending) {
ADDRGP4 cgs+148696
INDIRI4
CNSTI4 0
EQI4 $870
line 1003
;1002:		const char *p1, *p2, *b;
;1003:		p1 = p2 = b = NULL;
ADDRLP4 12
CNSTP4 0
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 12
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 12
INDIRP4
ASGNP4
line 1004
;1004:		switch (cgs.currentOrder) {
ADDRLP4 16
ADDRGP4 cgs+148692
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 1
LTI4 $873
ADDRLP4 16
INDIRI4
CNSTI4 7
GTI4 $873
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $901-4
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $901
address $876
address $880
address $884
address $888
address $895
address $898
address $892
code
LABELV $876
line 1006
;1005:		case TEAMTASK_OFFENSE:
;1006:			p1 = VOICECHAT_ONOFFENSE;
ADDRLP4 8
ADDRGP4 $877
ASGNP4
line 1007
;1007:			p2 = VOICECHAT_OFFENSE;
ADDRLP4 4
ADDRGP4 $878
ASGNP4
line 1008
;1008:			b = "+button7; wait; -button7";
ADDRLP4 0
ADDRGP4 $879
ASGNP4
line 1009
;1009:			break;
ADDRGP4 $874
JUMPV
LABELV $880
line 1011
;1010:		case TEAMTASK_DEFENSE:
;1011:			p1 = VOICECHAT_ONDEFENSE;
ADDRLP4 8
ADDRGP4 $881
ASGNP4
line 1012
;1012:			p2 = VOICECHAT_DEFEND;
ADDRLP4 4
ADDRGP4 $882
ASGNP4
line 1013
;1013:			b = "+button8; wait; -button8";
ADDRLP4 0
ADDRGP4 $883
ASGNP4
line 1014
;1014:			break;
ADDRGP4 $874
JUMPV
LABELV $884
line 1016
;1015:		case TEAMTASK_PATROL:
;1016:			p1 = VOICECHAT_ONPATROL;
ADDRLP4 8
ADDRGP4 $885
ASGNP4
line 1017
;1017:			p2 = VOICECHAT_PATROL;
ADDRLP4 4
ADDRGP4 $886
ASGNP4
line 1018
;1018:			b = "+button9; wait; -button9";
ADDRLP4 0
ADDRGP4 $887
ASGNP4
line 1019
;1019:			break;
ADDRGP4 $874
JUMPV
LABELV $888
line 1021
;1020:		case TEAMTASK_FOLLOW:
;1021:			p1 = VOICECHAT_ONFOLLOW;
ADDRLP4 8
ADDRGP4 $889
ASGNP4
line 1022
;1022:			p2 = VOICECHAT_FOLLOWME;
ADDRLP4 4
ADDRGP4 $890
ASGNP4
line 1023
;1023:			b = "+button10; wait; -button10";
ADDRLP4 0
ADDRGP4 $891
ASGNP4
line 1024
;1024:			break;
ADDRGP4 $874
JUMPV
LABELV $892
line 1026
;1025:		case TEAMTASK_CAMP:
;1026:			p1 = VOICECHAT_ONCAMPING;
ADDRLP4 8
ADDRGP4 $893
ASGNP4
line 1027
;1027:			p2 = VOICECHAT_CAMP;
ADDRLP4 4
ADDRGP4 $894
ASGNP4
line 1028
;1028:			break;
ADDRGP4 $874
JUMPV
LABELV $895
line 1030
;1029:		case TEAMTASK_RETRIEVE:
;1030:			p1 = VOICECHAT_ONGETFLAG;
ADDRLP4 8
ADDRGP4 $896
ASGNP4
line 1031
;1031:			p2 = VOICECHAT_RETURNFLAG;
ADDRLP4 4
ADDRGP4 $897
ASGNP4
line 1032
;1032:			break;
ADDRGP4 $874
JUMPV
LABELV $898
line 1034
;1033:		case TEAMTASK_ESCORT:
;1034:			p1 = VOICECHAT_ONFOLLOWCARRIER;
ADDRLP4 8
ADDRGP4 $899
ASGNP4
line 1035
;1035:			p2 = VOICECHAT_FOLLOWFLAGCARRIER;
ADDRLP4 4
ADDRGP4 $900
ASGNP4
line 1036
;1036:			break;
LABELV $873
LABELV $874
line 1038
;1037:		}
;1038:		if (cg_currentSelectedPlayer.integer == numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
NEI4 $903
line 1040
;1039:			// to everyone
;1040:			trap_SendConsoleCommand(va("cmd vsay_team %s\n", p2));
ADDRGP4 $906
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 20
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1041
;1041:		}
ADDRGP4 $904
JUMPV
LABELV $903
line 1042
;1042:		else {
line 1044
;1043:			// for the player self
;1044:			if (sortedTeamPlayers[cg_currentSelectedPlayer.integer] == cg.snap->ps.clientNum && p1) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $907
ADDRLP4 8
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $907
line 1045
;1045:				trap_SendConsoleCommand(va("teamtask %i\n", cgs.currentOrder));
ADDRGP4 $911
ARGP4
ADDRGP4 cgs+148692
INDIRI4
ARGI4
ADDRLP4 20
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 20
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1047
;1046:				//trap_SendConsoleCommand(va("cmd say_team %s\n", p2));
;1047:				trap_SendConsoleCommand(va("cmd vsay_team %s\n", p1));
ADDRGP4 $906
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 24
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1048
;1048:			}
ADDRGP4 $908
JUMPV
LABELV $907
line 1049
;1049:			else if (p2) {
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $913
line 1051
;1050:				//trap_SendConsoleCommand(va("cmd say_team %s, %s\n", ci->name,p));
;1051:				trap_SendConsoleCommand(va("cmd vtell %d %s\n", sortedTeamPlayers[cg_currentSelectedPlayer.integer], p2));
ADDRGP4 $915
ARGP4
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 20
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1052
;1052:			}
LABELV $913
LABELV $908
line 1053
;1053:		}
LABELV $904
line 1054
;1054:		if (b) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $917
line 1055
;1055:			trap_SendConsoleCommand(b);
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 trap_SendConsoleCommand
CALLV
pop
line 1056
;1056:		}
LABELV $917
line 1057
;1057:		cgs.orderPending = qfalse;
ADDRGP4 cgs+148696
CNSTI4 0
ASGNI4
line 1058
;1058:	}
LABELV $870
line 1059
;1059:}
LABELV $866
endproc CG_CheckOrderPending 28 12
export CG_OtherTeamHasFlag
proc CG_OtherTeamHasFlag 8 0
line 1063
;1060:
;1061:
;1062:// from cg_newdraw.c
;1063:qboolean CG_OtherTeamHasFlag() {
line 1064
;1064:	if (cgs.gametype == GT_CTF
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
NEI4 $921
line 1068
;1065:#ifdef MISSIONPACK
;1066:		|| cgs.gametype == GT_1FCTF
;1067:#endif
;1068:		) {
line 1069
;1069:		int team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 1077
;1070:#ifdef MISSIONPACK
;1071:		if (cgs.gametype == GT_1FCTF) {
;1072:			return ((team == TEAM_RED && cgs.flagStatus == FLAG_TAKEN_BLUE) || 
;1073:					(team == TEAM_BLUE && cgs.flagStatus == FLAG_TAKEN_RED));
;1074:		}
;1075:		else {
;1076:#endif
;1077:			return ((team == TEAM_RED && cgs.redflag == FLAG_TAKEN) ||
ADDRLP4 0
INDIRI4
CNSTI4 1
NEI4 $931
ADDRGP4 cgs+34832
INDIRI4
CNSTI4 1
EQI4 $930
LABELV $931
ADDRLP4 0
INDIRI4
CNSTI4 2
NEI4 $928
ADDRGP4 cgs+34836
INDIRI4
CNSTI4 1
NEI4 $928
LABELV $930
ADDRLP4 4
CNSTI4 1
ASGNI4
ADDRGP4 $929
JUMPV
LABELV $928
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $929
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $920
JUMPV
LABELV $921
line 1083
;1078:					(team == TEAM_BLUE && cgs.blueflag == FLAG_TAKEN));
;1079:#ifdef MISSIONPACK
;1080:		}
;1081:#endif
;1082:	}
;1083:	return qfalse;
CNSTI4 0
RETI4
LABELV $920
endproc CG_OtherTeamHasFlag 8 0
export CG_YourTeamHasFlag
proc CG_YourTeamHasFlag 8 0
line 1086
;1084:}
;1085:
;1086:qboolean CG_YourTeamHasFlag() {
line 1087
;1087:	if (cgs.gametype == GT_CTF
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
NEI4 $933
line 1091
;1088:#ifdef MISSIONPACK
;1089:		|| cgs.gametype == GT_1FCTF
;1090:#endif
;1091:		) {
line 1092
;1092:		int team = cg.snap->ps.persistant[PERS_TEAM];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 304
ADDP4
INDIRI4
ASGNI4
line 1100
;1093:#ifdef MISSIONPACK
;1094:		if (cgs.gametype == GT_1FCTF) {
;1095:			return ((team == TEAM_RED && cgs.flagStatus == FLAG_TAKEN_RED) || 
;1096:					(team == TEAM_BLUE && cgs.flagStatus == FLAG_TAKEN_BLUE))
;1097:		}
;1098:		else {
;1099:#endif
;1100:			return ((team == TEAM_RED && cgs.blueflag == FLAG_TAKEN) || 
ADDRLP4 0
INDIRI4
CNSTI4 1
NEI4 $943
ADDRGP4 cgs+34836
INDIRI4
CNSTI4 1
EQI4 $942
LABELV $943
ADDRLP4 0
INDIRI4
CNSTI4 2
NEI4 $940
ADDRGP4 cgs+34832
INDIRI4
CNSTI4 1
NEI4 $940
LABELV $942
ADDRLP4 4
CNSTI4 1
ASGNI4
ADDRGP4 $941
JUMPV
LABELV $940
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $941
ADDRLP4 4
INDIRI4
RETI4
ADDRGP4 $932
JUMPV
LABELV $933
line 1106
;1101:					(team == TEAM_BLUE && cgs.redflag == FLAG_TAKEN));
;1102:#ifdef MISSIONPACK
;1103:		}
;1104:#endif
;1105:	}
;1106:	return qfalse;
CNSTI4 0
RETI4
LABELV $932
endproc CG_YourTeamHasFlag 8 0
proc CG_SetSelectedPlayerName 8 8
line 1110
;1107:}
;1108:
;1109:// from cg_newdraw.c
;1110:static void CG_SetSelectedPlayerName() {
line 1111
;1111:	if (cg_currentSelectedPlayer.integer >= 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 0
LTI4 $945
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
GEI4 $945
line 1112
;1112:		clientInfo_t *ci = cgs.clientinfo + sortedTeamPlayers[cg_currentSelectedPlayer.integer];
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 1113
;1113:		if (ci) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $946
line 1114
;1114:			trap_Cvar_Set("cg_selectedPlayerName", ci->name);
ADDRGP4 $953
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 trap_Cvar_Set
CALLV
pop
line 1115
;1115:			trap_Cvar_Set("cg_selectedPlayer", va("%d", sortedTeamPlayers[cg_currentSelectedPlayer.integer]));
ADDRGP4 $955
ARGP4
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRGP4 $954
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 trap_Cvar_Set
CALLV
pop
line 1116
;1116:			cgs.currentOrder = ci->teamTask;
ADDRGP4 cgs+148692
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRI4
ASGNI4
line 1117
;1117:		}
line 1118
;1118:	}
ADDRGP4 $946
JUMPV
LABELV $945
line 1119
;1119:	else {
line 1120
;1120:		trap_Cvar_Set("cg_selectedPlayerName", "Everyone");
ADDRGP4 $953
ARGP4
ADDRGP4 $958
ARGP4
ADDRGP4 trap_Cvar_Set
CALLV
pop
line 1121
;1121:	}
LABELV $946
line 1122
;1122:}
LABELV $944
endproc CG_SetSelectedPlayerName 8 8
export CG_GetSelectedPlayer
proc CG_GetSelectedPlayer 0 0
line 1124
;1123:
;1124:int CG_GetSelectedPlayer(void) {
line 1130
;1125:#ifdef MISSIONPACK
;1126:	if (cg_currentSelectedPlayer.integer < 0 || cg_currentSelectedPlayer.integer >= numSortedTeamPlayers) {
;1127:		cg_currentSelectedPlayer.integer = 0;
;1128:	}
;1129:#endif
;1130:	return cg_currentSelectedPlayer.integer;
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
RETI4
LABELV $959
endproc CG_GetSelectedPlayer 0 0
export CG_SelectNextPlayer
proc CG_SelectNextPlayer 4 0
line 1142
;1131:}
;1132:
;1133:/*
;1134:=================
;1135:CG_SelectPrevPlayer & CG_SelectNextPlayer
;1136:from MISSIONPACK
;1137:bind PGUP "prevTeamMember"
;1138:bind PGDN "nextTeamMember"
;1139:bind o "nextOrder"
;1140:=================
;1141:*/
;1142:void CG_SelectNextPlayer(void) {
line 1143
;1143:	CG_CheckOrderPending();
ADDRGP4 CG_CheckOrderPending
CALLV
pop
line 1145
;1144:
;1145:	if (cg_currentSelectedPlayer.integer >= 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 0
LTI4 $962
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
GEI4 $962
line 1146
;1146:		cg_currentSelectedPlayer.integer++;
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1147
;1147:	}
ADDRGP4 $963
JUMPV
LABELV $962
line 1148
;1148:	else {
line 1149
;1149:		cg_currentSelectedPlayer.integer = 0;
ADDRGP4 cg_currentSelectedPlayer+12
CNSTI4 0
ASGNI4
line 1150
;1150:	}
LABELV $963
line 1151
;1151:	CG_SetSelectedPlayerName();
ADDRGP4 CG_SetSelectedPlayerName
CALLV
pop
line 1152
;1152:}
LABELV $961
endproc CG_SelectNextPlayer 4 0
export CG_SelectPrevPlayer
proc CG_SelectPrevPlayer 4 0
line 1154
;1153:
;1154:void CG_SelectPrevPlayer(void) {
line 1155
;1155:	CG_CheckOrderPending();
ADDRGP4 CG_CheckOrderPending
CALLV
pop
line 1157
;1156:
;1157:	if (cg_currentSelectedPlayer.integer > 0 && cg_currentSelectedPlayer.integer <= numSortedTeamPlayers) {
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
CNSTI4 0
LEI4 $969
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
GTI4 $969
line 1158
;1158:		cg_currentSelectedPlayer.integer--;
ADDRLP4 0
ADDRGP4 cg_currentSelectedPlayer+12
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1159
;1159:	}
ADDRGP4 $970
JUMPV
LABELV $969
line 1160
;1160:	else {
line 1161
;1161:		cg_currentSelectedPlayer.integer = numSortedTeamPlayers;
ADDRGP4 cg_currentSelectedPlayer+12
ADDRGP4 numSortedTeamPlayers
INDIRI4
ASGNI4
line 1162
;1162:	}
LABELV $970
line 1163
;1163:	CG_SetSelectedPlayerName();
ADDRGP4 CG_SetSelectedPlayerName
CALLV
pop
line 1164
;1164:}
LABELV $968
endproc CG_SelectPrevPlayer 4 0
export CG_StatusHandle
proc CG_StatusHandle 8 0
line 1167
;1165:
;1166:// from cg_newdraw.c
;1167:qhandle_t CG_StatusHandle(int task) {
line 1168
;1168:	qhandle_t h = cgs.media.assaultShader;
ADDRLP4 0
ADDRGP4 cgs+148752+964
INDIRI4
ASGNI4
line 1169
;1169:	switch (task) {
ADDRLP4 4
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 1
LTI4 $978
ADDRLP4 4
INDIRI4
CNSTI4 7
GTI4 $978
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $1003-4
ADDP4
INDIRP4
JUMPV
data
align 4
LABELV $1003
address $980
address $983
address $986
address $989
address $995
address $998
address $992
code
LABELV $980
line 1171
;1170:	case TEAMTASK_OFFENSE:
;1171:		h = cgs.media.assaultShader;
ADDRLP4 0
ADDRGP4 cgs+148752+964
INDIRI4
ASGNI4
line 1172
;1172:		break;
ADDRGP4 $979
JUMPV
LABELV $983
line 1174
;1173:	case TEAMTASK_DEFENSE:
;1174:		h = cgs.media.defendShader;
ADDRLP4 0
ADDRGP4 cgs+148752+976
INDIRI4
ASGNI4
line 1175
;1175:		break;
ADDRGP4 $979
JUMPV
LABELV $986
line 1177
;1176:	case TEAMTASK_PATROL:
;1177:		h = cgs.media.patrolShader;
ADDRLP4 0
ADDRGP4 cgs+148752+960
INDIRI4
ASGNI4
line 1178
;1178:		break;
ADDRGP4 $979
JUMPV
LABELV $989
line 1180
;1179:	case TEAMTASK_FOLLOW:
;1180:		h = cgs.media.followShader;
ADDRLP4 0
ADDRGP4 cgs+148752+972
INDIRI4
ASGNI4
line 1181
;1181:		break;
ADDRGP4 $979
JUMPV
LABELV $992
line 1183
;1182:	case TEAMTASK_CAMP:
;1183:		h = cgs.media.campShader;
ADDRLP4 0
ADDRGP4 cgs+148752+968
INDIRI4
ASGNI4
line 1184
;1184:		break;
ADDRGP4 $979
JUMPV
LABELV $995
line 1186
;1185:	case TEAMTASK_RETRIEVE:
;1186:		h = cgs.media.retrieveShader;
ADDRLP4 0
ADDRGP4 cgs+148752+984
INDIRI4
ASGNI4
line 1187
;1187:		break;
ADDRGP4 $979
JUMPV
LABELV $998
line 1189
;1188:	case TEAMTASK_ESCORT:
;1189:		h = cgs.media.escortShader;
ADDRLP4 0
ADDRGP4 cgs+148752+988
INDIRI4
ASGNI4
line 1190
;1190:		break;
ADDRGP4 $979
JUMPV
LABELV $978
line 1192
;1191:	default:
;1192:		h = cgs.media.assaultShader;
ADDRLP4 0
ADDRGP4 cgs+148752+964
INDIRI4
ASGNI4
line 1193
;1193:		break;
LABELV $979
line 1195
;1194:	}
;1195:	return h;
ADDRLP4 0
INDIRI4
RETI4
LABELV $975
endproc CG_StatusHandle 8 0
export CG_DrawSelectedPlayerStatus
proc CG_DrawSelectedPlayerStatus 12 20
line 1199
;1196:}
;1197:
;1198:
;1199:void CG_DrawSelectedPlayerStatus(rectDef_t *rect, int player) {
line 1200
;1200:	clientInfo_t *ci = cgs.clientinfo + sortedTeamPlayers[player];
ADDRLP4 0
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedTeamPlayers
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 1201
;1201:	if (ci) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1007
line 1203
;1202:		qhandle_t h;
;1203:		if (cgs.orderPending && (cg_currentSelectedPlayer.integer == numSortedTeamPlayers || cg_currentSelectedPlayer.integer == player)) {
ADDRGP4 cgs+148696
INDIRI4
CNSTI4 0
EQI4 $1009
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRGP4 numSortedTeamPlayers
INDIRI4
EQI4 $1014
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ADDRFP4 4
INDIRI4
NEI4 $1009
LABELV $1014
line 1205
;1204:			// blink the icon
;1205:			if (cg.time > cgs.orderTime - 2500 && (cg.time >> 9) & 1) {
ADDRGP4 cg+107604
INDIRI4
ADDRGP4 cgs+148700
INDIRI4
CNSTI4 2500
SUBI4
LEI4 $1015
ADDRGP4 cg+107604
INDIRI4
CNSTI4 9
RSHI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $1015
line 1206
;1206:				return;
ADDRGP4 $1005
JUMPV
LABELV $1015
line 1208
;1207:			}
;1208:			h = CG_StatusHandle(cgs.currentOrder);
ADDRGP4 cgs+148692
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 CG_StatusHandle
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1209
;1209:		}
ADDRGP4 $1010
JUMPV
LABELV $1009
line 1210
;1210:		else {
line 1211
;1211:			h = CG_StatusHandle(ci->teamTask);
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 CG_StatusHandle
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1212
;1212:		}
LABELV $1010
line 1213
;1213:		CG_DrawPic(rect->x, rect->y, rect->w, rect->h, h);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 CG_DrawPic
CALLV
pop
line 1214
;1214:	}
LABELV $1007
line 1215
;1215:}
LABELV $1005
endproc CG_DrawSelectedPlayerStatus 12 20
proc CG_DrawPlayerStatus 16 20
line 1218
;1216:
;1217:// from cg_newdraw.c
;1218:static void CG_DrawPlayerStatus(rectDef_t *rect) {
line 1219
;1219:	clientInfo_t *ci = &cgs.clientinfo[cg.snap->ps.clientNum];
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996
ADDP4
ASGNP4
line 1220
;1220:	if (ci) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1024
line 1221
;1221:		qhandle_t h = CG_StatusHandle(ci->teamTask);
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 CG_StatusHandle
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1222
;1222:		CG_DrawPic(rect->x, rect->y, rect->w, rect->h, h);
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
INDIRF4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 CG_DrawPic
CALLV
pop
line 1223
;1223:	}
LABELV $1024
line 1224
;1224:}
LABELV $1021
endproc CG_DrawPlayerStatus 16 20
proc HUDParamToTeamPlayerIdx 0 0
line 1226
;1225:
;1226:static int HUDParamToTeamPlayerIdx(item_t * itm) {
line 1227
;1227:	if (itm->propFlags & PROP_TEAM_PLAYER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $1027
line 1228
;1228:		if (!itm->team_player)
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
NEI4 $1029
line 1229
;1229:			return cg.snap->ps.clientNum;
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
RETI4
ADDRGP4 $1026
JUMPV
LABELV $1029
line 1230
;1230:		else if (itm->team_player < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 0
GEI4 $1032
line 1231
;1231:			return cg_currentSelectedPlayer.integer;
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
RETI4
ADDRGP4 $1026
JUMPV
LABELV $1032
line 1233
;1232:		}
;1233:		else if (itm->team_player >= 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
CNSTI4 1
LTI4 $1035
line 1234
;1234:			return itm->team_player;
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
RETI4
ADDRGP4 $1026
JUMPV
LABELV $1035
line 1236
;1235:		}
;1236:	}
LABELV $1027
line 1237
;1237:	return cg.snap->ps.clientNum;
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
RETI4
LABELV $1026
endproc HUDParamToTeamPlayerIdx 0 0
export HUD_DrawBackground
proc HUD_DrawBackground 40 40
line 1240
;1238:}
;1239:
;1240:void HUD_DrawBackground(item_t * itm, rectangle_t *r) {
line 1241
;1241:	qhandle_t	shader = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1243
;1242:
;1243:	int param = (itm->propFlags & PROP_TEAM_PLAYER) ? itm->team_player : itm->param;
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $1040
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $1041
JUMPV
LABELV $1040
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ASGNI4
LABELV $1041
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1245
;1244:
;1245:	if (itm->iconFlags & ICON_GAME_TYPE) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1042
line 1246
;1246:		shader = cgs.media.gameTypeShader[cgs.gametype];
ADDRLP4 0
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+148752+300
ADDP4
INDIRI4
ASGNI4
line 1247
;1247:	}
ADDRGP4 $1043
JUMPV
LABELV $1042
line 1248
;1248:	else if (itm->iconFlags & ICON_HOLDABLE_ITEM) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $1047
line 1249
;1249:		int value = cg.snap->ps.stats[STAT_HOLDABLE_ITEM];
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
ASGNI4
line 1250
;1250:		if (value) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1048
line 1251
;1251:			CG_RegisterItemVisuals(value);
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_RegisterItemVisuals
CALLV
pop
line 1252
;1252:			shader = cg_items[value].icon;
ADDRLP4 0
ADDRLP4 12
INDIRI4
CNSTI4 28
MULI4
ADDRGP4 cg_items+20
ADDP4
INDIRI4
ASGNI4
line 1253
;1253:		}
line 1254
;1254:	}
ADDRGP4 $1048
JUMPV
LABELV $1047
line 1255
;1255:	else if (itm->iconFlags & ICON_BLUE_FLAG) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $1053
line 1256
;1256:		shader = cgs.media.blueFlagShader[cgs.blueflag];//GUNNM TODO icon list parsed from the HUD file
ADDRLP4 0
ADDRGP4 cgs+34836
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+148752+60
ADDP4
INDIRI4
ASGNI4
line 1257
;1257:	}
ADDRGP4 $1054
JUMPV
LABELV $1053
line 1258
;1258:	else if (itm->iconFlags & ICON_RED_FLAG) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1058
line 1259
;1259:		shader = cgs.media.redFlagShader[cgs.redflag];
ADDRLP4 0
ADDRGP4 cgs+34832
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+148752+48
ADDP4
INDIRI4
ASGNI4
line 1260
;1260:	}
ADDRGP4 $1059
JUMPV
LABELV $1058
line 1261
;1261:	else if (itm->iconFlags & ICON_ARMOR) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $1063
line 1263
;1262:		int clientNum;
;1263:		if (!param)
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1065
line 1264
;1264:			clientNum = cg.snap->ps.clientNum;
ADDRLP4 12
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $1066
JUMPV
LABELV $1065
line 1265
;1265:		else if (param < 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $1068
line 1266
;1266:			clientNum = cg_currentSelectedPlayer.integer;
ADDRLP4 12
ADDRGP4 cg_currentSelectedPlayer+12
INDIRI4
ASGNI4
line 1267
;1267:		}
ADDRGP4 $1069
JUMPV
LABELV $1068
line 1268
;1268:		else if (param >= 1)
ADDRLP4 4
INDIRI4
CNSTI4 1
LTI4 $1071
line 1269
;1269:			clientNum = param;
ADDRLP4 12
ADDRLP4 4
INDIRI4
ASGNI4
LABELV $1071
LABELV $1069
LABELV $1066
line 1270
;1270:		CG_Draw_Icon_Armor(itm, *r, clientNum);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 16
ADDRLP4 16
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_Draw_Icon_Armor
CALLV
pop
line 1271
;1271:	}
ADDRGP4 $1064
JUMPV
LABELV $1063
line 1272
;1272:	else if (itm->iconFlags & ICON_AMMO) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $1073
line 1273
;1273:		int clientNum = HUDParamToTeamPlayerIdx(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 HUDParamToTeamPlayerIdx
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 1274
;1274:		CG_Draw_Icon_Ammo(itm, *r, clientNum);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 16
ADDRLP4 20
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRGP4 CG_Draw_Icon_Ammo
CALLV
pop
line 1275
;1275:	}
ADDRGP4 $1074
JUMPV
LABELV $1073
line 1276
;1276:	else if (itm->iconFlags & ICON_POWERUP) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $1075
line 1277
;1277:		int clientNum = HUDParamToTeamPlayerIdx(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 HUDParamToTeamPlayerIdx
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 16
INDIRI4
ASGNI4
line 1278
;1278:		CG_DrawTeamPlayerPowerup(r, itm->team_player, 0 );
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
CNSTI4 0
ARGI4
ADDRGP4 CG_DrawTeamPlayerPowerup
CALLV
pop
line 1279
;1279:	}
ADDRGP4 $1076
JUMPV
LABELV $1075
line 1280
;1280:	else if (itm->iconFlags & ICON_HEAD || itm->iconFlags & ICON_HEAD_ANIM ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
NEU4 $1079
ADDRLP4 12
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1077
LABELV $1079
line 1281
;1281:		int clientNum = HUDParamToTeamPlayerIdx(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 HUDParamToTeamPlayerIdx
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 20
INDIRI4
ASGNI4
line 1282
;1282:		CG_DrawStatusBarHead(itm, *r, clientNum);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 16
ADDRLP4 24
ARGP4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 CG_DrawStatusBarHead
CALLV
pop
line 1283
;1283:		return;
ADDRGP4 $1038
JUMPV
LABELV $1077
line 1285
;1284:	}
;1285:	else if (itm->iconFlags & ICON_ATTACKER) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $1080
line 1286
;1286:		CG_DrawAttacker_icon(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_DrawAttacker_icon
CALLV
pop
line 1287
;1287:	}
ADDRGP4 $1081
JUMPV
LABELV $1080
line 1288
;1288:	else if (itm->iconFlags & ICON_ORDER) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $1082
line 1289
;1289:		if (!param) {
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1084
line 1290
;1290:			CG_DrawPlayerStatus(r);
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 CG_DrawPlayerStatus
CALLV
pop
line 1291
;1291:		}
ADDRGP4 $1038
JUMPV
LABELV $1084
line 1292
;1292:		else if (param < 0) {
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $1086
line 1293
;1293:			CG_DrawSelectedPlayerStatus(r, CG_GetSelectedPlayer());
ADDRLP4 16
ADDRGP4 CG_GetSelectedPlayer
CALLI4
ASGNI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 CG_DrawSelectedPlayerStatus
CALLV
pop
line 1294
;1294:		}
ADDRGP4 $1038
JUMPV
LABELV $1086
line 1295
;1295:		else if (param >= 1) {
ADDRLP4 4
INDIRI4
CNSTI4 1
LTI4 $1038
line 1296
;1296:			CG_DrawSelectedPlayerStatus(r, param);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRGP4 CG_DrawSelectedPlayerStatus
CALLV
pop
line 1297
;1297:		}
line 1298
;1298:		return;
ADDRGP4 $1038
JUMPV
LABELV $1082
line 1300
;1299:	}
;1300:	else if (itm->shader) {
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1090
line 1301
;1301:		shader = CG_HUDShader(itm, cgs.media.whiteShader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 cgs+148752+16
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 CG_HUDShader
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 16
INDIRI4
ASGNI4
line 1302
;1302:	}
LABELV $1090
LABELV $1081
LABELV $1076
LABELV $1074
LABELV $1064
LABELV $1059
LABELV $1054
LABELV $1048
LABELV $1043
line 1304
;1303:
;1304:	if (shader) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1094
line 1305
;1305:		if (itm->propFlags & PROP_VERTICALBAR) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1096
line 1306
;1306:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1098
line 1307
;1307:				r->x += r->w;
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1308
;1308:				r->w = -r->w;
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 1309
;1309:			}
LABELV $1098
line 1310
;1310:			CG_DrawGradientPic(itm, r->x, r->y - r->h, r->w, r->h, 0, 0, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
SUBF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 1311
;1311:		}
ADDRGP4 $1097
JUMPV
LABELV $1096
line 1312
;1312:		else {
line 1313
;1313:			if (itm->iconFlags & ICON_INVERT_W) {
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1100
line 1314
;1314:				r->x += r->w;
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1315
;1315:				r->w = -r->w;
ADDRLP4 20
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 20
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
NEGF4
ASGNF4
line 1316
;1316:			}
LABELV $1100
line 1317
;1317:			CG_DrawGradientPic(itm, r->x, r->y, r->w, r->h, 0, 0, 1, 1, shader);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 16
INDIRP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
ARGF4
CNSTF4 0
ARGF4
CNSTF4 0
ARGF4
CNSTF4 1065353216
ARGF4
CNSTF4 1065353216
ARGF4
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 CG_DrawGradientPic
CALLV
pop
line 1318
;1318:		}
LABELV $1097
line 1319
;1319:	}
LABELV $1094
line 1320
;1320:}
LABELV $1038
endproc HUD_DrawBackground 40 40
export HUD_getText
proc HUD_getText 20 16
line 1322
;1321:
;1322:const char * HUD_getText(item_t *itm, int value) {
line 1325
;1323:	char		*s;
;1324:
;1325:	if (itm->text.flags & VAL_TEXT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1103
line 1326
;1326:		s = itm->text.caption;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1196
ADDP4
INDIRP4
ASGNP4
line 1327
;1327:	}
ADDRGP4 $1104
JUMPV
LABELV $1103
line 1328
;1328:	else if (itm->text.flags & VAL_SPEED) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $1105
line 1329
;1329:		if (itm->param == 1)
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 1
NEI4 $1107
line 1330
;1330:			s = va("%1.0i", value);
ADDRGP4 $1109
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
ADDRGP4 $1106
JUMPV
LABELV $1107
line 1332
;1331:		else
;1332:			s = va("%1.0iups", value);
ADDRGP4 $1110
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
ASGNP4
line 1333
;1333:	}
ADDRGP4 $1106
JUMPV
LABELV $1105
line 1334
;1334:	else if (itm->text.flags & VAL_NAME) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $1111
line 1335
;1335:		const char* plyrName = getTeamPlayerName(itm->team_player);
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 getTeamPlayerName
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 1336
;1336:		s = va("%s", plyrName);
ADDRGP4 $1113
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1337
;1337:	}
ADDRGP4 $1112
JUMPV
LABELV $1111
line 1338
;1338:	else if (itm->text.flags & VAL_HEALTH) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1114
line 1339
;1339:		int playerHealth = getPlayerHealth(itm->team_player);
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 getPlayerHealth
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1340
;1340:		s = va("%i", playerHealth);
ADDRGP4 $1116
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1341
;1341:	}
ADDRGP4 $1115
JUMPV
LABELV $1114
line 1342
;1342:	else if (itm->text.flags & VAL_TIMER) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1117
line 1346
;1343:		int			mins, seconds;
;1344:		int			msec;
;1345:
;1346:		msec = cg.time - cgs.levelStartTime;
ADDRLP4 8
ADDRGP4 cg+107604
INDIRI4
ADDRGP4 cgs+34820
INDIRI4
SUBI4
ASGNI4
line 1347
;1347:		seconds = msec / 1000;
ADDRLP4 4
ADDRLP4 8
INDIRI4
CNSTI4 1000
DIVI4
ASGNI4
line 1348
;1348:		mins = seconds / 60;
ADDRLP4 12
ADDRLP4 4
INDIRI4
CNSTI4 60
DIVI4
ASGNI4
line 1349
;1349:		seconds -= mins * 60;
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 60
MULI4
SUBI4
ASGNI4
line 1351
;1350:
;1351:		msec = cg.time - cgs.levelStartTime;
ADDRLP4 8
ADDRGP4 cg+107604
INDIRI4
ADDRGP4 cgs+34820
INDIRI4
SUBI4
ASGNI4
line 1354
;1352:
;1353:		// param 2: countdown
;1354:		if (itm->param == 2 && cgs.timelimit) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 2
NEI4 $1123
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 0
EQI4 $1123
line 1355
;1355:			msec = (cgs.timelimit * 60 * 1000) - msec;
ADDRLP4 8
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 60
MULI4
CNSTI4 1000
MULI4
ADDRLP4 8
INDIRI4
SUBI4
ASGNI4
line 1356
;1356:		}
LABELV $1123
line 1358
;1357:
;1358:		seconds = msec / 1000;
ADDRLP4 4
ADDRLP4 8
INDIRI4
CNSTI4 1000
DIVI4
ASGNI4
line 1359
;1359:		mins = seconds / 60;
ADDRLP4 12
ADDRLP4 4
INDIRI4
CNSTI4 60
DIVI4
ASGNI4
line 1360
;1360:		seconds -= mins * 60;
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 60
MULI4
SUBI4
ASGNI4
line 1362
;1361:
;1362:		if (itm->param == 1) {
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
CNSTI4 1
NEI4 $1127
line 1363
;1363:			if (mins) {
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1129
line 1364
;1364:				msec = msec - (mins * 60 * 1000) - (seconds * 1000);
ADDRLP4 8
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 60
MULI4
CNSTI4 1000
MULI4
SUBI4
ADDRLP4 4
INDIRI4
CNSTI4 1000
MULI4
SUBI4
ASGNI4
line 1365
;1365:				s = va("%i:%i:%02i", mins, seconds, msec);
ADDRGP4 $1131
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1366
;1366:			}
ADDRGP4 $1118
JUMPV
LABELV $1129
line 1367
;1367:			else {
line 1368
;1368:				msec -= (seconds * 1000);
ADDRLP4 8
ADDRLP4 8
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 1000
MULI4
SUBI4
ASGNI4
line 1369
;1369:				s = va("%i:%02i", seconds, msec);
ADDRGP4 $1132
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1370
;1370:			}
line 1371
;1371:		}
ADDRGP4 $1118
JUMPV
LABELV $1127
line 1372
;1372:		else {
line 1373
;1373:			s = va("%i:%02i", mins, seconds);
ADDRGP4 $1132
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1374
;1374:		}
line 1375
;1375:	}
ADDRGP4 $1118
JUMPV
LABELV $1117
line 1376
;1376:	else if (itm->text.flags & VAL_FPS) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1133
line 1377
;1377:		s = va("%ifps", FPS);
ADDRGP4 $1135
ARGP4
ADDRGP4 FPS
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1378
;1378:	}
ADDRGP4 $1134
JUMPV
LABELV $1133
line 1379
;1379:	else if (itm->text.flags & VAL_FOLLOW_NAME) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32768
BANDU4
CNSTU4 0
EQU4 $1136
line 1380
;1380:		s = cgs.clientinfo[cg.snap->ps.clientNum].name;
ADDRLP4 0
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
CNSTI4 1652
MULI4
ADDRGP4 cgs+40996+4
ADDP4
ASGNP4
line 1381
;1381:	}
ADDRGP4 $1137
JUMPV
LABELV $1136
line 1382
;1382:	else if (itm->text.flags & VAL_SNAPSHOT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 65536
BANDU4
CNSTU4 0
EQU4 $1141
line 1383
;1383:		s = va("time:%i snap:%i cmd:%i", cg.snap->serverTime, cg.latestSnapshotNum, cgs.serverCommandSequence);
ADDRGP4 $1143
ARGP4
ADDRGP4 cg+36
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRGP4 cg+28
INDIRI4
ARGI4
ADDRGP4 cgs+31468
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1384
;1384:	}
ADDRGP4 $1142
JUMPV
LABELV $1141
line 1385
;1385:	else if (itm->text.flags & VAL_LOCATION) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 131072
BANDU4
CNSTU4 0
EQU4 $1147
line 1386
;1386:		const char* str = getPlayerLocation(itm->team_player);
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 getPlayerLocation
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 1387
;1387:		s = va("%s", str);
ADDRGP4 $1113
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1388
;1388:	}
ADDRGP4 $1148
JUMPV
LABELV $1147
line 1389
;1389:	else if (itm->text.flags & VAL_CAPFRAG_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 2048
BANDU4
CNSTU4 0
EQU4 $1149
line 1390
;1390:		int lim = (cgs.gametype >= GT_CTF) ? cgs.capturelimit : cgs.fraglimit;
ADDRGP4 cgs+31480
INDIRI4
CNSTI4 4
LTI4 $1155
ADDRLP4 8
ADDRGP4 cgs+31496
INDIRI4
ASGNI4
ADDRGP4 $1156
JUMPV
LABELV $1155
ADDRLP4 8
ADDRGP4 cgs+31492
INDIRI4
ASGNI4
LABELV $1156
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1391
;1391:		s = va("%2i", lim);
ADDRGP4 $1157
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1392
;1392:	}
ADDRGP4 $1150
JUMPV
LABELV $1149
line 1393
;1393:	else if (itm->text.flags & VAL_FRAG_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4096
BANDU4
CNSTU4 0
EQU4 $1158
line 1394
;1394:		s = va("%2i", cgs.fraglimit);
ADDRGP4 $1157
ARGP4
ADDRGP4 cgs+31492
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1395
;1395:	}
ADDRGP4 $1159
JUMPV
LABELV $1158
line 1396
;1396:	else if (itm->text.flags & VAL_CAPTURE_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 8192
BANDU4
CNSTU4 0
EQU4 $1161
line 1397
;1397:		s = va("%2i", cgs.capturelimit);
ADDRGP4 $1157
ARGP4
ADDRGP4 cgs+31496
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1398
;1398:	}
ADDRGP4 $1162
JUMPV
LABELV $1161
line 1399
;1399:	else if (itm->text.flags & VAL_AMMO) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $1164
line 1400
;1400:		int val = HUD_PropValue(itm, VAL_AMMO, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 4
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1401
;1401:		s = va("%2i", val);
ADDRGP4 $1157
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1402
;1402:	}
ADDRGP4 $1165
JUMPV
LABELV $1164
line 1403
;1403:	else if (itm->text.flags & VAL_ARMOR) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1166
line 1404
;1404:		int val = GetTeamPlayerstat(itm, STAT_ARMOR);
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 8
ADDRGP4 GetTeamPlayerstat
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1405
;1405:		s = va("%2i", val);
ADDRGP4 $1157
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1406
;1406:	}
ADDRGP4 $1167
JUMPV
LABELV $1166
line 1407
;1407:	else if (itm->text.flags & VAL_WEAPON) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $1168
line 1408
;1408:		int val = HUD_PropValue(itm, VAL_WEAPON, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 32
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1409
;1409:		s = va("%2i", val);
ADDRGP4 $1157
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1410
;1410:	}
ADDRGP4 $1169
JUMPV
LABELV $1168
line 1411
;1411:	else if (itm->text.flags & VAL_HOLDABLE_ITEM) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $1170
line 1412
;1412:		int val = HUD_PropValue(itm, VAL_HOLDABLE_ITEM, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1413
;1413:		s = va("%2i", val);
ADDRGP4 $1157
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1414
;1414:	}
ADDRGP4 $1171
JUMPV
LABELV $1170
line 1415
;1415:	else if (itm->text.flags & VAL_SCORE) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 1024
BANDU4
CNSTU4 0
EQU4 $1172
line 1416
;1416:		int val = HUD_PropValue(itm, VAL_SCORE, itm->param);
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 1024
ARGI4
ADDRLP4 8
INDIRP4
CNSTI4 1036
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUD_PropValue
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 1417
;1417:		s = va("%2i", val);
ADDRGP4 $1157
ARGP4
ADDRLP4 4
INDIRI4
ARGI4
ADDRLP4 16
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 1418
;1418:	}
ADDRGP4 $1173
JUMPV
LABELV $1172
line 1419
;1419:	else if (itm->text.flags & VAL_TIME_LIMIT) {
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 16384
BANDU4
CNSTU4 0
EQU4 $1174
line 1420
;1420:		s = va("%2i", ((cgs.timelimit) * 60));
ADDRGP4 $1157
ARGP4
ADDRGP4 cgs+31500
INDIRI4
CNSTI4 60
MULI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1421
;1421:	}
ADDRGP4 $1175
JUMPV
LABELV $1174
line 1422
;1422:	else {
line 1423
;1423:		s = va("%i", value);
ADDRGP4 $1116
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 va
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 1424
;1424:	}
LABELV $1175
LABELV $1173
LABELV $1171
LABELV $1169
LABELV $1167
LABELV $1165
LABELV $1162
LABELV $1159
LABELV $1150
LABELV $1148
LABELV $1142
LABELV $1137
LABELV $1134
LABELV $1118
LABELV $1115
LABELV $1112
LABELV $1106
LABELV $1104
line 1425
;1425:	return s;
ADDRLP4 0
INDIRP4
RETP4
LABELV $1102
endproc HUD_getText 20 16
export HUD_Draw_Text
proc HUD_Draw_Text 64 32
line 1428
;1426:}
;1427:
;1428:void HUD_Draw_Text(item_t *itm, rectangle_t *r) {
line 1434
;1429:	int			value;
;1430:	const char	*s;
;1431:	vec4_t		forecolor;
;1432:	qboolean	showZeroValue;
;1433:
;1434:	if (!itm->text.flags)
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
INDIRU4
CNSTU4 0
NEU4 $1178
line 1435
;1435:		return;
ADDRGP4 $1177
JUMPV
LABELV $1178
line 1437
;1436:
;1437:	value = HUD_ItemCaptionValue(itm);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 HUD_ItemCaptionValue
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 28
INDIRI4
ASGNI4
line 1439
;1438:
;1439:	showZeroValue = (value == 0 && (itm->visible_prop_flags[1] & VIS_ZERO_VALUE));
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1181
ADDRFP4 0
INDIRP4
CNSTI4 1064
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1181
ADDRLP4 32
CNSTI4 1
ASGNI4
ADDRGP4 $1182
JUMPV
LABELV $1181
ADDRLP4 32
CNSTI4 0
ASGNI4
LABELV $1182
ADDRLP4 4
ADDRLP4 32
INDIRI4
ASGNI4
line 1442
;1440:
;1441:	// allow 0 xhen VIS_SHOW_ZERO_VALUE in item's flags
;1442:	if (value >= 0 && !showZeroValue) {
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $1183
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1183
line 1443
;1443:		HUD_color(itm, &itm->forecolor, &forecolor, colorWhite);
ADDRLP4 36
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
CNSTI4 1152
ADDP4
ARGP4
ADDRLP4 12
ARGP4
ADDRGP4 colorWhite
ARGP4
ADDRGP4 HUD_color
CALLV
pop
line 1445
;1444:
;1445:		s = HUD_getText(itm, value);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 40
ADDRGP4 HUD_getText
CALLP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
ASGNP4
line 1449
;1446:
;1447:#ifdef USE_NEW_FONT_RENDERER
;1448:
;1449:		CG_SelectFont(itm->text.styleflags);
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CVUI4 4
ARGI4
ADDRGP4 CG_SelectFont
CALLV
pop
line 1451
;1450:
;1451:		CG_DrawString(r->x, r->y, s, forecolor, itm->fontsize.w, itm->fontsize.h, 0, itm->text.styleflags);
ADDRLP4 44
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 44
INDIRP4
INDIRF4
ARGF4
ADDRLP4 44
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ARGF4
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 12
ARGP4
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 48
INDIRP4
CNSTI4 1120
ADDP4
INDIRF4
ARGF4
ADDRLP4 48
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
ARGF4
CNSTI4 0
ARGI4
ADDRLP4 48
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CVUI4 4
ARGI4
ADDRGP4 CG_DrawString
CALLV
pop
line 1453
;1452:
;1453:		CG_SelectFont(0);
CNSTI4 0
ARGI4
ADDRGP4 CG_SelectFont
CALLV
pop
line 1455
;1454:
;1455:		r->w = itm->fontsize.w * CG_DrawStrlen(s);
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 CG_DrawStrlen
CALLI4
ASGNI4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 1120
ADDP4
INDIRF4
ADDRLP4 52
INDIRI4
CVIF4 4
MULF4
ASGNF4
line 1456
;1456:		if (itm->text.styleflags & DS_RIGHT)
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1185
line 1457
;1457:			r->x -= r->w;
ADDRLP4 56
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 56
INDIRP4
ADDRLP4 56
INDIRP4
INDIRF4
ADDRLP4 56
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ASGNF4
LABELV $1185
line 1458
;1458:		if (itm->text.styleflags & DS_CENTER)
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
INDIRU4
CNSTU4 8
BANDU4
CNSTU4 0
EQU4 $1187
line 1459
;1459:			r->x -= 0.5f * r->w;
ADDRLP4 60
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 60
INDIRP4
INDIRF4
ADDRLP4 60
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
CNSTF4 1056964608
MULF4
SUBF4
ASGNF4
LABELV $1187
line 1460
;1460:		r->h = itm->fontsize.h;
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
ASGNF4
line 1466
;1461:
;1462:#else
;1463:		trap_R_SetColor(forecolor);
;1464:		CG_DrawField(r->x, r->y, 3, value, itm->fontsize.w, itm->fontsize.h);
;1465:#endif
;1466:	}
LABELV $1183
line 1467
;1467:}
LABELV $1177
endproc HUD_Draw_Text 64 32
export CG_HUDShader
proc CG_HUDShader 0 0
line 1475
;1468:
;1469:
;1470:/*
;1471:===============
;1472:HudShader
;1473:===============
;1474:*/
;1475:qhandle_t CG_HUDShader(item_t *itm, qhandle_t defaultShader) {
line 1476
;1476:	if (!itm->shader)
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
INDIRI4
CNSTI4 0
NEI4 $1190
line 1477
;1477:		return defaultShader;
ADDRFP4 4
INDIRI4
RETI4
ADDRGP4 $1189
JUMPV
LABELV $1190
line 1479
;1478:	else
;1479:		return itm->shader;
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
INDIRI4
RETI4
LABELV $1189
endproc CG_HUDShader 0 0
proc rectangleIsNull 8 0
line 1482
;1480:}
;1481:
;1482:static qboolean rectangleIsNull(rectangle_t r) {
line 1483
;1483:	return (!r.x && !r.y && !r.w && !r.h);
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
INDIRF4
CNSTF4 0
NEF4 $1194
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1194
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1194
ADDRLP4 4
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1194
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $1195
JUMPV
LABELV $1194
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1195
ADDRLP4 0
INDIRI4
RETI4
LABELV $1192
endproc rectangleIsNull 8 0
export getParentRect
proc getParentRect 1252 8
line 1486
;1484:}
;1485:
;1486:void getParentRect(const item_t *itm, rectangle_t *res) {
line 1489
;1487:	item_t parentItm;
;1488:
;1489:	if (!itm->parent) {
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
CNSTI4 0
NEI4 $1197
line 1490
;1490:		return;
ADDRGP4 $1196
JUMPV
LABELV $1197
line 1494
;1491:	}
;1492:
;1493:	// the minus sign indicate that item is in dyn_itemArray
;1494:	if (itm->parent < 0) {
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
CNSTI4 0
GEI4 $1199
line 1495
;1495:		parentItm = dyn_itemArray[-itm->parent];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
NEGI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
INDIRB
ASGNB 1212
line 1496
;1496:	}
ADDRGP4 $1200
JUMPV
LABELV $1199
line 1497
;1497:	else {
line 1498
;1498:		parentItm = itemArray[itm->parent];
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
INDIRB
ASGNB 1212
line 1499
;1499:	}
LABELV $1200
line 1501
;1500:	// use parent finalRect (real drawn rectangle for dynamic sized items)
;1501:	if (!rectangleIsNull(parentItm.finalRect)) {
ADDRLP4 1212
ADDRLP4 0+1104
INDIRB
ASGNB 16
ADDRLP4 1212
ARGP4
ADDRLP4 1228
ADDRGP4 rectangleIsNull
CALLI4
ASGNI4
ADDRLP4 1228
INDIRI4
CNSTI4 0
NEI4 $1201
line 1502
;1502:		*res = parentItm.finalRect;
ADDRFP4 4
INDIRP4
ADDRLP4 0+1104
INDIRB
ASGNB 16
line 1503
;1503:		return;
ADDRGP4 $1196
JUMPV
LABELV $1201
line 1505
;1504:	}
;1505:	else {
line 1507
;1506:		// if item not (or not yet) in this frame, use its original rect property
;1507:		if (!rectangleIsNull(parentItm.rect)) {
ADDRLP4 1232
ADDRLP4 0+1088
INDIRB
ASGNB 16
ADDRLP4 1232
ARGP4
ADDRLP4 1248
ADDRGP4 rectangleIsNull
CALLI4
ASGNI4
ADDRLP4 1248
INDIRI4
CNSTI4 0
NEI4 $1205
line 1508
;1508:			*res = parentItm.rect;
ADDRFP4 4
INDIRP4
ADDRLP4 0+1088
INDIRB
ASGNB 16
line 1509
;1509:		}
ADDRGP4 $1206
JUMPV
LABELV $1205
line 1510
;1510:		else if (parentItm.parent) {
ADDRLP4 0+1028
INDIRI4
CNSTI4 0
EQI4 $1209
line 1511
;1511:			getParentRect(&parentItm, res);
ADDRLP4 0
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 getParentRect
CALLV
pop
line 1512
;1512:		}
LABELV $1209
LABELV $1206
line 1513
;1513:	}
line 1514
;1514:}
LABELV $1196
endproc getParentRect 1252 8
export HUD_Update_Anchors
proc HUD_Update_Anchors 44 8
line 1521
;1515:
;1516:/*
;1517:================
;1518:CG_Update_Anchors
;1519:================
;1520:*/
;1521:void HUD_Update_Anchors(const item_t *itm, rectangle_t *r) {
line 1524
;1522:	rectangle_t parentR;
;1523:
;1524:	parentR.x = parentR.y = parentR.w = parentR.h = 0;
ADDRLP4 16
CNSTF4 0
ASGNF4
ADDRLP4 0+12
ADDRLP4 16
INDIRF4
ASGNF4
ADDRLP4 0+8
ADDRLP4 16
INDIRF4
ASGNF4
ADDRLP4 0+4
ADDRLP4 16
INDIRF4
ASGNF4
ADDRLP4 0
ADDRLP4 16
INDIRF4
ASGNF4
line 1526
;1525:
;1526:	getParentRect(itm, &parentR);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
ARGP4
ADDRGP4 getParentRect
CALLV
pop
line 1528
;1527:	
;1528:	if (rectangleIsNull(parentR)) {
ADDRLP4 20
ADDRLP4 0
INDIRB
ASGNB 16
ADDRLP4 20
ARGP4
ADDRLP4 36
ADDRGP4 rectangleIsNull
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
EQI4 $1216
line 1529
;1529:		return;
ADDRGP4 $1212
JUMPV
LABELV $1216
line 1535
;1530:	}
;1531:
;1532:	// Left/Right and Top/Bottom should be inverted, but this was counter-intuitive.
;1533:	// (an item left to its parent, is actually anchored by its right side)
;1534:
;1535:	if (itm->propFlags & PROP_ANCHOR_RIGHT) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $1218
line 1536
;1536:		r->x += parentR.x + parentR.w;
ADDRLP4 40
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
ADDRLP4 0+8
INDIRF4
ADDF4
ADDF4
ASGNF4
line 1537
;1537:	}
ADDRGP4 $1219
JUMPV
LABELV $1218
line 1538
;1538:	else if (itm->propFlags & PROP_ANCHOR_LEFT) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1221
line 1539
;1539:		r->x += parentR.x - r->w;
ADDRLP4 40
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
ADDRLP4 40
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
SUBF4
ADDF4
ASGNF4
line 1540
;1540:	}
ADDRGP4 $1222
JUMPV
LABELV $1221
line 1541
;1541:	else if (itm->propFlags & PROP_ANCHOR_CENTER) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
EQU4 $1223
line 1542
;1542:		r->x += parentR.x;
ADDRLP4 40
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0
INDIRF4
ADDF4
ASGNF4
line 1543
;1543:	}
LABELV $1223
LABELV $1222
LABELV $1219
line 1545
;1544:
;1545:	if (itm->propFlags & PROP_ANCHOR_BOTTOM) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
EQU4 $1225
line 1546
;1546:		r->y += parentR.y + parentR.h;
ADDRLP4 40
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0+4
INDIRF4
ADDRLP4 0+12
INDIRF4
ADDF4
ADDF4
ASGNF4
line 1547
;1547:	}
ADDRGP4 $1226
JUMPV
LABELV $1225
line 1548
;1548:	else if (itm->propFlags & PROP_ANCHOR_TOP) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1229
line 1549
;1549:		r->y += parentR.y - itm->rect.h;
ADDRLP4 40
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0+4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
SUBF4
ADDF4
ASGNF4
line 1550
;1550:	}
ADDRGP4 $1230
JUMPV
LABELV $1229
line 1551
;1551:	else if (itm->propFlags & PROP_ANCHOR_MIDDLE) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1232
line 1552
;1552:		r->y += parentR.y;
ADDRLP4 40
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRF4
ADDRLP4 0+4
INDIRF4
ADDF4
ASGNF4
line 1553
;1553:	}
LABELV $1232
LABELV $1230
LABELV $1226
line 1556
;1554:
;1555:	// GUNNM TODO: use screen rectangle as a parent when no parent are provided
;1556:}
LABELV $1212
endproc HUD_Update_Anchors 44 8
export HUD_Update_Margin
proc HUD_Update_Margin 16 0
line 1564
;1557:
;1558:/*
;1559:===============
;1560:CG_Update_Margin
;1561:===============
;1562:*/
;1563:void HUD_Update_Margin(item_t *itm, rectangle_t *r)
;1564:{
line 1566
;1565:	// return if no margins defined
;1566:	if (itm->margin.left == 0 && itm->margin.right == 0 &&
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 1176
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1236
ADDRLP4 0
INDIRP4
CNSTI4 1180
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1236
ADDRLP4 0
INDIRP4
CNSTI4 1184
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1236
ADDRLP4 0
INDIRP4
CNSTI4 1188
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1236
line 1567
;1567:		itm->margin.top == 0 && itm->margin.bottom == 0) {
line 1568
;1568:		return;
ADDRGP4 $1235
JUMPV
LABELV $1236
line 1571
;1569:	}
;1570:
;1571:	if (itm->propFlags & PROP_ANCHOR_LEFT ) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 16
BANDU4
CNSTU4 0
EQU4 $1238
line 1572
;1572:		r->x -= itm->margin.left;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1176
ADDP4
INDIRF4
SUBF4
ASGNF4
line 1573
;1573:	}
ADDRGP4 $1239
JUMPV
LABELV $1238
line 1574
;1574:	else if (itm->propFlags & PROP_ANCHOR_CENTER || (itm->propFlags & PROP_ANCHOR_RIGHT)) {
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 32
BANDU4
CNSTU4 0
NEU4 $1242
ADDRLP4 4
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 64
BANDU4
CNSTU4 0
EQU4 $1240
LABELV $1242
line 1575
;1575:		r->x += itm->margin.right;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1180
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1576
;1576:	}
LABELV $1240
LABELV $1239
line 1578
;1577:
;1578:	if (itm->propFlags & PROP_ANCHOR_BOTTOM || (itm->propFlags & PROP_ANCHOR_MIDDLE)) {
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 512
BANDU4
CNSTU4 0
NEU4 $1245
ADDRLP4 8
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 256
BANDU4
CNSTU4 0
EQU4 $1243
LABELV $1245
line 1579
;1579:		r->y += itm->margin.bottom;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1188
ADDP4
INDIRF4
ADDF4
ASGNF4
line 1580
;1580:	}
ADDRGP4 $1244
JUMPV
LABELV $1243
line 1581
;1581:	else if (itm->propFlags & PROP_ANCHOR_TOP) {
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 128
BANDU4
CNSTU4 0
EQU4 $1246
line 1582
;1582:		r->y -= itm->margin.top;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1184
ADDP4
INDIRF4
SUBF4
ASGNF4
line 1583
;1583:	}
LABELV $1246
LABELV $1244
line 1584
;1584:}
LABELV $1235
endproc HUD_Update_Margin 16 0
export HUD_Update_Valign
proc HUD_Update_Valign 16 0
line 1593
;1585:
;1586:
;1587:/*
;1588:===============
;1589:CG_Update_Valign
;1590:===============
;1591:*/
;1592:void HUD_Update_Valign(item_t *itm, rectangle_t *r)
;1593:{
line 1595
;1594:	int h;
;1595:	if (itm->rect.h) {
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
CNSTF4 0
EQF4 $1249
line 1596
;1596:		h = itm->rect.h;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
CVFI4 4
ASGNI4
line 1597
;1597:	}
ADDRGP4 $1250
JUMPV
LABELV $1249
line 1598
;1598:	else if (itm->fontsize.h) {
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
CNSTF4 0
EQF4 $1248
line 1599
;1599:		h = itm->fontsize.h;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
CVFI4 4
ASGNI4
line 1600
;1600:	}
line 1601
;1601:	else {
line 1602
;1602:		return;
LABELV $1252
LABELV $1250
line 1605
;1603:	}
;1604:
;1605:	if (itm->propFlags & PROP_VALIGN_TOP)
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1253
line 1606
;1606:		r->y -= h;
ADDRLP4 4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
SUBF4
ASGNF4
ADDRGP4 $1254
JUMPV
LABELV $1253
line 1607
;1607:	else if (itm->propFlags & PROP_VALIGN_BOTTOM)
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 4
BANDU4
CNSTU4 0
EQU4 $1255
line 1608
;1608:		r->y += h;
ADDRLP4 8
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
ADDRGP4 $1256
JUMPV
LABELV $1255
line 1609
;1609:	else if (itm->propFlags & PROP_VALIGN_MIDDLE)
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
INDIRU4
CNSTU4 2
BANDU4
CNSTU4 0
EQU4 $1257
line 1610
;1610:		r->y -= itm->rect.y +200+ h * 0.5f;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 1092
ADDP4
INDIRF4
CNSTF4 1128792064
ADDF4
ADDRLP4 0
INDIRI4
CVIF4 4
CNSTF4 1056964608
MULF4
ADDF4
SUBF4
ASGNF4
LABELV $1257
LABELV $1256
LABELV $1254
line 1611
;1611:}
LABELV $1248
endproc HUD_Update_Valign 16 0
export HUD_Update_finalRect
proc HUD_Update_finalRect 0 0
line 1613
;1612:
;1613:void HUD_Update_finalRect(item_t *itm, int x, int y, int w, int h) {
line 1614
;1614:	itm->finalRect.x = x;
ADDRFP4 0
INDIRP4
CNSTI4 1104
ADDP4
ADDRFP4 4
INDIRI4
CVIF4 4
ASGNF4
line 1615
;1615:	itm->finalRect.y = y;
ADDRFP4 0
INDIRP4
CNSTI4 1108
ADDP4
ADDRFP4 8
INDIRI4
CVIF4 4
ASGNF4
line 1616
;1616:	itm->finalRect.w = w;
ADDRFP4 0
INDIRP4
CNSTI4 1112
ADDP4
ADDRFP4 12
INDIRI4
CVIF4 4
ASGNF4
line 1617
;1617:	itm->finalRect.h = h;
ADDRFP4 0
INDIRP4
CNSTI4 1116
ADDP4
ADDRFP4 16
INDIRI4
CVIF4 4
ASGNF4
line 1623
;1618:
;1619:	//GUNNM TODO if caption, use str lenght et charW according to align, valign, and charH
;1620:
;1621:	//display all the finalRect, for debug:
;1622:	//CG_DrawPic(itm->finalRect.x, itm->finalRect.y, itm->finalRect.w, itm->finalRect.h, cgs.media.selectShader);
;1623:}
LABELV $1259
endproc HUD_Update_finalRect 0 0
proc HUD_Alloc 8 4
line 1629
;1624:/*
;1625:===============
;1626:UI_Alloc
;1627:===============
;1628:*/
;1629:static void *HUD_Alloc(int size) {
line 1631
;1630:	char *p;
;1631:	if (allocPoint + size > MEM_POOL_SIZE) {
ADDRGP4 allocPoint
INDIRI4
ADDRFP4 0
INDIRI4
ADDI4
CNSTI4 131072
LEI4 $1261
line 1632
;1632:		outOfMemory = qtrue;
ADDRGP4 outOfMemory
CNSTI4 1
ASGNI4
line 1633
;1633:		Com_Printf("HUD_Alloc: Failure. Out of memory!");
ADDRGP4 $1263
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 1634
;1634:		return NULL;
CNSTP4 0
RETP4
ADDRGP4 $1260
JUMPV
LABELV $1261
line 1636
;1635:	}
;1636:	p = &memoryPool[allocPoint];
ADDRLP4 0
ADDRGP4 allocPoint
INDIRI4
ADDRGP4 memoryPool
ADDP4
ASGNP4
line 1637
;1637:	allocPoint += (size + 15) & ~15;
ADDRLP4 4
ADDRGP4 allocPoint
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ADDRFP4 0
INDIRI4
CNSTI4 15
ADDI4
CNSTI4 -16
BANDI4
ADDI4
ASGNI4
line 1638
;1638:	return p;
ADDRLP4 0
INDIRP4
RETP4
LABELV $1260
endproc HUD_Alloc 8 4
proc UI_InitMemory 0 0
line 1647
;1639:}
;1640:
;1641:
;1642:/*
;1643:===============
;1644:UI_InitMemory
;1645:===============
;1646:*/
;1647:static void UI_InitMemory(void) {
line 1648
;1648:	allocPoint = 0;
ADDRGP4 allocPoint
CNSTI4 0
ASGNI4
line 1649
;1649:	outOfMemory = qfalse;
ADDRGP4 outOfMemory
CNSTI4 0
ASGNI4
line 1650
;1650:}
LABELV $1264
endproc UI_InitMemory 0 0
proc hashForString 16 4
line 1658
;1651:
;1652:
;1653:/*
;1654:================
;1655:return a hash value for the string
;1656:================
;1657:*/
;1658:static unsigned hashForString(const char *str) {
line 1663
;1659:	int			i;
;1660:	unsigned	hash;
;1661:	char		letter;
;1662:
;1663:	hash = 0;
ADDRLP4 8
CNSTU4 0
ASGNU4
line 1664
;1664:	i = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1267
JUMPV
LABELV $1266
line 1665
;1665:	while (str[i] != '\0') {
line 1666
;1666:		letter = tolower(str[i]);
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 12
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
CVII1 4
ASGNI1
line 1667
;1667:		hash += (unsigned)(letter)*(i + 119);
ADDRLP4 8
ADDRLP4 8
INDIRU4
ADDRLP4 4
INDIRI1
CVII4 1
CVIU4 4
ADDRLP4 0
INDIRI4
CNSTI4 119
ADDI4
CVIU4 4
MULU4
ADDU4
ASGNU4
line 1668
;1668:		i++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1669
;1669:	}
LABELV $1267
line 1665
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $1266
line 1670
;1670:	hash &= (HASH_TABLE_SIZE - 1);
ADDRLP4 8
ADDRLP4 8
INDIRU4
CNSTU4 2047
BANDU4
ASGNU4
line 1671
;1671:	return hash;
ADDRLP4 8
INDIRU4
RETU4
LABELV $1265
endproc hashForString 16 4
data
align 4
LABELV strPoolIndex
byte 4 0
align 4
LABELV strHandleCount
byte 4 0
bss
align 1
LABELV $1270
skip 4096
code
proc PC_SourceError 136 16
line 1692
;1672:}
;1673:
;1674:typedef struct stringDef_s {
;1675:	struct stringDef_s *next;
;1676:	const char *str;
;1677:} stringDef_t;
;1678:
;1679:static int strPoolIndex = 0;
;1680:static char strPool[STRING_POOL_SIZE];
;1681:
;1682:static int strHandleCount = 0;
;1683:static stringDef_t *strHandle[HASH_TABLE_SIZE];
;1684:
;1685:
;1686:/*
;1687:=================
;1688:PC_SourceError
;1689:help HUD creation by giving error information
;1690:=================
;1691:*/
;1692:static void PC_SourceError(int handle, char *format, ...) {
line 1698
;1693:	int line;
;1694:	char filename[128];
;1695:	va_list argptr;
;1696:	static char string[4096];
;1697:
;1698:	va_start(argptr, format);
ADDRLP4 132
ADDRFP4 4+4
ASGNP4
line 1699
;1699:	ED_vsprintf(string, format, argptr);
ADDRGP4 $1270
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 132
INDIRP4
ARGP4
ADDRGP4 ED_vsprintf
CALLI4
pop
line 1700
;1700:	va_end(argptr);
ADDRLP4 132
CNSTP4 0
ASGNP4
line 1702
;1701:
;1702:	filename[0] = '\0';
ADDRLP4 4
CNSTI1 0
ASGNI1
line 1703
;1703:	line = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1704
;1704:	trap_PC_SourceFileAndLine(handle, filename, &line);
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 0
ARGP4
ADDRGP4 trap_PC_SourceFileAndLine
CALLI4
pop
line 1706
;1705:
;1706:	Com_Printf(S_COLOR_RED "ERROR: %s, line %d: %s\n", filename, line, string);
ADDRGP4 $1272
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 $1270
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 1707
;1707:}
LABELV $1269
endproc PC_SourceError 136 16
proc keepTokenStr_OnError 0 0
line 1725
;1708:
;1709:
;1710:/*
;1711:=================
;1712:keepTokenOnError
;1713:
;1714:keep last token when parse error occured,
;1715:because token can't been unread
;1716:it will be the next one to be proceed
;1717:=================
;1718:*/
;1719:qboolean needCacheToken;
;1720:qboolean itemEnd;
;1721:qboolean propertyEnd;
;1722:char* cacheTokenStr;
;1723:
;1724:static void keepTokenStr_OnError(pc_token_t token)
;1725:{
line 1726
;1726:	cacheTokenStr = token.string;
ADDRGP4 cacheTokenStr
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
line 1727
;1727:	needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 1728
;1728:}
LABELV $1273
endproc keepTokenStr_OnError 0 0
proc resetTokenCache 0 0
line 1730
;1729:
;1730:static void resetTokenCache() {
line 1731
;1731:	needCacheToken = qfalse;
ADDRGP4 needCacheToken
CNSTI4 0
ASGNI4
line 1732
;1732:	*cacheTokenStr = '\0';
ADDRGP4 cacheTokenStr
INDIRP4
CNSTI1 0
ASGNI1
line 1733
;1733:}
LABELV $1274
endproc resetTokenCache 0 0
proc PC_Int_Parse 1052 12
line 1741
;1734:
;1735:
;1736:/*
;1737:=================
;1738:PC_Int_Parse
;1739:=================
;1740:*/
;1741:static qboolean PC_Int_Parse(int handle, int *i) {
line 1743
;1742:	pc_token_t token;
;1743:	int negative = qfalse;
ADDRLP4 1040
CNSTI4 0
ASGNI4
line 1745
;1744:
;1745:	if (!i)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1276
line 1746
;1746:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1275
JUMPV
LABELV $1276
line 1748
;1747:
;1748:	if (!trap_PC_ReadToken(handle, &token))
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1278
line 1749
;1749:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1275
JUMPV
LABELV $1278
line 1751
;1750:
;1751:	if (token.string[0] == '-') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $1280
line 1752
;1752:		if (!trap_PC_ReadToken(handle, &token))
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1283
line 1753
;1753:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1275
JUMPV
LABELV $1283
line 1754
;1754:		negative = qtrue;
ADDRLP4 1040
CNSTI4 1
ASGNI4
line 1755
;1755:	}
ADDRGP4 $1281
JUMPV
LABELV $1280
line 1756
;1756:	else if (token.string[0] == '}' || token.string[0] == ';') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
EQI4 $1289
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
NEI4 $1285
LABELV $1289
line 1757
;1757:		itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 1758
;1758:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1275
JUMPV
LABELV $1285
LABELV $1281
line 1761
;1759:	}
;1760:
;1761:	if (token.type != TT_NUMBER) {
ADDRLP4 0
INDIRI4
CNSTI4 3
EQI4 $1290
line 1762
;1762:		if (token.type == TT_NAME) {
ADDRLP4 0
INDIRI4
CNSTI4 4
NEI4 $1292
line 1763
;1763:			propertyEnd = qtrue;
ADDRGP4 propertyEnd
CNSTI4 1
ASGNI4
line 1764
;1764:		}
ADDRGP4 $1293
JUMPV
LABELV $1292
line 1765
;1765:		else if (token.type == TT_STRING) {
ADDRLP4 0
INDIRI4
CNSTI4 1
NEI4 $1294
line 1766
;1766:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 1767
;1767:			cacheTokenStr = (char *)token.string;
ADDRGP4 cacheTokenStr
ADDRLP4 0+16
ASGNP4
line 1768
;1768:		}
ADDRGP4 $1295
JUMPV
LABELV $1294
line 1769
;1769:		else {
line 1770
;1770:			PC_SourceError(handle, "expected integer but found %s \n", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1297
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 1771
;1771:		}
LABELV $1295
LABELV $1293
line 1773
;1772:
;1773:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1275
JUMPV
LABELV $1290
line 1776
;1774:	}
;1775:
;1776:	*i = token.intvalue;
ADDRFP4 4
INDIRP4
ADDRLP4 0+8
INDIRI4
ASGNI4
line 1777
;1777:	if (negative)
ADDRLP4 1040
INDIRI4
CNSTI4 0
EQI4 $1300
line 1778
;1778:		*i = -*i;
ADDRLP4 1048
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 1048
INDIRP4
ADDRLP4 1048
INDIRP4
INDIRI4
NEGI4
ASGNI4
LABELV $1300
line 1779
;1779:	return qtrue;
CNSTI4 1
RETI4
LABELV $1275
endproc PC_Int_Parse 1052 12
export KeywordHash_Key
proc KeywordHash_Key 20 0
line 1787
;1780:}
;1781:
;1782:/*
;1783:===============
;1784:Keyword Hash
;1785:===============
;1786:*/
;1787:int KeywordHash_Key(char *keyword) {
line 1790
;1788:	int hash, i;
;1789:
;1790:	hash = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1791
;1791:	for (i = 0; keyword[i] != '\0'; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1306
JUMPV
LABELV $1303
line 1792
;1792:		if (keyword[i] >= 'A' && keyword[i] <= 'Z')
ADDRLP4 8
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 65
LTI4 $1307
ADDRLP4 8
INDIRI4
CNSTI4 90
GTI4 $1307
line 1793
;1793:			hash += (keyword[i] + ('a' - 'A')) * (119 + i);
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 32
ADDI4
ADDRLP4 0
INDIRI4
CNSTI4 119
ADDI4
MULI4
ADDI4
ASGNI4
ADDRGP4 $1308
JUMPV
LABELV $1307
line 1795
;1794:		else
;1795:			hash += keyword[i] * (119 + i);
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRI4
CNSTI4 119
ADDI4
MULI4
ADDI4
ASGNI4
LABELV $1308
line 1796
;1796:	}
LABELV $1304
line 1791
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1306
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $1303
line 1797
;1797:	hash = (hash ^ (hash >> 10) ^ (hash >> 20)) & (KEYWORDHASH_SIZE - 1);
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 4
INDIRI4
CNSTI4 10
RSHI4
BXORI4
ADDRLP4 4
INDIRI4
CNSTI4 20
RSHI4
BXORI4
CNSTI4 511
BANDI4
ASGNI4
line 1798
;1798:	return hash;
ADDRLP4 4
INDIRI4
RETI4
LABELV $1302
endproc KeywordHash_Key 20 0
export cvarTest_KeywordHash_Add
proc cvarTest_KeywordHash_Add 8 4
line 1814
;1799:}
;1800:
;1801:/*
;1802:===============
;1803:cvarTest list hash
;1804:===============
;1805:*/
;1806:typedef struct cvarTest_keywordHash_s
;1807:{
;1808:	char *keyword;
;1809:	vmCvar_t *cvar;
;1810:	int flag;
;1811:	struct cvarTest_keywordHash_s *next;
;1812:} cvarTest_keywordHash_t;
;1813:
;1814:void cvarTest_KeywordHash_Add(cvarTest_keywordHash_t *table[], cvarTest_keywordHash_t *key) {
line 1817
;1815:	int hash;
;1816:
;1817:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 1818
;1818:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 1819
;1819:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 1820
;1820:}
LABELV $1309
endproc cvarTest_KeywordHash_Add 8 4
export cvarTest_KeywordHash_Find
proc cvarTest_KeywordHash_Find 16 8
line 1823
;1821:
;1822:cvarTest_keywordHash_t *cvarTest_KeywordHash_Find(cvarTest_keywordHash_t *table[], char *keyword)
;1823:{
line 1827
;1824:	cvarTest_keywordHash_t *key;
;1825:	int hash;
;1826:
;1827:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1828
;1828:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1314
JUMPV
LABELV $1311
line 1829
;1829:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1315
line 1830
;1830:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1310
JUMPV
LABELV $1315
line 1831
;1831:	}
LABELV $1312
line 1828
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRP4
ASGNP4
LABELV $1314
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1311
line 1832
;1832:	return NULL;
CNSTP4 0
RETP4
LABELV $1310
endproc cvarTest_KeywordHash_Find 16 8
data
export cvarTest_Keywords
align 4
LABELV cvarTest_Keywords
address $1317
address cg_drawWeaponSelect
byte 4 2
byte 4 0
address $1318
address cg_drawAttacker
byte 4 4
byte 4 0
address $1319
address cg_drawTeamOverlay
byte 4 8
byte 4 0
address $1320
address cg_drawCrosshairNames
byte 4 16
byte 4 0
address $1321
address cg_drawIcons
byte 4 32
byte 4 0
address $1322
address cg_draw3dIcons
byte 4 64
byte 4 0
address $1323
address cg_drawFPS
byte 4 128
byte 4 0
address $1324
address cg_drawSpeed
byte 4 256
byte 4 0
address $1325
address cg_drawTimer
byte 4 512
byte 4 0
address $1326
address cg_lagometer
byte 4 1024
byte 4 0
address $1327
address cg_drawPing
byte 4 2048
byte 4 0
address $1328
address cg_drawSnapshot
byte 4 4096
byte 4 0
address $1329
address cg_drawStatus
byte 4 1
byte 4 0
address $1330
address cg_drawRewards
byte 4 8192
byte 4 0
address $1331
address cg_drawAmmoWarning
byte 4 16384
byte 4 0
address $1332
address cg_drawCrosshair
byte 4 32768
byte 4 0
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export cvarTest_SetupKeywordHash
code
proc cvarTest_SetupKeywordHash 4 12
line 1858
;1833:}
;1834:
;1835:cvarTest_keywordHash_t cvarTest_Keywords[] = {
;1836:	{"cg_drawWeaponSelect",		&cg_drawWeaponSelect,	CV_cg_drawWeaponSelect,		NULL},
;1837:	{"cg_drawAttacker",			&cg_drawAttacker,		CV_cg_drawAttacker,			NULL},
;1838:	{"cg_drawTeamOverlay",		&cg_drawTeamOverlay,	CV_cg_drawTeamOverlay,		NULL},
;1839:	{"cg_drawCrosshairNames",	&cg_drawCrosshairNames,	CV_cg_drawCrosshairNames,	NULL},
;1840:	{"cg_drawIcons",			&cg_drawIcons,			CV_cg_drawIcons,			NULL},
;1841:	{"cg_draw3dIcons",			&cg_draw3dIcons,		CV_cg_draw3dIcons,			NULL},
;1842:	{"cg_drawFPS",				&cg_drawFPS,			CV_cg_drawFPS,				NULL},
;1843:	{"cg_drawSpeed",			&cg_drawSpeed,			CV_cg_drawSpeed,			NULL},
;1844:	{"cg_drawTimer",			&cg_drawTimer,			CV_cg_drawTimer,			NULL},
;1845:	{"cg_lagometer",			&cg_lagometer,			CV_cg_lagometer,			NULL},
;1846:	{"cg_drawPing",				&cg_drawPing,			CV_cg_drawPing,				NULL},
;1847:	{"cg_drawSnapshot",			&cg_drawSnapshot,		CV_cg_drawSnapshot,			NULL},
;1848:	{"cg_drawStatus",			&cg_drawStatus,			CV_cg_drawStatus,			NULL},
;1849:	{"cg_drawRewards",			&cg_drawRewards,		CV_cg_drawRewards,			NULL},
;1850:	{"cg_drawAmmoWarning",		&cg_drawAmmoWarning,	CV_cg_drawAmmoWarning,		NULL},
;1851:	{"cg_drawCrosshair",		&cg_drawCrosshair,		CV_cg_drawCrosshair,		NULL},
;1852:	{NULL, 0, 0, NULL}
;1853:};
;1854:
;1855:cvarTest_keywordHash_t *cvarTest_KeywordHash[KEYWORDHASH_SIZE];
;1856:
;1857://fill command_KeywordHash list
;1858:void cvarTest_SetupKeywordHash(void) {
line 1861
;1859:	int i;
;1860:
;1861:	memset(cvarTest_KeywordHash, 0, sizeof(cvarTest_KeywordHash));
ADDRGP4 cvarTest_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1862
;1862:	for (i = 0; cvarTest_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1337
JUMPV
LABELV $1334
line 1863
;1863:		cvarTest_KeywordHash_Add(cvarTest_KeywordHash, &cvarTest_Keywords[i]);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 cvarTest_Keywords
ADDP4
ARGP4
ADDRGP4 cvarTest_KeywordHash_Add
CALLV
pop
line 1864
;1864:	}
LABELV $1335
line 1862
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1337
ADDRLP4 0
INDIRI4
CNSTI4 4
LSHI4
ADDRGP4 cvarTest_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1334
line 1865
;1865:}
LABELV $1333
endproc cvarTest_SetupKeywordHash 4 12
proc PC_Float_Parse 2116 8
line 1873
;1866:
;1867:
;1868:/*
;1869:=================
;1870:PC_Float_Parse
;1871:=================
;1872:*/
;1873:static qboolean PC_Float_Parse(int handle, float *f) {
line 1875
;1874:	pc_token_t token;
;1875:	int negative = qfalse;
ADDRLP4 1040
CNSTI4 0
ASGNI4
line 1877
;1876:
;1877:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1339
line 1878
;1878:		keepTokenStr_OnError( token );
ADDRLP4 1048
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1048
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1879
;1879:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1339
line 1884
;1880:	}
;1881:
;1882:	// fixme: those are lazy fix.
;1883:	// take care of colors T and E when parsing color. 
;1884:	if (token.string[0] == 'T' || token.string[0] == 'E') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 84
EQI4 $1345
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 69
NEI4 $1341
LABELV $1345
line 1885
;1885:		keepTokenStr_OnError(token);
ADDRLP4 1048
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1048
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1886
;1886:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1341
line 1889
;1887:	}
;1888:	// take care of colors arrays when parsing color.
;1889:	if (strcmp("HealthColors", cacheTokenStr) == 0 || strcmp("ArmorColors", cacheTokenStr) == 0 ||
ADDRGP4 $1348
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1048
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
EQI4 $1358
ADDRGP4 $1349
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1052
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
EQI4 $1358
ADDRGP4 $1350
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1056
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
EQI4 $1358
ADDRGP4 $1351
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1060
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1060
INDIRI4
CNSTI4 0
EQI4 $1358
ADDRGP4 $1352
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1064
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1064
INDIRI4
CNSTI4 0
EQI4 $1358
ADDRGP4 $1353
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1068
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1068
INDIRI4
CNSTI4 0
NEI4 $1346
LABELV $1358
line 1892
;1890:		strcmp("AmmoColors", cacheTokenStr) == 0 || strcmp("TeamsColors", cacheTokenStr) == 0 || 
;1891:		strcmp("BlueTeamColor", cacheTokenStr) == 0 || strcmp("RedTeamColor", cacheTokenStr) == 0)
;1892:	{
line 1893
;1893:		keepTokenStr_OnError(token);
ADDRLP4 1072
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1072
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1894
;1894:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1346
line 1897
;1895:	}
;1896:
;1897:	if (token.string[0] == ';') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
NEI4 $1359
line 1898
;1898:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1359
line 1900
;1899:	}
;1900:	else if (token.string[0] == '}') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1362
line 1901
;1901:		itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 1902
;1902:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1362
line 1905
;1903:	}
;1904:	// std separators
;1905:	else if (token.string[0] == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1365
line 1906
;1906:		if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1072
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1072
INDIRI4
CNSTI4 0
NEI4 $1368
line 1907
;1907:			keepTokenStr_OnError(token);
ADDRLP4 1076
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1076
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1908
;1908:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1368
line 1910
;1909:		}
;1910:	}
LABELV $1365
line 1912
;1911:
;1912:	if (token.string[0] == '-') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $1370
line 1913
;1913:		if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1072
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1072
INDIRI4
CNSTI4 0
NEI4 $1373
line 1914
;1914:			keepTokenStr_OnError(token);
ADDRLP4 1076
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1076
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1915
;1915:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1373
line 1917
;1916:		}
;1917:		negative = qtrue;
ADDRLP4 1040
CNSTI4 1
ASGNI4
line 1918
;1918:	}
LABELV $1370
line 1920
;1919:
;1920:	if ( token.type != TT_NUMBER ) {
ADDRLP4 0
INDIRI4
CNSTI4 3
EQI4 $1375
line 1921
;1921:		keepTokenStr_OnError(token);
ADDRLP4 1072
ADDRLP4 0
INDIRB
ASGNB 1040
ADDRLP4 1072
ARGP4
ADDRGP4 keepTokenStr_OnError
CALLV
pop
line 1922
;1922:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1338
JUMPV
LABELV $1375
line 1925
;1923:	}
;1924:
;1925:	if (negative)
ADDRLP4 1040
INDIRI4
CNSTI4 0
EQI4 $1377
line 1926
;1926:		*f = -token.floatvalue;
ADDRFP4 4
INDIRP4
ADDRLP4 0+12
INDIRF4
NEGF4
ASGNF4
ADDRGP4 $1378
JUMPV
LABELV $1377
line 1928
;1927:	else
;1928:		*f = token.floatvalue;
ADDRFP4 4
INDIRP4
ADDRLP4 0+12
INDIRF4
ASGNF4
LABELV $1378
line 1929
;1929:	return qtrue;
CNSTI4 1
RETI4
LABELV $1338
endproc PC_Float_Parse 2116 8
proc PC_Color_Parse 12 8
line 1938
;1930:}
;1931:
;1932:
;1933:/*
;1934:=================
;1935:PC_Color_Parse
;1936:=================
;1937:*/
;1938:static qboolean PC_Color_Parse(int handle, vec4_t *c) {
line 1941
;1939:	int i;
;1940:	float f;
;1941:	for (i = 0; i < 4; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1382
line 1942
;1942:		if (!PC_Float_Parse(handle, &f)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1386
line 1943
;1943:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1381
JUMPV
LABELV $1386
line 1945
;1944:		}
;1945:		(*c)[i] = f;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1946
;1946:	}
LABELV $1383
line 1941
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 4
LTI4 $1382
line 1947
;1947:	return qtrue;
CNSTI4 1
RETI4
LABELV $1381
endproc PC_Color_Parse 12 8
proc Color_Str_Parse 40 8
line 1957
;1948:}
;1949:
;1950:
;1951:/*
;1952:=================
;1953:parse color if RGBA, or add flag: C_COLOR_TEAMS | C_COLOR_TEAM
;1954:C_COLOR_NME | C_COLOR_HEALTH | C_COLOR_ARMOR | C_COLOR_AMMO
;1955:=================
;1956:*/
;1957:static qboolean Color_Str_Parse(int handle, color_Def_t *col) {
line 1961
;1958:	int i;
;1959:	float f;
;1960:
;1961:	for (i = 0; i < 4; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1389
line 1962
;1962:		if (!PC_Float_Parse(handle, &f)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1393
line 1963
;1963:			if (strcmp("TeamsColors", cacheTokenStr) == 0) {
ADDRGP4 $1351
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1395
line 1964
;1964:				col->colorflags |= C_COLORS_TEAMS;
ADDRLP4 16
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
line 1965
;1965:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1966
;1966:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1395
line 1968
;1967:			}
;1968:			else if (cacheTokenStr[0] == 'T') {
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
CNSTI4 84
NEI4 $1397
line 1969
;1969:				col->colorflags |= C_COLOR_TEAM;
ADDRLP4 16
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 2
BORU4
ASGNU4
line 1970
;1970:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1971
;1971:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1397
line 1973
;1972:			}
;1973:			else if (cacheTokenStr[0] == 'E') {
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
CNSTI4 69
NEI4 $1399
line 1974
;1974:				col->colorflags |= C_COLOR_NME;
ADDRLP4 16
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
line 1975
;1975:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1976
;1976:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1399
line 1978
;1977:			}
;1978:			else if (strcmp("BlueTeamColor", cacheTokenStr) == 0) {
ADDRGP4 $1352
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $1401
line 1979
;1979:				col->colorflags |= C_COLOR_BLUE_TEAM;
ADDRLP4 20
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
line 1980
;1980:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1981
;1981:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1401
line 1983
;1982:			}
;1983:			else if (strcmp("RedTeamColor", cacheTokenStr) == 0) {
ADDRGP4 $1353
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $1403
line 1984
;1984:				col->colorflags |= C_COLOR_RED_TEAM;
ADDRLP4 24
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRU4
CNSTU4 128
BORU4
ASGNU4
line 1985
;1985:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1986
;1986:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1403
line 1988
;1987:			}
;1988:			else if (strcmp("HealthColors", cacheTokenStr) == 0) {
ADDRGP4 $1348
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $1405
line 1989
;1989:				col->colorflags |= C_COLORS_HEALTH;
ADDRLP4 28
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 1990
;1990:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1991
;1991:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1405
line 1993
;1992:			}
;1993:			else if (strcmp("ArmorColors", cacheTokenStr) == 0) {
ADDRGP4 $1349
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $1407
line 1994
;1994:				col->colorflags |= C_COLORS_ARMOR;
ADDRLP4 32
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
line 1995
;1995:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 1996
;1996:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1407
line 1998
;1997:			}
;1998:			else if (strcmp("AmmoColors", cacheTokenStr) == 0) {
ADDRGP4 $1350
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $1409
line 1999
;1999:				col->colorflags |= C_COLORS_AMMO;
ADDRLP4 36
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRU4
CNSTU4 32
BORU4
ASGNU4
line 2000
;2000:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 2001
;2001:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1409
line 2003
;2002:			}
;2003:			else {
line 2004
;2004:				Com_Printf("Color parse error: %s\n", cacheTokenStr);
ADDRGP4 $1411
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2005
;2005:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1388
JUMPV
LABELV $1393
line 2010
;2006:			}
;2007:		}
;2008:
;2009:		// float parse success
;2010:		col->colorflags |= C_COLOR_RGBA;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2011
;2011:		col->color[i] = f;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 2012
;2012:	}
LABELV $1390
line 1961
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 4
LTI4 $1389
line 2013
;2013:	return qtrue;
CNSTI4 1
RETI4
LABELV $1388
endproc Color_Str_Parse 40 8
proc PC_Rect_Parse 20 8
line 2022
;2014:}
;2015:
;2016:
;2017:/*
;2018:=================
;2019:PC_Rect_Parse
;2020:=================
;2021:*/
;2022:static qboolean PC_Rect_Parse(int handle, rectDef_t *r) {
line 2023
;2023:	int intNb = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 2024
;2024:	if (PC_Float_Parse(handle, &r->x)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1413
line 2025
;2025:		intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2026
;2026:		if (PC_Float_Parse(handle, &r->y)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1415
line 2027
;2027:			intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2028
;2028:			if (PC_Float_Parse(handle, &r->w)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ARGP4
ADDRLP4 12
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1417
line 2029
;2029:				intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2030
;2030:				if (PC_Float_Parse(handle, &r->h)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1419
line 2031
;2031:					intNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2032
;2032:					return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1412
JUMPV
LABELV $1419
line 2034
;2033:				}
;2034:			}
LABELV $1417
line 2035
;2035:		}
LABELV $1415
line 2036
;2036:	}
LABELV $1413
line 2037
;2037:	return (intNb > 0);
ADDRLP4 0
INDIRI4
CNSTI4 0
LEI4 $1422
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRGP4 $1423
JUMPV
LABELV $1422
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $1423
ADDRLP4 8
INDIRI4
RETI4
LABELV $1412
endproc PC_Rect_Parse 20 8
proc PC_Margin_Parse 20 8
line 2045
;2038:}
;2039:
;2040:/*
;2041:=================
;2042:PC_Margin_Parse
;2043:=================
;2044:*/
;2045:static qboolean PC_Margin_Parse(int handle, margin_t *m) {
line 2046
;2046:	int paramNb = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 2047
;2047:	if (PC_Float_Parse(handle, &m->left)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1425
line 2048
;2048:		paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2049
;2049:		if (PC_Float_Parse(handle, &m->right)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1427
line 2050
;2050:			paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2051
;2051:			if (PC_Float_Parse(handle, &m->top)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ARGP4
ADDRLP4 12
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1429
line 2052
;2052:				paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2053
;2053:				if (PC_Float_Parse(handle, &m->bottom)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1431
line 2054
;2054:					paramNb++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2055
;2055:					return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1424
JUMPV
LABELV $1431
line 2057
;2056:				}
;2057:			}
LABELV $1429
line 2058
;2058:		}
LABELV $1427
line 2059
;2059:	}
LABELV $1425
line 2060
;2060:	return (paramNb > 0);
ADDRLP4 0
INDIRI4
CNSTI4 0
LEI4 $1434
ADDRLP4 8
CNSTI4 1
ASGNI4
ADDRGP4 $1435
JUMPV
LABELV $1434
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $1435
ADDRLP4 8
INDIRI4
RETI4
LABELV $1424
endproc PC_Margin_Parse 20 8
proc PC_String_Parse 1048 8
line 2069
;2061:}
;2062:
;2063:
;2064:/*
;2065:=================
;2066:PC_String_Parse
;2067:=================
;2068:*/
;2069:static qboolean PC_String_Parse(int handle, const char **out) {
line 2072
;2070:	pc_token_t token;
;2071:
;2072:	if (!trap_PC_ReadToken(handle, &token))
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1040
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1040
INDIRI4
CNSTI4 0
NEI4 $1437
line 2073
;2073:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1436
JUMPV
LABELV $1437
line 2075
;2074:
;2075:	*(out) = String_Alloc(token.string);
ADDRLP4 0+16
ARGP4
ADDRLP4 1044
ADDRGP4 String_Alloc
CALLP4
ASGNP4
ADDRFP4 4
INDIRP4
ADDRLP4 1044
INDIRP4
ASGNP4
line 2076
;2076:	return qtrue;
CNSTI4 1
RETI4
LABELV $1436
endproc PC_String_Parse 1048 8
proc PC_bool_Parse 20 8
line 2085
;2077:}
;2078:
;2079:
;2080:/*
;2081:=================
;2082:PC_bool_Parse
;2083:=================
;2084:*/
;2085:static qboolean PC_bool_Parse(int handle, qboolean defaultValue, qboolean *b) {
line 2087
;2086:	const char *temp;
;2087:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1441
line 2088
;2088:		if (temp[0] == '}')	{
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1443
line 2089
;2089:			*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2090
;2090:			itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2091
;2091:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1440
JUMPV
LABELV $1443
line 2094
;2092:		}
;2093:		// e.g. when just the keyword 'visible' alone, it mean visible = qtrue
;2094:		else if (temp[0] == '\0' || temp[0] == ';') {
ADDRLP4 8
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1447
ADDRLP4 8
INDIRI4
CNSTI4 59
NEI4 $1445
LABELV $1447
line 2095
;2095:			*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2096
;2096:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1440
JUMPV
LABELV $1445
line 2098
;2097:		}
;2098:		else if ( strcmp("false", temp) == 0 || temp[0] == '0') {
ADDRGP4 $1450
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1451
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $1448
LABELV $1451
line 2099
;2099:			*b = qfalse;
ADDRFP4 8
INDIRP4
CNSTI4 0
ASGNI4
line 2100
;2100:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1440
JUMPV
LABELV $1448
line 2102
;2101:		}
;2102:		else if ( strcmp("true", temp) == 0 || temp[0] == '1') {
ADDRGP4 $1454
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1455
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 49
NEI4 $1452
LABELV $1455
line 2103
;2103:			*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
line 2104
;2104:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1440
JUMPV
LABELV $1452
line 2106
;2105:		}
;2106:		else {
line 2107
;2107:			if ( defaultValue )
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $1456
line 2108
;2108:				*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
LABELV $1456
line 2110
;2109:
;2110:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2111
;2111:			cacheTokenStr = (char *)temp ;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2112
;2112:		}
line 2113
;2113:	}
LABELV $1441
line 2115
;2114:
;2115:	*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2116
;2116:	return qfalse;
CNSTI4 0
RETI4
LABELV $1440
endproc PC_bool_Parse 20 8
proc prop_name 8 8
line 2125
;2117:}
;2118:
;2119:
;2120:/*
;2121:===============
;2122:properties Keyword Parse functions
;2123:===============
;2124:*/
;2125:static qboolean prop_name(item_t *itm, int handle) {
line 2128
;2126:	const char *s;
;2127:
;2128:	if (!PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1459
line 2129
;2129:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1458
JUMPV
LABELV $1459
line 2131
;2130:	}
;2131:	else {
line 2132
;2132:		strcpy(itm->item_name, s);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 2133
;2133:		return qtrue;
CNSTI4 1
RETI4
LABELV $1458
endproc prop_name 8 8
proc prop_margin 4 8
line 2138
;2134:	}
;2135:}
;2136:
;2137:// margin <float, float, float, float>
;2138:static qboolean prop_margin(item_t *itm, int handle) {
line 2139
;2139:	if (!PC_Margin_Parse(handle, &itm->margin)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1176
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Margin_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1462
line 2140
;2140:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1461
JUMPV
LABELV $1462
line 2142
;2141:	}
;2142:	return qtrue;
CNSTI4 1
RETI4
LABELV $1461
endproc prop_margin 4 8
proc prop_rect 12 8
line 2146
;2143:}
;2144:
;2145:// rect <rectangle>
;2146:static qboolean prop_rect(item_t *itm, int handle) {
line 2147
;2147:	if (!PC_Rect_Parse(handle, &itm->rect)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1088
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Rect_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1465
line 2148
;2148:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1464
JUMPV
LABELV $1465
line 2151
;2149:	}
;2150:
;2151:	if (itm->rect.w < 0)
ADDRFP4 0
INDIRP4
CNSTI4 1096
ADDP4
INDIRF4
CNSTF4 0
GEF4 $1467
line 2152
;2152:		itm->iconFlags |= ICON_INVERT_W;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
LABELV $1467
line 2153
;2153:	if (itm->rect.h < 0)
ADDRFP4 0
INDIRP4
CNSTI4 1100
ADDP4
INDIRF4
CNSTF4 0
GEF4 $1469
line 2154
;2154:		itm->iconFlags |= ICON_INVERT_H;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 32
BORU4
ASGNU4
LABELV $1469
line 2156
;2155:
;2156:	return qtrue;
CNSTI4 1
RETI4
LABELV $1464
endproc prop_rect 12 8
proc prop_pulseScale 4 8
line 2160
;2157:}
;2158:
;2159:// pulseScale <float>
;2160:static qboolean prop_pulseScale(item_t *itm, int handle) {
line 2161
;2161:	if (!PC_Float_Parse(handle, &itm->pulseScale)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1040
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1472
line 2162
;2162:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1471
JUMPV
LABELV $1472
line 2164
;2163:	}
;2164:	return qtrue;
CNSTI4 1
RETI4
LABELV $1471
endproc prop_pulseScale 4 8
proc prop_proportional 8 12
line 2169
;2165:}
;2166:
;2167:// CG_DrawString() flag
;2168:// proportional <boolean>
;2169:static qboolean prop_proportional(item_t *itm, int handle) {
line 2171
;2170:	qboolean proportionalTmp;
;2171:	PC_bool_Parse(handle, qtrue, &proportionalTmp);
ADDRFP4 4
INDIRI4
ARGI4
CNSTI4 1
ARGI4
ADDRLP4 0
ARGP4
ADDRGP4 PC_bool_Parse
CALLI4
pop
line 2172
;2172:	if (proportionalTmp) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1475
line 2173
;2173:		itm->text.styleflags |= DS_PROPORTIONAL;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
line 2174
;2174:	}
LABELV $1475
line 2175
;2175:	return qtrue;
CNSTI4 1
RETI4
LABELV $1474
endproc prop_proportional 8 12
proc prop_shadow 8 12
line 2180
;2176:}
;2177:
;2178:// CG_DrawString() flag
;2179:// shadow <boolean>
;2180:static qboolean prop_shadow(item_t *itm, int handle) {
line 2182
;2181:	qboolean shadowTmp;
;2182:	PC_bool_Parse(handle, qtrue, &shadowTmp);
ADDRFP4 4
INDIRI4
ARGI4
CNSTI4 1
ARGI4
ADDRLP4 0
ARGP4
ADDRGP4 PC_bool_Parse
CALLI4
pop
line 2183
;2183:	if (shadowTmp) {
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1478
line 2184
;2184:		itm->text.styleflags |= DS_SHADOW;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2185
;2185:	}
LABELV $1478
line 2186
;2186:	return qtrue;
CNSTI4 1
RETI4
LABELV $1477
endproc prop_shadow 8 12
proc prop_textalign 16 8
line 2191
;2187:}
;2188:
;2189:// CG_DrawString() flag
;2190:// textAlign <textAlign_t>
;2191:static qboolean prop_textalign(item_t *itm, int handle) {
line 2194
;2192:	const char *s;
;2193:
;2194:	if (PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1481
line 2195
;2195:		if (s[0] == 'R')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 82
NEI4 $1483
line 2196
;2196:			itm->text.styleflags |= DS_RIGHT;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
ADDRGP4 $1484
JUMPV
LABELV $1483
line 2197
;2197:		else if (s[0] == 'C')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 67
NEI4 $1485
line 2198
;2198:			itm->text.styleflags |= DS_CENTER;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
ADDRGP4 $1486
JUMPV
LABELV $1485
line 2199
;2199:		else if (s[0] == 'L')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 76
NEI4 $1487
line 2201
;2200:			//return item->text.styleflags |= DS_LEFT; // CG_DrawString() default value is left align
;2201:			return qtrue;	
CNSTI4 1
RETI4
ADDRGP4 $1480
JUMPV
LABELV $1487
LABELV $1486
LABELV $1484
line 2202
;2202:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1480
JUMPV
LABELV $1481
line 2204
;2203:	}
;2204:	return qfalse;
CNSTI4 0
RETI4
LABELV $1480
endproc prop_textalign 16 8
proc prop_background 60 8
line 2208
;2205:}
;2206:
;2207:// image <const char*>
;2208:static qboolean prop_background(item_t *itm, int handle) {
line 2210
;2209:	const char *s;
;2210:	if (!PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1490
line 2211
;2211:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1490
line 2213
;2212:	}
;2213:	if (strcmp("ICON_GAME_TYPE", s) == 0) {
ADDRGP4 $1494
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1492
line 2214
;2214:		itm->iconFlags |= ICON_GAME_TYPE;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2215
;2215:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1492
line 2217
;2216:	}
;2217:	else if (strcmp("ICON_HOLDABLE_ITEM", s) == 0) {
ADDRGP4 $1497
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1495
line 2218
;2218:		itm->iconFlags |= ICON_HOLDABLE_ITEM;
ADDRLP4 16
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 2
BORU4
ASGNU4
line 2219
;2219:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1495
line 2221
;2220:	}
;2221:	else if (strcmp("ICON_BLUE_FLAG", s) == 0) {
ADDRGP4 $1500
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $1498
line 2222
;2222:		itm->iconFlags |= ICON_BLUE_FLAG;
ADDRLP4 20
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
line 2223
;2223:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1498
line 2225
;2224:	}
;2225:	else if (strcmp("ICON_RED_FLAG", s) == 0) {
ADDRGP4 $1503
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $1501
line 2226
;2226:		itm->iconFlags |= ICON_RED_FLAG;
ADDRLP4 24
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2227
;2227:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1501
line 2229
;2228:	}
;2229:	else if (strcmp("ICON_HEAD", s) == 0) {
ADDRGP4 $1506
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $1504
line 2230
;2230:		itm->iconFlags |= ICON_HEAD;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
line 2231
;2231:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1504
line 2233
;2232:	}
;2233:	else if (strcmp("ICON_HEAD_ANIM", s) == 0) {
ADDRGP4 $1509
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $1507
line 2234
;2234:		itm->iconFlags |= ICON_HEAD_ANIM;
ADDRLP4 32
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRU4
CNSTU4 128
BORU4
ASGNU4
line 2235
;2235:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1507
line 2237
;2236:	}
;2237:	else if (strcmp("ICON_ARMOR", s) == 0) {
ADDRGP4 $1512
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $1510
line 2238
;2238:		itm->iconFlags |= ICON_ARMOR;
ADDRLP4 36
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRU4
CNSTU4 512
BORU4
ASGNU4
line 2239
;2239:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1510
line 2241
;2240:	}
;2241:	else if (strcmp("ICON_AMMO", s) == 0) {
ADDRGP4 $1515
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $1513
line 2242
;2242:		itm->iconFlags |= ICON_AMMO;
ADDRLP4 40
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRU4
CNSTU4 1024
BORU4
ASGNU4
line 2243
;2243:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1513
line 2245
;2244:	}
;2245:	else if (strcmp("ICON_ORDER", s) == 0) {
ADDRGP4 $1518
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $1516
line 2246
;2246:		itm->iconFlags |= ICON_ORDER;
ADDRLP4 44
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 44
INDIRP4
ADDRLP4 44
INDIRP4
INDIRU4
CNSTU4 2048
BORU4
ASGNU4
line 2247
;2247:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1516
line 2249
;2248:	}
;2249:	else if (strcmp("ICON_POWERUP", s) == 0) {
ADDRGP4 $1521
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 44
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
NEI4 $1519
line 2250
;2250:		itm->iconFlags |= ICON_POWERUP;
ADDRLP4 48
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 48
INDIRP4
ADDRLP4 48
INDIRP4
INDIRU4
CNSTU4 4096
BORU4
ASGNU4
line 2251
;2251:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1519
line 2253
;2252:	}
;2253:	else if (strcmp("ICON_ATTACKER", s) == 0) {
ADDRGP4 $1524
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 48
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
NEI4 $1522
line 2254
;2254:		itm->iconFlags |= ICON_ATTACKER;
ADDRLP4 52
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 52
INDIRP4
ADDRLP4 52
INDIRP4
INDIRU4
CNSTU4 8192
BORU4
ASGNU4
line 2255
;2255:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1522
line 2259
;2256:	}
;2257:	// This one is the team arena animated background
;2258:	// it uses a special shader
;2259:	else if (strcmp("menuscreen2", s) == 0) {
ADDRGP4 $1527
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 0
NEI4 $1525
line 2260
;2260:		itm->shader = cgs.media.menuscreen2;
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
ADDRGP4 cgs+148752+956
INDIRI4
ASGNI4
line 2261
;2261:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1489
JUMPV
LABELV $1525
line 2264
;2262:	}
;2263:
;2264:	itm->shader = trap_R_RegisterShaderNoMip(s);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 56
ADDRGP4 trap_R_RegisterShaderNoMip
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 1192
ADDP4
ADDRLP4 56
INDIRI4
ASGNI4
line 2265
;2265:	return qtrue;
CNSTI4 1
RETI4
LABELV $1489
endproc prop_background 60 8
proc prop_verticalbar 16 12
line 2270
;2266:}
;2267:
;2268:
;2269:// verticalbar <qboolean>
;2270:static qboolean prop_verticalbar(item_t *itm, int handle) {
line 2272
;2271:	qboolean vertic;
;2272:	qboolean def = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2273
;2273:	if (!PC_bool_Parse(handle, def, &vertic)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_bool_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1531
line 2275
;2274:		// if keyword 'verticalbar' alone
;2275:		itm->propFlags |= PROP_VERTICALBAR;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2276
;2276:		return def;
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $1530
JUMPV
LABELV $1531
line 2278
;2277:	}
;2278:	else if (vertic) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1533
line 2279
;2279:		itm->propFlags |= PROP_VERTICALBAR;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 8
BORU4
ASGNU4
line 2280
;2280:	}
LABELV $1533
line 2281
;2281:	return qtrue;
CNSTI4 1
RETI4
LABELV $1530
endproc prop_verticalbar 16 12
proc prop_Size 12 8
line 2285
;2282:}
;2283:
;2284:// fontsize <charSizeDef_t>
;2285:static qboolean prop_Size(item_t *itm, int handle) {
line 2287
;2286:	qboolean onlyWidth;
;2287:	if (PC_Float_Parse(handle, &itm->fontsize.w)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1120
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1536
line 2288
;2288:		onlyWidth = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2289
;2289:		if (PC_Float_Parse(handle, &itm->fontsize.h)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1538
line 2290
;2290:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1535
JUMPV
LABELV $1538
line 2292
;2291:		}
;2292:	}
LABELV $1536
line 2294
;2293:	// if only Width is provided, height = width
;2294:	if (onlyWidth && !itm->fontsize.h)
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1540
ADDRFP4 0
INDIRP4
CNSTI4 1124
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1540
line 2295
;2295:		itm->fontsize.h = itm->fontsize.w;
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
CNSTI4 1124
ADDP4
ADDRLP4 8
INDIRP4
CNSTI4 1120
ADDP4
INDIRF4
ASGNF4
LABELV $1540
line 2296
;2296:	return onlyWidth;
ADDRLP4 0
INDIRI4
RETI4
LABELV $1535
endproc prop_Size 12 8
proc prop_font 16 8
line 2300
;2297:}
;2298:
;2299:// font <fontType_t>
;2300:static qboolean prop_font(item_t *itm, int handle) {
line 2303
;2301:	const char *temp;
;2302:
;2303:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1543
line 2304
;2304:		if (strcmp("numbers", temp) == 0)
ADDRGP4 $1547
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1545
line 2305
;2305:			itm->text.styleflags |= DS_FONT_NUMBER;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1200
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
LABELV $1545
line 2308
;2306:		//else if (strcmp("other", temp) == 0) // for futur dev
;2307:		//	itm->text.styleflags |= DS_FONT_OTHER;
;2308:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1542
JUMPV
LABELV $1543
line 2310
;2309:	}
;2310:	return qfalse;
CNSTI4 0
RETI4
LABELV $1542
endproc prop_font 16 8
proc prop_param 4 8
line 2314
;2311:}
;2312:
;2313:// param <int>
;2314:static qboolean prop_param(item_t *itm, int handle) {
line 2315
;2315:	if (!PC_Int_Parse(handle, &itm->param)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1036
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1549
line 2316
;2316:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1548
JUMPV
LABELV $1549
line 2318
;2317:	}
;2318:	return qtrue;
CNSTI4 1
RETI4
LABELV $1548
endproc prop_param 4 8
proc CheckAlpha 4 8
line 2329
;2319:}
;2320:
;2321:/*
;2322:=================
;2323:CheckAlpha
;2324:Use a specific alpha when provide after flag:
;2325:C_COLOR_TEAMS | C_COLOR_TEAM | etc..
;2326:=================
;2327:*/
;2328://retour ligne 761---------------------------------------------------------------------------------
;2329:static qboolean CheckAlpha(int handle, color_Def_t *col, float *alpha) {//todo virer itm
line 2330
;2330:	if (needCacheToken)//GUNNM TODO: do we need this test?
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1552
line 2331
;2331:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1551
JUMPV
LABELV $1552
line 2333
;2332:
;2333:	if (col->colorflags & C_COLOR_RGBA)
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRU4
CNSTU4 1
BANDU4
CNSTU4 0
EQU4 $1554
line 2334
;2334:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1551
JUMPV
LABELV $1554
line 2336
;2335:
;2336:	if (!PC_Float_Parse(handle, alpha)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Float_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1556
line 2337
;2337:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1551
JUMPV
LABELV $1556
line 2340
;2338:	}
;2339:
;2340:	return qtrue;
CNSTI4 1
RETI4
LABELV $1551
endproc CheckAlpha 4 8
proc prop_forecolor 12 12
line 2345
;2341:}
;2342:
;2343://GUNNM TODO factorise those 2 fct
;2344:// forecolor <vec4_t>
;2345:static qboolean prop_forecolor(item_t *itm, int handle) {
line 2346
;2346:	if (!Color_Str_Parse(handle, &itm->forecolor)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1152
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 Color_Str_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1559
line 2347
;2347:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1558
JUMPV
LABELV $1559
line 2350
;2348:	}
;2349:
;2350:	if (CheckAlpha(handle, &itm->forecolor, &itm->forecolor.alpha)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1152
ADDP4
ARGP4
ADDRLP4 4
INDIRP4
CNSTI4 1172
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 CheckAlpha
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1561
line 2352
;2351:		//itm->forecolor.colorflags |= C_COLOR_FORCE_ALPHA;
;2352:	}
LABELV $1561
line 2353
;2353:	return qtrue;
CNSTI4 1
RETI4
LABELV $1558
endproc prop_forecolor 12 12
proc prop_backcolor 12 12
line 2357
;2354:}
;2355:
;2356:// backcolor <vec4_t>
;2357:static qboolean prop_backcolor(item_t *itm, int handle) {
line 2358
;2358:	if (!Color_Str_Parse(handle, &itm->backcolor)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1128
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 Color_Str_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1564
line 2359
;2359:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1563
JUMPV
LABELV $1564
line 2362
;2360:	}
;2361:	
;2362:	if (CheckAlpha(handle, &itm->backcolor, &itm->backcolor.alpha)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
CNSTI4 1128
ADDP4
ARGP4
ADDRLP4 4
INDIRP4
CNSTI4 1148
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 CheckAlpha
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1566
line 2364
;2363:		//itm->backcolor.colorflags |= C_COLOR_FORCE_ALPHA;
;2364:	}
LABELV $1566
line 2365
;2365:	return qtrue;
CNSTI4 1
RETI4
LABELV $1563
endproc prop_backcolor 12 12
proc addAnchorFlags 40 0
ADDRFP4 4
ADDRFP4 4
INDIRI4
CVII1 4
ASGNI1
line 2369
;2366:}
;2367:
;2368:
;2369:static qboolean addAnchorFlags(item_t *itm, const char firstChar) {
line 2370
;2370:	switch (firstChar) {
ADDRLP4 0
ADDRFP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 76
EQI4 $1572
ADDRLP4 0
INDIRI4
CNSTI4 77
EQI4 $1576
ADDRLP4 0
INDIRI4
CNSTI4 77
GTI4 $1579
LABELV $1578
ADDRLP4 0
INDIRI4
CNSTI4 66
EQI4 $1577
ADDRLP4 0
INDIRI4
CNSTI4 67
EQI4 $1573
ADDRGP4 $1569
JUMPV
LABELV $1579
ADDRLP4 0
INDIRI4
CNSTI4 82
EQI4 $1574
ADDRLP4 0
INDIRI4
CNSTI4 84
EQI4 $1575
ADDRGP4 $1569
JUMPV
LABELV $1572
line 2372
;2371:	case 'L':
;2372:		itm->propFlags |= PROP_ANCHOR_LEFT;
ADDRLP4 16
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 16
BORU4
ASGNU4
line 2373
;2373:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1568
JUMPV
LABELV $1573
line 2375
;2374:	case 'C':
;2375:		itm->propFlags |= PROP_ANCHOR_CENTER;
ADDRLP4 20
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
CNSTU4 32
BORU4
ASGNU4
line 2376
;2376:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1568
JUMPV
LABELV $1574
line 2378
;2377:	case 'R':
;2378:		itm->propFlags |= PROP_ANCHOR_RIGHT;
ADDRLP4 24
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 24
INDIRP4
ADDRLP4 24
INDIRP4
INDIRU4
CNSTU4 64
BORU4
ASGNU4
line 2379
;2379:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1568
JUMPV
LABELV $1575
line 2381
;2380:	case 'T':
;2381:		itm->propFlags |= PROP_ANCHOR_TOP;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRU4
CNSTU4 128
BORU4
ASGNU4
line 2382
;2382:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1568
JUMPV
LABELV $1576
line 2384
;2383:	case 'M':
;2384:		itm->propFlags |= PROP_ANCHOR_MIDDLE;
ADDRLP4 32
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
line 2385
;2385:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1568
JUMPV
LABELV $1577
line 2387
;2386:	case 'B':
;2387:		itm->propFlags |= PROP_ANCHOR_BOTTOM;
ADDRLP4 36
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRU4
CNSTU4 512
BORU4
ASGNU4
line 2388
;2388:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1568
JUMPV
LABELV $1569
line 2390
;2389:	default:
;2390:		return qfalse;
CNSTI4 0
RETI4
LABELV $1568
endproc addAnchorFlags 40 0
proc prop_anchors 16 8
line 2395
;2391:	}
;2392:}
;2393:
;2394:// anchors <L|C|R> and <T|M|B> or <Left|Center|Right> and <Top|Middle|Bottom>
;2395:static qboolean prop_anchors(item_t *itm, int handle) {
line 2398
;2396:	const char *temp;
;2397:	// one or two flags possible. eg: "anchor Top Right"
;2398:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1581
line 2399
;2399:		addAnchorFlags(itm, temp[0]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRGP4 addAnchorFlags
CALLI4
pop
line 2401
;2400:		// check if two anchors were defined
;2401:		if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 8
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1583
line 2402
;2402:			if (temp[0] == '}') {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1585
line 2403
;2403:				itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2404
;2404:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1580
JUMPV
LABELV $1585
line 2407
;2405:			}
;2406:
;2407:			if (!addAnchorFlags(itm, temp[0])) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 12
ADDRGP4 addAnchorFlags
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1584
line 2408
;2408:				needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2409
;2409:				cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2411
;2410:				// one anchor flag is enough
;2411:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1580
JUMPV
line 2413
;2412:			}
;2413:		}
LABELV $1583
line 2414
;2414:		else {
line 2415
;2415:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2416
;2416:			cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2417
;2417:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1580
JUMPV
LABELV $1584
line 2420
;2418:		}
;2419:
;2420:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1580
JUMPV
LABELV $1581
line 2422
;2421:	}
;2422:	return qfalse;
CNSTI4 0
RETI4
LABELV $1580
endproc prop_anchors 16 8
proc prop_fill 16 12
line 2426
;2423:}
;2424:
;2425:// fill <qboolean>
;2426:static qboolean prop_fill(item_t *itm, int handle) {
line 2428
;2427:	qboolean res;
;2428:	qboolean defaultValue = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2429
;2429:	if (!PC_bool_Parse(handle, defaultValue, &res)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_bool_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1590
line 2430
;2430:		if (defaultValue)
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1592
line 2431
;2431:			itm->propFlags |= PROP_FILL;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 4096
BORU4
ASGNU4
LABELV $1592
line 2432
;2432:		return defaultValue;
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $1589
JUMPV
LABELV $1590
line 2434
;2433:	}
;2434:	if (res) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1594
line 2435
;2435:		itm->propFlags |= PROP_FILL;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 4096
BORU4
ASGNU4
line 2436
;2436:	}
LABELV $1594
line 2438
;2437:
;2438:	return qtrue;
CNSTI4 1
RETI4
LABELV $1589
endproc prop_fill 16 12
proc bool_ParseStr 12 8
line 2441
;2439:}
;2440:
;2441:static qboolean bool_ParseStr(const char *str, qboolean defaultValue, qboolean *b) {
line 2442
;2442:	if (str[0] == '}') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1597
line 2443
;2443:		*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2444
;2444:		itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2445
;2445:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1596
JUMPV
LABELV $1597
line 2448
;2446:	}
;2447:	// e.g. when just the keyword 'visible' alone, it mean visible = qtrue
;2448:	else if (str[0] == '\0' || str[0] == ';') {
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1601
ADDRLP4 0
INDIRI4
CNSTI4 59
NEI4 $1599
LABELV $1601
line 2449
;2449:		*b = defaultValue;
ADDRFP4 8
INDIRP4
ADDRFP4 4
INDIRI4
ASGNI4
line 2450
;2450:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1596
JUMPV
LABELV $1599
line 2452
;2451:	}
;2452:	else if (strcmp("false", str) == 0 || str[0] == '0') {
ADDRGP4 $1450
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1604
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $1602
LABELV $1604
line 2453
;2453:		*b = qfalse;
ADDRFP4 8
INDIRP4
CNSTI4 0
ASGNI4
line 2454
;2454:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1596
JUMPV
LABELV $1602
line 2456
;2455:	}
;2456:	else if (strcmp("true", str) == 0 || str[0] == '1') {
ADDRGP4 $1454
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1607
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 49
NEI4 $1605
LABELV $1607
line 2457
;2457:		*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
line 2458
;2458:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1596
JUMPV
LABELV $1605
line 2460
;2459:	}
;2460:	else {
line 2461
;2461:		if (defaultValue)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $1608
line 2462
;2462:			*b = qtrue;
ADDRFP4 8
INDIRP4
CNSTI4 1
ASGNI4
LABELV $1608
line 2463
;2463:	}
line 2465
;2464:
;2465:	return qfalse;
CNSTI4 0
RETI4
LABELV $1596
endproc bool_ParseStr 12 8
proc prop_icon3D 16 12
line 2469
;2466:}
;2467:
;2468:// icon3D <qboolean>
;2469:static qboolean prop_icon3D(item_t *itm, int handle) {
line 2471
;2470:	qboolean res;
;2471:	qboolean defaultValue = qtrue;
ADDRLP4 0
CNSTI4 1
ASGNI4
line 2472
;2472:	if (!PC_bool_Parse(handle, defaultValue, &res)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 8
ADDRGP4 PC_bool_Parse
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1611
line 2473
;2473:		if (defaultValue)
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1613
line 2474
;2474:			itm->iconFlags |= ICON_3D;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
LABELV $1613
line 2475
;2475:		return defaultValue;
ADDRLP4 0
INDIRI4
RETI4
ADDRGP4 $1610
JUMPV
LABELV $1611
line 2477
;2476:	}
;2477:	if (res) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1615
line 2478
;2478:		itm->iconFlags |= ICON_3D;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1056
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 256
BORU4
ASGNU4
line 2479
;2479:	}
LABELV $1615
line 2480
;2480:	return qtrue;
CNSTI4 1
RETI4
LABELV $1610
endproc prop_icon3D 16 12
proc prop_BlinkWhenLow 4 0
line 2482
;2481:}
;2482:static qboolean prop_BlinkWhenLow(item_t *itm, int handle) {
line 2489
;2483:	/*qboolean res;
;2484:	qboolean defaultValue = qtrue;
;2485:	if (!PC_bool_Parse(handle, defaultValue, &res)) {
;2486:		return defaultValue;
;2487:	}
;2488:	if (res) {*/
;2489:		itm->propFlags |= PROP_BLINK_WHEN_LOW;
ADDRLP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
INDIRU4
CNSTU4 8192
BORU4
ASGNU4
line 2491
;2490:	//}
;2491:	return qtrue;
CNSTI4 1
RETI4
LABELV $1617
endproc prop_BlinkWhenLow 4 0
proc prop_time 4 8
line 2495
;2492:}
;2493:
;2494:// time <int>
;2495:static qboolean prop_time(item_t *itm, int handle) {
line 2496
;2496:	if (!PC_Int_Parse(handle, &itm->time)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1032
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1619
line 2497
;2497:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1618
JUMPV
LABELV $1619
line 2499
;2498:	}
;2499:	return qtrue;
CNSTI4 1
RETI4
LABELV $1618
endproc prop_time 4 8
proc prop_TeamPlayer 8 8
line 2502
;2500:}
;2501:
;2502:static qboolean prop_TeamPlayer(item_t *itm, int handle) {
line 2503
;2503:	if (!PC_Int_Parse(handle, &itm->team_player)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
CNSTI4 1044
ADDP4
ARGP4
ADDRLP4 0
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $1622
line 2504
;2504:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1621
JUMPV
LABELV $1622
line 2506
;2505:	}
;2506:	itm->propFlags |= PROP_TEAM_PLAYER;
ADDRLP4 4
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 4
INDIRP4
INDIRU4
CNSTU4 16384
BORU4
ASGNU4
line 2507
;2507:	return qtrue;
CNSTI4 1
RETI4
LABELV $1621
endproc prop_TeamPlayer 8 8
data
export vis_Keywords
align 4
LABELV vis_Keywords
address $1624
byte 4 2
byte 4 0
address $1625
byte 4 1
byte 4 0
address $1626
byte 4 4
byte 4 0
address $1627
byte 4 16
byte 4 0
address $1628
byte 4 8
byte 4 0
address $1629
byte 4 32
byte 4 0
address $1630
byte 4 64
byte 4 0
address $1631
byte 4 128
byte 4 0
address $1632
byte 4 256
byte 4 0
address $1633
byte 4 512
byte 4 0
address $1634
byte 4 1024
byte 4 0
address $1635
byte 4 2048
byte 4 0
address $1636
byte 4 4096
byte 4 0
address $1637
byte 4 8192
byte 4 0
address $1638
byte 4 16384
byte 4 0
address $1639
byte 4 32768
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export flag_KeywordHash_Add
code
proc flag_KeywordHash_Add 8 4
line 2544
;2508:}
;2509:/*
;2510:===============
;2511:value list hash
;2512:===============
;2513:*/
;2514:typedef struct flag_keywordHash_s
;2515:{
;2516:	char *keyword;
;2517:	int flag;
;2518:	struct flag_keywordHash_s *next;
;2519:} flag_keywordHash_t;
;2520:
;2521:flag_keywordHash_t vis_Keywords[] = {
;2522:	//HUD keyword				Visibility flags		NULL
;2523:	{"VIS_IN_SCORE",			VIS_IN_SCORE,			NULL},
;2524:	{"VIS_NEVER",				VIS_NEVER,				NULL},
;2525:	{"VIS_IN_MENU",				VIS_IN_MENU,			NULL},
;2526:	{"VIS_LOCAL_SERVER",		VIS_LOCAL_SERVER,		NULL},
;2527:	{"VIS_PMF_FOLLOW",			VIS_PMF_FOLLOW,			NULL},
;2528:	{"VIS_LOW_AMMO_WARNING",	VIS_LOW_AMMO_WARNING,	NULL},
;2529:	{"VIS_OUT_OF_AMMO",			VIS_OUT_OF_AMMO,		NULL},
;2530:	{"VIS_WARMUP",				VIS_WARMUP,				NULL},
;2531:	{"VIS_ZERO_VALUE",			VIS_ZERO_VALUE,			NULL},
;2532:	{"VIS_DISCONNECTED",		VIS_DISCONNECTED,		NULL},
;2533:	{"VIS_BLINK",				VIS_BLINK,				NULL},
;2534:	{"VIS_BLUE_FLAG_TAKEN",		VIS_BLUE_FLAG_TAKEN,	NULL},
;2535:	{"VIS_RED_FLAG_TAKEN",		VIS_RED_FLAG_TAKEN,		NULL},
;2536:	{"VIS_POWERUP_1",			VIS_POWERUP_1,			NULL},
;2537:	{"VIS_PICKUP_ITEM",			VIS_PICKUP_ITEM,		NULL},//fixme: does not worked, item always visible
;2538:	{"VIS_FIRING",				VIS_FIRING,				NULL},
;2539:	{NULL, 0, NULL}
;2540:};
;2541:
;2542:flag_keywordHash_t *flag_KeywordHash[KEYWORDHASH_SIZE];
;2543:
;2544:void flag_KeywordHash_Add(flag_keywordHash_t *table[], flag_keywordHash_t *key) {
line 2547
;2545:	int hash;
;2546:
;2547:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2548
;2548:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2549
;2549:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2550
;2550:}
LABELV $1640
endproc flag_KeywordHash_Add 8 4
export flag_KeywordHash_Find
proc flag_KeywordHash_Find 16 8
line 2553
;2551:
;2552:flag_keywordHash_t *flag_KeywordHash_Find(flag_keywordHash_t *table[], char *keyword)
;2553:{
line 2557
;2554:	flag_keywordHash_t *key;
;2555:	int hash;
;2556:
;2557:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2558
;2558:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1645
JUMPV
LABELV $1642
line 2559
;2559:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1646
line 2560
;2560:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1641
JUMPV
LABELV $1646
line 2561
;2561:	}
LABELV $1643
line 2558
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1645
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1642
line 2562
;2562:	return NULL;
CNSTP4 0
RETP4
LABELV $1641
endproc flag_KeywordHash_Find 16 8
export flag_SetupKeywordHash
proc flag_SetupKeywordHash 4 12
line 2565
;2563:}
;2564:
;2565:void flag_SetupKeywordHash(void) {
line 2568
;2566:	int i;
;2567:
;2568:	memset(flag_KeywordHash, 0, sizeof(flag_KeywordHash));
ADDRGP4 flag_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2569
;2569:	for (i = 0; vis_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1652
JUMPV
LABELV $1649
line 2570
;2570:		flag_KeywordHash_Add(flag_KeywordHash, &vis_Keywords[i]);
ADDRGP4 flag_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 vis_Keywords
ADDP4
ARGP4
ADDRGP4 flag_KeywordHash_Add
CALLV
pop
line 2571
;2571:	}
LABELV $1650
line 2569
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1652
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 vis_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1649
line 2572
;2572:}
LABELV $1648
endproc flag_SetupKeywordHash 4 12
export value_KeywordHash_Add
proc value_KeywordHash_Add 8 4
line 2579
;2573:
;2574:/*
;2575:===============
;2576:value visible flags list hash
;2577:===============
;2578:*/
;2579:void value_KeywordHash_Add(flag_keywordHash_t *table[], flag_keywordHash_t *key) {
line 2582
;2580:	int hash;
;2581:
;2582:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2583
;2583:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2584
;2584:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2585
;2585:}
LABELV $1653
endproc value_KeywordHash_Add 8 4
export value_KeywordHash_Find
proc value_KeywordHash_Find 16 8
line 2588
;2586:
;2587:flag_keywordHash_t *value_KeywordHash_Find(flag_keywordHash_t *table[], char *keyword)
;2588:{
line 2592
;2589:	flag_keywordHash_t *key;
;2590:	int hash;
;2591:
;2592:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2593
;2593:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1658
JUMPV
LABELV $1655
line 2594
;2594:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1659
line 2595
;2595:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1654
JUMPV
LABELV $1659
line 2596
;2596:	}
LABELV $1656
line 2593
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1658
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1655
line 2597
;2597:	return NULL;
CNSTP4 0
RETP4
LABELV $1654
endproc value_KeywordHash_Find 16 8
data
export value_Keywords
align 4
LABELV value_Keywords
address $1661
byte 4 8
byte 4 0
address $1662
byte 4 16
byte 4 0
address $1663
byte 4 4
byte 4 0
address $1664
byte 4 32
byte 4 0
address $1665
byte 4 1024
byte 4 0
address $1666
byte 4 256
byte 4 0
address $1667
byte 4 64
byte 4 0
address $1668
byte 4 128
byte 4 0
address $1669
byte 4 512
byte 4 0
address $1670
byte 4 32768
byte 4 0
address $1671
byte 4 65536
byte 4 0
address $1672
byte 4 2048
byte 4 0
address $1673
byte 4 4096
byte 4 0
address $1674
byte 4 8192
byte 4 0
address $1675
byte 4 16384
byte 4 0
address $1676
byte 4 131072
byte 4 0
address $1677
byte 4 2
byte 4 0
address $1678
byte 4 262144
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export value_SetupKeywordHash
code
proc value_SetupKeywordHash 4 12
line 2627
;2598:}
;2599:
;2600:flag_keywordHash_t value_Keywords[] = {
;2601:	// caption and gradient flags:
;2602:	{ "VAL_HEALTH",			VAL_HEALTH,			NULL },
;2603:	{ "VAL_ARMOR",			VAL_ARMOR,			NULL },
;2604:	{ "VAL_AMMO",			VAL_AMMO,			NULL },
;2605:	{ "VAL_WEAPON",			VAL_WEAPON,			NULL },
;2606:	{ "VAL_SCORE",			VAL_SCORE,			NULL },
;2607:	{ "VAL_TIMER",			VAL_TIMER,			NULL },
;2608:	{ "VAL_HOLDABLE_ITEM",	VAL_HOLDABLE_ITEM,	NULL },
;2609:	{ "VAL_FPS",			VAL_FPS,			NULL },
;2610:	{ "VAL_SPEED",			VAL_SPEED,			NULL },
;2611:	{ "VAL_FOLLOW_NAME",	VAL_FOLLOW_NAME,	NULL },
;2612:	{ "VAL_SNAPSHOT",		VAL_SNAPSHOT,		NULL },
;2613:	{ "VAL_CAPFRAG_LIMIT",	VAL_CAPFRAG_LIMIT,	NULL },
;2614:	{ "VAL_FRAG_LIMIT",		VAL_FRAG_LIMIT,		NULL },
;2615:	{ "VAL_CAPTURE_LIMIT",	VAL_CAPTURE_LIMIT,	NULL },
;2616:	{ "VAL_TIME_LIMIT",		VAL_TIME_LIMIT,		NULL },
;2617:	{ "VAL_LOCATION",		VAL_LOCATION,		NULL },
;2618:	{ "VAL_NAME",			VAL_NAME,			NULL },
;2619:	{ "VAL_PLAYERS_NB_TEAM",VAL_PLAYERS_NB_TEAM,NULL },
;2620:
;2621:	{ NULL, 0, NULL }
;2622:};
;2623:
;2624:flag_keywordHash_t *value_KeywordHash[KEYWORDHASH_SIZE];
;2625:
;2626://fill value_KeywordHash list
;2627:void value_SetupKeywordHash(void) {
line 2630
;2628:	int i;
;2629:
;2630:	memset(value_KeywordHash, 0, sizeof(value_KeywordHash));
ADDRGP4 value_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2631
;2631:	for (i = 0; value_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1683
JUMPV
LABELV $1680
line 2632
;2632:		value_KeywordHash_Add(value_KeywordHash, &value_Keywords[i]);
ADDRGP4 value_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 value_Keywords
ADDP4
ARGP4
ADDRGP4 value_KeywordHash_Add
CALLV
pop
line 2633
;2633:	}
LABELV $1681
line 2631
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1683
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 value_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1680
line 2634
;2634:}
LABELV $1679
endproc value_SetupKeywordHash 4 12
export GT_Vis_KeywordHash_Add
proc GT_Vis_KeywordHash_Add 8 4
line 2641
;2635:
;2636:/*
;2637:===============
;2638:GT_visible flags list hash
;2639:===============
;2640:*/
;2641:void GT_Vis_KeywordHash_Add(flag_keywordHash_t *table[], flag_keywordHash_t *key) {
line 2644
;2642:	int hash;
;2643:
;2644:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2645
;2645:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2646
;2646:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2647
;2647:}
LABELV $1684
endproc GT_Vis_KeywordHash_Add 8 4
export GT_Vis_KeywordHash_Find
proc GT_Vis_KeywordHash_Find 16 8
line 2650
;2648:
;2649:flag_keywordHash_t *GT_Vis_KeywordHash_Find(flag_keywordHash_t *table[], char *keyword)
;2650:{
line 2654
;2651:	flag_keywordHash_t *key;
;2652:	int hash;
;2653:
;2654:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2655
;2655:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1689
JUMPV
LABELV $1686
line 2656
;2656:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1690
line 2657
;2657:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1685
JUMPV
LABELV $1690
line 2658
;2658:	}
LABELV $1687
line 2655
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1689
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1686
line 2659
;2659:	return NULL;
CNSTP4 0
RETP4
LABELV $1685
endproc GT_Vis_KeywordHash_Find 16 8
data
export GT_Vis_Keywords
align 4
LABELV GT_Vis_Keywords
address $1692
byte 4 1
byte 4 0
address $1693
byte 4 2
byte 4 0
address $1694
byte 4 4
byte 4 0
address $1695
byte 4 8
byte 4 0
address $1696
byte 4 16
byte 4 0
address $1697
byte 4 32
byte 4 0
address $1698
byte 4 512
byte 4 0
address $1699
byte 4 1024
byte 4 0
address $1700
byte 4 4096
byte 4 0
address $1701
byte 4 2048
byte 4 0
address $1702
byte 4 4096
byte 4 0
address $1703
byte 4 8192
byte 4 0
address $1704
byte 4 16384
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export GT_Vis_SetupKeywordHash
code
proc GT_Vis_SetupKeywordHash 4 12
line 2687
;2660:}
;2661:
;2662:flag_keywordHash_t GT_Vis_Keywords[] = {
;2663:	{"VIS_TEAM_PLAY",			VIS_TEAM_PLAY,			NULL},
;2664:	{"VIS_GT_TOURNAMENT",		VIS_GT_TOURNAMENT,		NULL},
;2665:	{"VIS_GT_FFA",				VIS_GT_FFA,				NULL},
;2666:	{"VIS_GT_TDM",				VIS_GT_TDM,				NULL},
;2667:	{"VIS_GT_CTF",				VIS_GT_CTF,				NULL},
;2668:#ifdef MISSIONPACK
;2669:	{"VIS_GT_1FCTF",			VIS_ONLY_GT_1FCTF,		NULL},
;2670:	{"VIS_GT_OBELISK",			VIS_ONLY_GT_OBELISK,	NULL},
;2671:	"VIS_GT_HARVESTER",			VIS_ONLY_GT_HARVESTER,	NULL },
;2672:#endif
;2673:	{ "VIS_GT_FREEZE",			VIS_GT_FREEZE,			NULL },
;2674:	{ "VIS_TEAM_BLUE",			VIS_TEAM_BLUE,			NULL },
;2675:	{ "VIS_TEAM_RED",			VIS_TEAM_RED,			NULL },
;2676:	{ "VIS_TEAM_SPEC",			VIS_TEAM_SPECTATOR,		NULL },
;2677:	{ "VIS_TEAM_BLUE_OR_RED",	VIS_TEAM_BLUE_OR_RED,	NULL },
;2678:	{ "VIS_TEAM_SPECTATOR",		VIS_TEAM_SPECTATOR,		NULL },
;2679:	{ "VIS_SHOW_TEAMINFO",		VIS_SHOW_TEAMINFO,		NULL },
;2680:	{ "VIS_TEAM_PLAYER",		VIS_TEAM_PLAYER,		NULL },
;2681:{ NULL, 0, NULL }
;2682:};
;2683:
;2684:flag_keywordHash_t *GT_Vis_KeywordHash[KEYWORDHASH_SIZE];
;2685:
;2686://fill GT_Vis_KeywordHash list
;2687:void GT_Vis_SetupKeywordHash(void) {
line 2690
;2688:	int i;
;2689:
;2690:	memset(GT_Vis_KeywordHash, 0, sizeof(GT_Vis_KeywordHash));
ADDRGP4 GT_Vis_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2691
;2691:	for (i = 0; GT_Vis_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1709
JUMPV
LABELV $1706
line 2692
;2692:		GT_Vis_KeywordHash_Add(GT_Vis_KeywordHash, &GT_Vis_Keywords[i]);
ADDRGP4 GT_Vis_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 GT_Vis_Keywords
ADDP4
ARGP4
ADDRGP4 GT_Vis_KeywordHash_Add
CALLV
pop
line 2693
;2693:	}
LABELV $1707
line 2691
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1709
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 GT_Vis_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1706
line 2694
;2694:}
LABELV $1705
endproc GT_Vis_SetupKeywordHash 4 12
proc addVisibilityFlags 1088 8
line 2702
;2695:
;2696:
;2697:/*
;2698:===============
;2699:addVisibilityFlags
;2700:===============
;2701:*/
;2702:static qboolean addVisibilityFlags(item_t *itm, int handle, const char *temp) {
line 2704
;2703:	// if keyword 'visible' alone, visible = qtrue
;2704:	if (temp[0] == '\0' || temp[0] == ';') {
ADDRLP4 0
ADDRFP4 8
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1713
ADDRLP4 0
INDIRI4
CNSTI4 59
NEI4 $1711
LABELV $1713
line 2705
;2705:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1711
line 2707
;2706:	}
;2707:	else if (temp[0] == '0' || strcmp("false", temp) == 0) {
ADDRLP4 4
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
EQI4 $1716
ADDRGP4 $1450
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1714
LABELV $1716
line 2708
;2708:		itm->visible_prop_flags[0] |= VIS_NEVER;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2709
;2709:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1714
line 2711
;2710:	}
;2711:	else if (temp[0] == '1' || strcmp("true", temp) == 0) {
ADDRLP4 12
ADDRFP4 8
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
INDIRI1
CVII4 1
CNSTI4 49
EQI4 $1719
ADDRGP4 $1454
ARGP4
ADDRLP4 12
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $1717
LABELV $1719
line 2712
;2712:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1717
line 2714
;2713:	}
;2714:	else {
line 2717
;2715:		pc_token_t token;
;2716:		flag_keywordHash_t *key;
;2717:		int invertFlag = qfalse;
ADDRLP4 20
CNSTI4 0
ASGNI4
line 2720
;2718:
;2719:		// If '!' change visibility to invisibility
;2720:		if (temp[0] == '!') {
ADDRFP4 8
INDIRP4
INDIRI1
CVII4 1
CNSTI4 33
NEI4 $1720
line 2721
;2721:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 28
ARGP4
ADDRLP4 1068
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1068
INDIRI4
CNSTI4 0
NEI4 $1722
line 2722
;2722:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1722
line 2724
;2723:			}
;2724:			temp = token.string;
ADDRFP4 8
ADDRLP4 28+16
ASGNP4
line 2725
;2725:			invertFlag = qtrue;
ADDRLP4 20
CNSTI4 1
ASGNI4
line 2726
;2726:		}
LABELV $1720
line 2729
;2727:
;2728:		// add flag for keywords: VIS_NEVER | VIS_IN_MENU | etc.
;2729:		key = flag_KeywordHash_Find(flag_KeywordHash, (char *)temp);
ADDRGP4 flag_KeywordHash
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 1068
ADDRGP4 flag_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 1068
INDIRP4
ASGNP4
line 2730
;2730:		if (key) {
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1725
line 2731
;2731:			if (invertFlag)
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $1727
line 2732
;2732:				itm->visible_prop_flags[1] |= key->flag;
ADDRLP4 1072
ADDRFP4 0
INDIRP4
CNSTI4 1064
ADDP4
ASGNP4
ADDRLP4 1072
INDIRP4
ADDRLP4 1072
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
ADDRGP4 $1728
JUMPV
LABELV $1727
line 2734
;2733:			else
;2734:				itm->visible_prop_flags[0] |= key->flag;
ADDRLP4 1076
ADDRFP4 0
INDIRP4
CNSTI4 1060
ADDP4
ASGNP4
ADDRLP4 1076
INDIRP4
ADDRLP4 1076
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
LABELV $1728
line 2735
;2735:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1725
line 2739
;2736:		}
;2737:
;2738:		// add flag for keywords: VIS_GT_FFA | VIS_GT_CTF | etc.
;2739:		key = GT_Vis_KeywordHash_Find(GT_Vis_KeywordHash, (char *)temp);
ADDRGP4 GT_Vis_KeywordHash
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 1072
ADDRGP4 GT_Vis_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 1072
INDIRP4
ASGNP4
line 2740
;2740:		if (key) {
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1729
line 2741
;2741:			if (invertFlag)
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $1731
line 2742
;2742:				itm->visible_GT_flags[1] |= key->flag;
ADDRLP4 1076
ADDRFP4 0
INDIRP4
CNSTI4 1080
ADDP4
ASGNP4
ADDRLP4 1076
INDIRP4
ADDRLP4 1076
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
ADDRGP4 $1732
JUMPV
LABELV $1731
line 2744
;2743:			else
;2744:				itm->visible_GT_flags[0] |= key->flag;
ADDRLP4 1080
ADDRFP4 0
INDIRP4
CNSTI4 1076
ADDP4
ASGNP4
ADDRLP4 1080
INDIRP4
ADDRLP4 1080
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
LABELV $1732
line 2745
;2745:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1729
line 2749
;2746:		}
;2747:
;2748:		// add flag for keywords: VAL_HEALTH | VAL_ARMOR | etc.
;2749:		key = value_KeywordHash_Find(value_KeywordHash, (char *)temp);
ADDRGP4 value_KeywordHash
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 1076
ADDRGP4 value_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 1076
INDIRP4
ASGNP4
line 2750
;2750:		if (key) {		
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $1733
line 2751
;2751:			if (invertFlag)
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $1735
line 2752
;2752:				itm->visible_val_flags[1] |= key->flag;
ADDRLP4 1080
ADDRFP4 0
INDIRP4
CNSTI4 1072
ADDP4
ASGNP4
ADDRLP4 1080
INDIRP4
ADDRLP4 1080
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
ADDRGP4 $1736
JUMPV
LABELV $1735
line 2754
;2753:			else
;2754:				itm->visible_val_flags[0] |= key->flag;
ADDRLP4 1084
ADDRFP4 0
INDIRP4
CNSTI4 1068
ADDP4
ASGNP4
ADDRLP4 1084
INDIRP4
ADDRLP4 1084
INDIRP4
INDIRU4
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
LABELV $1736
line 2755
;2755:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1710
JUMPV
LABELV $1733
line 2759
;2756:		}
;2757:
;2758:		//Com_Printf("visibility key not found: %s\n", temp);
;2759:		return qfalse;
CNSTI4 0
RETI4
LABELV $1710
endproc addVisibilityFlags 1088 8
proc prop_visible 20 12
line 2763
;2760:	}
;2761:}
;2762:
;2763:static qboolean prop_visible(item_t *itm, int handle) {
line 2764
;2764:	qboolean defaultValue = qtrue;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 2766
;2765:	const char *temp;
;2766:	qboolean end = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $1739
JUMPV
LABELV $1738
line 2770
;2767:
;2768:	// several visibility flag possible, so we loop until parse error
;2769:	// then keep token on error (we can't unread a token)
;2770:	while (!end) {
line 2771
;2771:		if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 12
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $1741
line 2772
;2772:			if (temp[0] == '}') {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1743
line 2773
;2773:				itemEnd = qtrue;
ADDRGP4 itemEnd
CNSTI4 1
ASGNI4
line 2774
;2774:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1737
JUMPV
LABELV $1743
line 2777
;2775:			}
;2776:
;2777:			if (addVisibilityFlags(itm, handle, temp)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 addVisibilityFlags
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1745
line 2778
;2778:				continue;
ADDRGP4 $1739
JUMPV
LABELV $1745
line 2780
;2779:			}
;2780:			else {
line 2781
;2781:				needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2782
;2782:				cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2783
;2783:				end = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 2784
;2784:			}
line 2785
;2785:		}
ADDRGP4 $1742
JUMPV
LABELV $1741
line 2786
;2786:		else {
line 2787
;2787:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2788
;2788:			cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2789
;2789:			end = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 2791
;2790:			// 'visible' alone is enough
;2791:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1737
JUMPV
LABELV $1742
line 2793
;2792:		}
;2793:	}
LABELV $1739
line 2770
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1738
line 2795
;2794:
;2795:	return qtrue;
CNSTI4 1
RETI4
LABELV $1737
endproc prop_visible 20 12
proc parentIndex 8 8
line 2798
;2796:}
;2797:
;2798:static int parentIndex(const char *parentName) {
line 2801
;2799:	int i;
;2800:
;2801:	for (i = itemCount; i >= 0; i--) {
ADDRLP4 0
ADDRGP4 itemCount
INDIRI4
ASGNI4
ADDRGP4 $1751
JUMPV
LABELV $1748
line 2802
;2802:		if (strcmp(itemArray[i].item_name, parentName) == 0) {
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1752
line 2803
;2803:			return itemArray[i].order;
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray+1024
ADDP4
INDIRI4
RETI4
ADDRGP4 $1747
JUMPV
LABELV $1752
line 2805
;2804:		}
;2805:	}
LABELV $1749
line 2801
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $1751
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $1748
line 2808
;2806:
;2807:	// it could be one of the dynamics item
;2808:	for (i = dyn_itemCount; i >= 0; i--) {
ADDRLP4 0
ADDRGP4 dyn_itemCount
INDIRI4
ASGNI4
ADDRGP4 $1758
JUMPV
LABELV $1755
line 2809
;2809:		if (strcmp(dyn_itemArray[i].item_name, parentName) == 0) {
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1759
line 2811
;2810:			// use sign to indicate that parent is in dyn_itemArray
;2811:			return -dyn_itemArray[i].order;
ADDRLP4 0
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray+1024
ADDP4
INDIRI4
NEGI4
RETI4
ADDRGP4 $1747
JUMPV
LABELV $1759
line 2813
;2812:		}
;2813:	}
LABELV $1756
line 2808
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $1758
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $1755
line 2816
;2814:
;2815:	// use previous item if parent not found, and warn user.
;2816:	Com_Printf("parent item '%s' not found. Parent must be placed before the item.\n", parentName);
ADDRGP4 $1762
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2817
;2817:	return itemCount - 1;
ADDRGP4 itemCount
INDIRI4
CNSTI4 1
SUBI4
RETI4
LABELV $1747
endproc parentIndex 8 8
proc prop_parent 16 12
line 2820
;2818:}
;2819:
;2820:static qboolean prop_parent(item_t *itm, int handle) {
line 2822
;2821:	const char *temp;
;2822:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1764
line 2823
;2823:		int idx = parentIndex(temp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 parentIndex
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
line 2825
;2824:
;2825:		if (idx == 0) {
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1766
line 2826
;2826:			PC_SourceError(handle, "HUD item parent not found: %s \n", temp);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1768
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 2827
;2827:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1763
JUMPV
LABELV $1766
line 2829
;2828:		}
;2829:		else {
line 2830
;2830:			itm->parent = idx;
ADDRFP4 0
INDIRP4
CNSTI4 1028
ADDP4
ADDRLP4 8
INDIRI4
ASGNI4
line 2831
;2831:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1763
JUMPV
LABELV $1764
line 2834
;2832:		}
;2833:	}
;2834:	return qfalse;
CNSTI4 0
RETI4
LABELV $1763
endproc prop_parent 16 12
proc prop_valign 20 8
line 2837
;2835:}
;2836:
;2837:static qboolean prop_valign(item_t *itm, int handle) {
line 2839
;2838:	const char *temp;
;2839:	if (PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1770
line 2840
;2840:		if (temp[0] == 'T')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 84
NEI4 $1772
line 2841
;2841:			itm->propFlags |= PROP_VALIGN_TOP;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
ADDRGP4 $1773
JUMPV
LABELV $1772
line 2842
;2842:		else if (temp[0] == 'M')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 77
NEI4 $1774
line 2843
;2843:			itm->propFlags |= PROP_VALIGN_MIDDLE;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 2
BORU4
ASGNU4
ADDRGP4 $1775
JUMPV
LABELV $1774
line 2844
;2844:		else if (temp[0] == 'B')
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 66
NEI4 $1776
line 2845
;2845:			itm->propFlags |= PROP_VALIGN_BOTTOM;
ADDRLP4 16
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 16
INDIRP4
INDIRU4
CNSTU4 4
BORU4
ASGNU4
ADDRGP4 $1777
JUMPV
LABELV $1776
line 2847
;2846:		else
;2847:		{
line 2848
;2848:			needCacheToken = qtrue;
ADDRGP4 needCacheToken
CNSTI4 1
ASGNI4
line 2849
;2849:			cacheTokenStr = (char *)temp;
ADDRGP4 cacheTokenStr
ADDRLP4 0
INDIRP4
ASGNP4
line 2850
;2850:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1769
JUMPV
LABELV $1777
LABELV $1775
LABELV $1773
line 2852
;2851:		}
;2852:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1769
JUMPV
LABELV $1770
line 2854
;2853:	}
;2854:	return qfalse;
CNSTI4 0
RETI4
LABELV $1769
endproc prop_valign 20 8
proc prop_cvarTest 24 12
line 2857
;2855:}
;2856:
;2857:static qboolean prop_cvarTest(item_t *itm, int handle) {
line 2859
;2858:	const char *temp;
;2859:	if (!PC_String_Parse(handle, &temp)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1779
line 2860
;2860:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1778
JUMPV
LABELV $1779
line 2862
;2861:	}
;2862:	else {
line 2864
;2863:		cvarTest_keywordHash_t *key;
;2864:		char *tmp = (char *)temp;
ADDRLP4 8
ADDRLP4 0
INDIRP4
ASGNP4
line 2865
;2865:		key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, tmp);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 12
ADDRLP4 16
INDIRP4
ASGNP4
line 2866
;2866:		if (!key) {
ADDRLP4 12
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1781
line 2867
;2867:			PC_SourceError(handle, "unknown cvar %s", tmp);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1783
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 2868
;2868:		}
ADDRGP4 $1782
JUMPV
LABELV $1781
line 2869
;2869:		else {
line 2870
;2870:			itm->cvarTest_flags |= key->flag;
ADDRLP4 20
ADDRFP4 0
INDIRP4
CNSTI4 1084
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 20
INDIRP4
INDIRU4
ADDRLP4 12
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
line 2871
;2871:		}
LABELV $1782
line 2872
;2872:	}
line 2873
;2873:	return qtrue;
CNSTI4 1
RETI4
LABELV $1778
endproc prop_cvarTest 24 12
proc ParseFlags 12 8
line 2876
;2874:}
;2875:
;2876:static qboolean ParseFlags(const char *s, unsigned int *flags, int handle) {
line 2878
;2877:	flag_keywordHash_t *key;
;2878:	key = value_KeywordHash_Find(value_KeywordHash, (char *)s);
ADDRGP4 value_KeywordHash
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 value_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 2879
;2879:	if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1785
line 2881
;2880:		//PC_SourceError(handle, "HUD item unknown value/caption: %s", s);
;2881:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1784
JUMPV
LABELV $1785
line 2883
;2882:	}
;2883:	else {
line 2884
;2884:		*flags |= key->flag;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRI4
CVIU4 4
BORU4
ASGNU4
line 2885
;2885:		return qtrue;
CNSTI4 1
RETI4
LABELV $1784
endproc ParseFlags 12 8
proc prop_gradient 16 12
line 2889
;2886:	}
;2887:}
;2888:
;2889:static qboolean prop_gradient(item_t *itm, int handle) {
line 2891
;2890:	const char *s;
;2891:	if (PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1788
line 2892
;2892:		if (*s == '!') {
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 33
NEI4 $1790
line 2893
;2893:			itm->propFlags |= PROP_GRADIENT_INVERT;
ADDRLP4 8
ADDRFP4 0
INDIRP4
CNSTI4 1052
ADDP4
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRU4
CNSTU4 1024
BORU4
ASGNU4
line 2894
;2894:			if (!PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 12
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1792
line 2895
;2895:				Com_Printf("Error HUD item %s, can't parse property 'gradient': %s", itm->item_name, s);
ADDRGP4 $1794
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2896
;2896:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1787
JUMPV
LABELV $1792
line 2898
;2897:			}
;2898:		}
LABELV $1790
line 2899
;2899:		return ParseFlags(s, &itm->gradientFlags, handle);
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 1048
ADDP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 ParseFlags
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
RETI4
ADDRGP4 $1787
JUMPV
LABELV $1788
line 2901
;2900:	}
;2901:	else {
line 2902
;2902:		Com_Printf("Error HUD item %s, can't parse property 'gradient': %s", itm->item_name, s);
ADDRGP4 $1794
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2903
;2903:		return qfalse;
CNSTI4 0
RETI4
LABELV $1787
endproc prop_gradient 16 12
proc prop_caption 16 12
line 2907
;2904:	}
;2905:}
;2906:
;2907:static qboolean prop_caption(item_t *itm, int handle) {
line 2909
;2908:	const char *s;
;2909:	if (PC_String_Parse(handle, &s)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1796
line 2910
;2910:		if (!ParseFlags(s, &itm->text.flags, handle)) {
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 8
ADDRGP4 ParseFlags
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $1798
line 2911
;2911:			itm->text.caption = (char *)s;
ADDRFP4 0
INDIRP4
CNSTI4 1196
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
line 2912
;2912:			itm->text.flags |= VAL_TEXT;
ADDRLP4 12
ADDRFP4 0
INDIRP4
CNSTI4 1204
ADDP4
ASGNP4
ADDRLP4 12
INDIRP4
ADDRLP4 12
INDIRP4
INDIRU4
CNSTU4 1
BORU4
ASGNU4
line 2913
;2913:		}
LABELV $1798
line 2914
;2914:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1795
JUMPV
LABELV $1796
line 2916
;2915:	}
;2916:	else {
line 2917
;2917:		Com_Printf("Error HUD item %s, can't parse property 'caption': %s", itm->item_name, s);
ADDRGP4 $1800
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 2918
;2918:		return qfalse;
CNSTI4 0
RETI4
LABELV $1795
endproc prop_caption 16 12
export items_KeywordHash_Add
proc items_KeywordHash_Add 8 4
line 2928
;2919:	}
;2920:}
;2921:
;2922:
;2923:/*
;2924:===============
;2925:Hud items list hash
;2926:===============
;2927:*/
;2928:void items_KeywordHash_Add(items_keywordHash_t *table[], items_keywordHash_t *key) {
line 2931
;2929:	int hash;
;2930:
;2931:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2932
;2932:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2933
;2933:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2934
;2934:}
LABELV $1801
endproc items_KeywordHash_Add 8 4
export items_KeywordHash_Find
proc items_KeywordHash_Find 16 8
line 2937
;2935:
;2936:items_keywordHash_t *items_KeywordHash_Find(items_keywordHash_t *table[], char *keyword)
;2937:{
line 2941
;2938:	items_keywordHash_t *key;
;2939:	int hash;
;2940:
;2941:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2942
;2942:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1806
JUMPV
LABELV $1803
line 2943
;2943:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1807
line 2944
;2944:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1802
JUMPV
LABELV $1807
line 2945
;2945:	}
LABELV $1804
line 2942
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1806
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1803
line 2946
;2946:	return NULL;
CNSTP4 0
RETP4
LABELV $1802
endproc items_KeywordHash_Find 16 8
export items_SetupKeywordHash
proc items_SetupKeywordHash 4 12
line 2951
;2947:}
;2948:
;2949:items_keywordHash_t *items_KeywordHash[KEYWORDHASH_SIZE];
;2950:
;2951:void items_SetupKeywordHash(void) {
line 2953
;2952:	int i;
;2953:	memset(items_KeywordHash, 0, sizeof(items_KeywordHash));
ADDRGP4 items_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2954
;2954:	for (i = 0; item_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1813
JUMPV
LABELV $1810
line 2955
;2955:		items_KeywordHash_Add(items_KeywordHash, &item_Keywords[i]);
ADDRGP4 items_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 item_Keywords
ADDP4
ARGP4
ADDRGP4 items_KeywordHash_Add
CALLV
pop
line 2956
;2956:	}
LABELV $1811
line 2954
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1813
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 item_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1810
line 2957
;2957:}
LABELV $1809
endproc items_SetupKeywordHash 4 12
data
export specifics_item_Keywords
align 4
LABELV specifics_item_Keywords
address $1814
byte 4 0
address $1815
byte 4 0
address $1348
byte 4 0
address $1349
byte 4 0
address $1350
byte 4 0
address $1351
byte 4 0
address $1816
byte 4 0
byte 4 0
byte 4 0
export specifics_items_KeywordHash_Add
code
proc specifics_items_KeywordHash_Add 8 4
line 2977
;2958:
;2959:/*
;2960:===============
;2961:specifics items list hash
;2962:===============
;2963:*/
;2964:specifics_keywordHash_t specifics_item_Keywords[] = {
;2965:	{"INFO",			NULL},
;2966:	{"SetCvar",			NULL},
;2967:	{"HealthColors",	NULL},
;2968:	{"ArmorColors",		NULL},
;2969:	{"AmmoColors",		NULL},
;2970:	{"TeamsColors",		NULL},
;2971:	{"GameTypeIcons",	NULL},
;2972:	//{"WeaponIcons",	NULL},//TODO
;2973:	//{"AmmoIcons",		NULL},//TODO
;2974:	{NULL,				NULL}
;2975:};
;2976:
;2977:void specifics_items_KeywordHash_Add(specifics_keywordHash_t *table[], specifics_keywordHash_t *key) {
line 2980
;2978:	int hash;
;2979:
;2980:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 2981
;2981:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2982
;2982:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 2983
;2983:}
LABELV $1817
endproc specifics_items_KeywordHash_Add 8 4
export specifics_items_KeywordHash_Find
proc specifics_items_KeywordHash_Find 16 8
line 2986
;2984:
;2985:specifics_keywordHash_t *specifics_items_KeywordHash_Find(specifics_keywordHash_t *table[], char *keyword)
;2986:{
line 2990
;2987:	specifics_keywordHash_t *key;
;2988:	int hash;
;2989:
;2990:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2991
;2991:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1822
JUMPV
LABELV $1819
line 2992
;2992:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1823
line 2993
;2993:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1818
JUMPV
LABELV $1823
line 2994
;2994:	}
LABELV $1820
line 2991
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ASGNP4
LABELV $1822
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1819
line 2995
;2995:	return NULL;
CNSTP4 0
RETP4
LABELV $1818
endproc specifics_items_KeywordHash_Find 16 8
export specifics_items_SetupKeywordHash
proc specifics_items_SetupKeywordHash 4 12
line 3000
;2996:}
;2997:
;2998:specifics_keywordHash_t *specifics_KeywordHash[KEYWORDHASH_SIZE];
;2999:
;3000:void specifics_items_SetupKeywordHash(void) {
line 3002
;3001:	int i;
;3002:	memset(specifics_KeywordHash, 0, sizeof(specifics_KeywordHash));
ADDRGP4 specifics_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3003
;3003:	for (i = 0; specifics_item_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1829
JUMPV
LABELV $1826
line 3004
;3004:		specifics_items_KeywordHash_Add(specifics_KeywordHash, &specifics_item_Keywords[i]);
ADDRGP4 specifics_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 3
LSHI4
ADDRGP4 specifics_item_Keywords
ADDP4
ARGP4
ADDRGP4 specifics_items_KeywordHash_Add
CALLV
pop
line 3005
;3005:	}
LABELV $1827
line 3003
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1829
ADDRLP4 0
INDIRI4
CNSTI4 3
LSHI4
ADDRGP4 specifics_item_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1826
line 3006
;3006:}
LABELV $1825
endproc specifics_items_SetupKeywordHash 4 12
data
export dyn_item_Keywords
align 4
LABELV dyn_item_Keywords
address $1830
address IcoWeapList_idx
byte 4 0
address $1831
address IcoWeapListSel_idx
byte 4 0
address $1832
address WeapListSelName_idx
byte 4 0
address $1833
address KillMsg_idx
byte 4 0
address $1834
address ItemMsg_idx
byte 4 0
address $1835
address WarmFightMsg_idx
byte 4 0
address $1836
address ServerMsg_idx
byte 4 0
address $1837
address IcoPowerUp_idx
byte 4 0
address $1838
address TeamOverlay_Sel_idx
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export dyn_items_KeywordHash_Add
code
proc dyn_items_KeywordHash_Add 8 4
line 3041
;3007:
;3008:/*
;3009:===============
;3010:Dynamics items list hash
;3011:===============
;3012:*/
;3013:item_t dyn_itemArray[MAX_HUD_ITEM];
;3014:int dyn_itemCount;
;3015:
;3016:int IcoWeapList_idx;
;3017:int IcoWeapListSel_idx;
;3018:int WeapListSelName_idx;
;3019:int IcoPowerUp_idx;
;3020:int WarmFightMsg_idx;
;3021:int KillMsg_idx;
;3022:int ItemMsg_idx;
;3023:int ServerMsg_idx;
;3024:int TeamOverlay_Sel_idx;
;3025:
;3026:dyn_items_keywordHash_t dyn_item_Keywords[] = {
;3027:	{"Icon_WeaponList",				&IcoWeapList_idx,		NULL},
;3028:	{"Icon_WeaponList_Selected",	&IcoWeapListSel_idx,	NULL},
;3029:	{"WeaponList_SelectedName",		&WeapListSelName_idx,	NULL},
;3030:	{"KillMessage",					&KillMsg_idx,			NULL},
;3031:	{"ItemMessage",					&ItemMsg_idx,			NULL},
;3032:	{"WarmupFightMessage",			&WarmFightMsg_idx,		NULL},
;3033:	{"ServerMessage",				&ServerMsg_idx,			NULL},
;3034:	{"Icon_PowerUp",				&IcoPowerUp_idx,		NULL},
;3035:	{"TeamOverlay_Selected",		&TeamOverlay_Sel_idx,	NULL},
;3036:	{NULL,							NULL,					NULL}
;3037:};
;3038:
;3039:dyn_items_keywordHash_t *dyn_KeywordHash[KEYWORDHASH_SIZE];
;3040:
;3041:void dyn_items_KeywordHash_Add(dyn_items_keywordHash_t *table[], dyn_items_keywordHash_t *key) {
line 3044
;3042:	int hash;
;3043:
;3044:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 3045
;3045:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 3046
;3046:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 3047
;3047:}
LABELV $1839
endproc dyn_items_KeywordHash_Add 8 4
export dyn_items_SetupKeywordHash
proc dyn_items_SetupKeywordHash 4 12
line 3049
;3048:
;3049:void dyn_items_SetupKeywordHash(void) {
line 3051
;3050:	int i;
;3051:	memset(dyn_KeywordHash, 0, sizeof(dyn_KeywordHash));
ADDRGP4 dyn_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3052
;3052:	for (i = 0; dyn_item_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1844
JUMPV
LABELV $1841
line 3053
;3053:		dyn_items_KeywordHash_Add(dyn_KeywordHash, &dyn_item_Keywords[i]);
ADDRGP4 dyn_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 dyn_item_Keywords
ADDP4
ARGP4
ADDRGP4 dyn_items_KeywordHash_Add
CALLV
pop
line 3054
;3054:	}
LABELV $1842
line 3052
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1844
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 dyn_item_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1841
line 3055
;3055:}
LABELV $1840
endproc dyn_items_SetupKeywordHash 4 12
export dyn_items_KeywordHash_Find
proc dyn_items_KeywordHash_Find 16 8
line 3058
;3056:
;3057:dyn_items_keywordHash_t *dyn_items_KeywordHash_Find(dyn_items_keywordHash_t *table[], char *keyword)
;3058:{
line 3062
;3059:	dyn_items_keywordHash_t *key;
;3060:	int hash;
;3061:
;3062:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 3063
;3063:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1849
JUMPV
LABELV $1846
line 3064
;3064:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1850
line 3065
;3065:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1845
JUMPV
LABELV $1850
line 3066
;3066:	}
LABELV $1847
line 3063
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1849
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1846
line 3067
;3067:	return NULL;
CNSTP4 0
RETP4
LABELV $1845
endproc dyn_items_KeywordHash_Find 16 8
export prop_KeywordHash_Add
proc prop_KeywordHash_Add 8 4
line 3084
;3068:}
;3069:
;3070:
;3071:/*
;3072:===============
;3073:properties list hash
;3074:===============
;3075:*/
;3076:typedef struct prop_keywordHash_s
;3077:{
;3078:	char *keyword;
;3079:	qboolean(*ownerDraw)(item_t *itm, int handle);
;3080:	struct prop_keywordHash_s *next;
;3081:} prop_keywordHash_t;
;3082:
;3083:
;3084:void prop_KeywordHash_Add(prop_keywordHash_t *table[], prop_keywordHash_t *key) {
line 3087
;3085:	int hash;
;3086:
;3087:	hash = KeywordHash_Key(key->keyword);
ADDRFP4 4
INDIRP4
INDIRP4
ARGP4
ADDRLP4 4
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRI4
ASGNI4
line 3088
;3088:	key->next = table[hash];
ADDRFP4 4
INDIRP4
CNSTI4 8
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 3089
;3089:	table[hash] = key;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 4
INDIRP4
ASGNP4
line 3090
;3090:}
LABELV $1852
endproc prop_KeywordHash_Add 8 4
export prop_KeywordHash_Find
proc prop_KeywordHash_Find 16 8
line 3093
;3091:
;3092:prop_keywordHash_t *prop_KeywordHash_Find(prop_keywordHash_t *table[], char *keyword)
;3093:{
line 3097
;3094:	prop_keywordHash_t *key;
;3095:	int hash;
;3096:
;3097:	hash = KeywordHash_Key(keyword);
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 KeywordHash_Key
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 3098
;3098:	for (key = table[hash]; key; key = key->next) {
ADDRLP4 0
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $1857
JUMPV
LABELV $1854
line 3099
;3099:		if (!Q_stricmp(key->keyword, keyword))
ADDRLP4 0
INDIRP4
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $1858
line 3100
;3100:			return key;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $1853
JUMPV
LABELV $1858
line 3101
;3101:	}
LABELV $1855
line 3098
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRP4
ASGNP4
LABELV $1857
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1854
line 3102
;3102:	return NULL;
CNSTP4 0
RETP4
LABELV $1853
endproc prop_KeywordHash_Find 16 8
data
export itemProperty_Keywords
align 4
LABELV itemProperty_Keywords
address $1860
address prop_name
byte 4 0
address $1861
address prop_rect
byte 4 0
address $1862
address prop_background
byte 4 0
address $1863
address prop_icon3D
byte 4 0
address $1864
address prop_cvarTest
byte 4 0
address $1865
address prop_verticalbar
byte 4 0
address $1866
address prop_textalign
byte 4 0
address $1867
address prop_Size
byte 4 0
address $1868
address prop_font
byte 4 0
address $1869
address prop_param
byte 4 0
address $1870
address prop_forecolor
byte 4 0
address $1871
address prop_backcolor
byte 4 0
address $1872
address prop_anchors
byte 4 0
address $1873
address prop_fill
byte 4 0
address $1874
address prop_BlinkWhenLow
byte 4 0
address $1875
address prop_time
byte 4 0
address $1876
address prop_visible
byte 4 0
address $1877
address prop_pulseScale
byte 4 0
address $1878
address prop_proportional
byte 4 0
address $1879
address prop_shadow
byte 4 0
address $1880
address prop_margin
byte 4 0
address $1881
address prop_valign
byte 4 0
address $1882
address prop_parent
byte 4 0
address $1883
address prop_gradient
byte 4 0
address $1884
address prop_caption
byte 4 0
address $1885
address prop_TeamPlayer
byte 4 0
byte 4 0
byte 4 0
byte 4 0
export prop_SetupKeywordHash
code
proc prop_SetupKeywordHash 4 12
line 3210
;3103:}
;3104:
;3105:// CPMA compatibility
;3106:/*static qboolean prop_textstyle(item_t *itm, int handle) {
;3107:	int res;
;3108:	if (!PC_Int_Parse(handle, &res)) {
;3109:		return qfalse;
;3110:	}
;3111:	if (res == 1) {
;3112:		itm->text.styleflags |= DS_SHADOW;
;3113:	}
;3114:	//what other textstyle value do?
;3115:	return qtrue;
;3116:}
;3117:// do nothing, it's for CPMA compatibility
;3118:static qboolean prop_textoffset(item_t *itm, int handle) {
;3119:	int res;
;3120:	if (!PC_Int_Parse(handle, &res)) {
;3121:		return qfalse;
;3122:	}
;3123:	else {
;3124:		if (!PC_Int_Parse(handle, &res)) {
;3125:			return qfalse;
;3126:		}
;3127:	}
;3128:	return qtrue;
;3129:}
;3130:
;3131:// do nothing, it's for CPMA compatibility
;3132:static qboolean imagetc_Parse(int handle, margin_t *m) {
;3133:	int paramNb = 0;
;3134:	float res;
;3135:	if (PC_Float_Parse(handle, &res)) {
;3136:		paramNb++;
;3137:		if (PC_Float_Parse(handle, &res)) {
;3138:			paramNb++;
;3139:			if (PC_Float_Parse(handle, &res)) {
;3140:				paramNb++;
;3141:				if (PC_Float_Parse(handle, &res)) {
;3142:					paramNb++;
;3143:					return qtrue;
;3144:				}
;3145:			}
;3146:		}
;3147:	}
;3148:	return (paramNb > 0);
;3149:}
;3150:// do nothing, it's for CPMA compatibility
;3151:static qboolean prop_imagetc(item_t *itm, int handle) {
;3152:	if (!imagetc_Parse(handle, &itm->margin)) {
;3153:		return qfalse;
;3154:	}
;3155:	return qtrue;
;3156:}*/
;3157:
;3158:prop_keywordHash_t itemProperty_Keywords[] = {
;3159:	{"name",		prop_name,			NULL},
;3160:	{"rect",		prop_rect,			NULL},
;3161:	{"background",	prop_background,	NULL},
;3162:	{"icon3D",		prop_icon3D,		NULL},
;3163:	{"cvarTest",	prop_cvarTest,		NULL},
;3164:	{"verticalbar", prop_verticalbar,	NULL},
;3165:	{"textalign",	prop_textalign,		NULL},
;3166:	{"fontsize",	prop_Size,			NULL},
;3167:	{"font",		prop_font,			NULL},
;3168:	{"param",		prop_param,			NULL},
;3169:	{"forecolor",	prop_forecolor,		NULL},
;3170:	{"backcolor",	prop_backcolor,		NULL},
;3171:	{"anchors",		prop_anchors,		NULL},
;3172:	{"fill",		prop_fill,			NULL},
;3173:	{"blink",		prop_BlinkWhenLow,	NULL},
;3174:	{"time",		prop_time,			NULL},
;3175:	{"visible",		prop_visible,		NULL},
;3176:	{"pulseScale",	prop_pulseScale,	NULL},
;3177:	{"proportional",prop_proportional,	NULL},
;3178:	{"shadow",		prop_shadow,		NULL},
;3179:	{"margin",		prop_margin,		NULL},
;3180:	{"valign",		prop_valign,		NULL},
;3181:	{"parent",		prop_parent,		NULL},
;3182:	{"gradient",	prop_gradient,		NULL},
;3183:	{"caption",		prop_caption,		NULL},
;3184:	{"team_player",	prop_TeamPlayer,	NULL},
;3185:	/*
;3186:	// CPMA compatibility
;3187:	{"color",		prop_forecolor,		NULL},
;3188:	{"bgcolor",		prop_backcolor,		NULL},
;3189:	{"image",		prop_background,	NULL},
;3190:	{"textstyle",	prop_textstyle,		NULL}, // do nothing
;3191:	{"visflags",	prop_textstyle,		NULL}, // do nothing
;3192:	{"alignh",		prop_textalign,		NULL},
;3193:	{"text",		prop_caption,		NULL},
;3194:	{"textoffset",	prop_textoffset,	NULL},	// do nothing
;3195:	{"imagetc",		prop_imagetc,		NULL},	// do nothing
;3196:	{"monospace",	prop_proportional,	NULL},
;3197:	*/
;3198:
;3199:	/*
;3200:	// only usefull in UIGAME
;3201:	{"name",		prop_HUDname,			NULL},	// name of the HUD file
;3202:	{"author",		prop_HUDauthor,		NULL},	// author of the HUD file
;3203:	{"description",	prop_HUDdescription,	NULL},	// HUD short description
;3204:	*/
;3205:	{NULL,			0,					NULL}
;3206:};
;3207:
;3208:prop_keywordHash_t *prop_KeywordHash[KEYWORDHASH_SIZE];
;3209:
;3210:void prop_SetupKeywordHash(void) {
line 3213
;3211:	int i;
;3212:
;3213:	memset(prop_KeywordHash, 0, sizeof(prop_KeywordHash));
ADDRGP4 prop_KeywordHash
ARGP4
CNSTI4 0
ARGI4
CNSTI4 2048
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3214
;3214:	for (i = 0; itemProperty_Keywords[i].keyword; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1890
JUMPV
LABELV $1887
line 3215
;3215:		prop_KeywordHash_Add(prop_KeywordHash, &itemProperty_Keywords[i]);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 itemProperty_Keywords
ADDP4
ARGP4
ADDRGP4 prop_KeywordHash_Add
CALLV
pop
line 3216
;3216:	}
LABELV $1888
line 3214
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1890
ADDRLP4 0
INDIRI4
CNSTI4 12
MULI4
ADDRGP4 itemProperty_Keywords
ADDP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1887
line 3217
;3217:}
LABELV $1886
endproc prop_SetupKeywordHash 4 12
export itemProperties_Parse
proc itemProperties_Parse 1056 12
line 3225
;3218:
;3219:/*
;3220:=================
;3221:itemProperties_Parse
;3222:parse properties (rect, image, ...) of each item
;3223:=================
;3224:*/
;3225:qboolean itemProperties_Parse(item_t *itm, int handle) {
line 3229
;3226:	pc_token_t token;
;3227:	prop_keywordHash_t *key;
;3228:
;3229:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1892
line 3230
;3230:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1891
JUMPV
LABELV $1892
line 3233
;3231:	}
;3232:
;3233:	if (*token.string != '{') {
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $1898
line 3234
;3234:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1891
JUMPV
LABELV $1897
line 3237
;3235:	}
;3236:
;3237:	while (1) {
line 3239
;3238:		// we can't unread token, so we check last token on parse error
;3239:		if (itemEnd) {
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $1900
line 3240
;3240:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3241
;3241:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1891
JUMPV
LABELV $1900
line 3244
;3242:		}
;3243:
;3244:		if (propertyEnd) {
ADDRGP4 propertyEnd
INDIRI4
CNSTI4 0
EQI4 $1902
line 3245
;3245:			key = prop_KeywordHash_Find(prop_KeywordHash, token.string);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRLP4 4+16
ARGP4
ADDRLP4 1048
ADDRGP4 prop_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 1048
INDIRP4
ASGNP4
line 3246
;3246:			propertyEnd = qfalse;
ADDRGP4 propertyEnd
CNSTI4 0
ASGNI4
line 3247
;3247:		}	
ADDRGP4 $1903
JUMPV
LABELV $1902
line 3248
;3248:		else if (needCacheToken) {
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1905
line 3249
;3249:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1048
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 59
EQI4 $1909
ADDRLP4 1048
INDIRI4
CNSTI4 44
NEI4 $1907
LABELV $1909
line 3250
;3250:				resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3251
;3251:				continue;
ADDRGP4 $1898
JUMPV
LABELV $1907
line 3253
;3252:			}
;3253:			key = prop_KeywordHash_Find(prop_KeywordHash, cacheTokenStr);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1052
ADDRGP4 prop_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 1052
INDIRP4
ASGNP4
line 3255
;3254:			//resetTokenCache();
;3255:		}
ADDRGP4 $1906
JUMPV
LABELV $1905
line 3256
;3256:		else {
line 3257
;3257:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3259
;3258:
;3259:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1910
line 3260
;3260:				PC_SourceError(handle, "end of file inside property");
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1912
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3261
;3261:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1891
JUMPV
LABELV $1910
line 3263
;3262:			}
;3263:			else if (*token.string == '}') {
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1913
line 3264
;3264:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1891
JUMPV
LABELV $1913
line 3266
;3265:			}
;3266:			else if (*token.string == ';' || *token.string == ',') {
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $1920
ADDRLP4 4+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1916
LABELV $1920
line 3267
;3267:				continue;
ADDRGP4 $1898
JUMPV
LABELV $1916
line 3270
;3268:			}
;3269:
;3270:			key = prop_KeywordHash_Find(prop_KeywordHash, token.string);
ADDRGP4 prop_KeywordHash
ARGP4
ADDRLP4 4+16
ARGP4
ADDRLP4 1052
ADDRGP4 prop_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 1052
INDIRP4
ASGNP4
line 3271
;3271:		}
LABELV $1906
LABELV $1903
line 3273
;3272:
;3273:		if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1922
line 3274
;3274:			PC_SourceError(handle, "unknown property keyword %s", token.string);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1924
ARGP4
ADDRLP4 4+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3275
;3275:			continue;
ADDRGP4 $1898
JUMPV
LABELV $1922
line 3278
;3276:		}
;3277:
;3278:		resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3280
;3279:
;3280:		if (!key->ownerDraw((item_t *)itm, handle)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 1048
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1926
line 3281
;3281:			PC_SourceError(handle, "couldn't parse property keyword %s", token.string);
ADDRFP4 4
INDIRI4
ARGI4
ADDRGP4 $1928
ARGP4
ADDRLP4 4+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3282
;3282:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1891
JUMPV
LABELV $1926
line 3284
;3283:		}
;3284:	}
LABELV $1898
line 3237
ADDRGP4 $1897
JUMPV
line 3285
;3285:	return qfalse;
CNSTI4 0
RETI4
LABELV $1891
endproc itemProperties_Parse 1056 12
proc skipItem 1044 8
line 3289
;3286:}
;3287:
;3288:// read until end of item
;3289:static qboolean skipItem(int handle) {
ADDRGP4 $1932
JUMPV
LABELV $1931
line 3291
;3290:	pc_token_t token;
;3291:	while (*token.string != '}') {
line 3292
;3292:		if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1040
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1040
INDIRI4
CNSTI4 0
NEI4 $1935
line 3293
;3293:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1930
JUMPV
LABELV $1935
line 3295
;3294:		}
;3295:	}
LABELV $1932
line 3291
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1931
line 3296
;3296:	return qtrue;
CNSTI4 1
RETI4
LABELV $1930
endproc skipItem 1044 8
export cvar_update
proc cvar_update 8 8
line 3299
;3297:}
;3298:
;3299:qboolean cvar_update(int handle, vmCvar_t *cvar) {
line 3301
;3300:	int val;
;3301:	if (!PC_Int_Parse(handle, &val)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_Int_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $1938
line 3302
;3302:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1937
JUMPV
LABELV $1938
line 3304
;3303:	}
;3304:	cvar->integer = val;
ADDRFP4 4
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 0
INDIRI4
ASGNI4
line 3305
;3305:	return qtrue;
CNSTI4 1
RETI4
LABELV $1937
endproc cvar_update 8 8
proc script_Parse 1056 12
line 3309
;3306:}
;3307:
;3308:// Parse cvar_t and change cvar_t state
;3309:static qboolean script_Parse(int handle ) {
line 3313
;3310:	pc_token_t token;
;3311:	cvarTest_keywordHash_t *key;
;3312:
;3313:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1044
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1044
INDIRI4
CNSTI4 0
NEI4 $1941
line 3314
;3314:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1940
JUMPV
LABELV $1941
line 3317
;3315:	}
;3316:
;3317:	if (*token.string != '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $1947
line 3318
;3318:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1940
JUMPV
LABELV $1946
line 3321
;3319:	}
;3320:
;3321:	while (1) {
line 3323
;3322:		// we can't unread token, so we check last token on parse error
;3323:		if (itemEnd)
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $1949
line 3324
;3324:		{
line 3325
;3325:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3326
;3326:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1940
JUMPV
LABELV $1949
line 3329
;3327:		}
;3328:
;3329:		if (needCacheToken)
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1951
line 3330
;3330:		{
line 3331
;3331:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1048
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 59
EQI4 $1955
ADDRLP4 1048
INDIRI4
CNSTI4 44
NEI4 $1953
LABELV $1955
line 3332
;3332:				continue;
ADDRGP4 $1947
JUMPV
LABELV $1953
line 3334
;3333:			}
;3334:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, cacheTokenStr);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1052
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1040
ADDRLP4 1052
INDIRP4
ASGNP4
line 3335
;3335:			resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3336
;3336:		}
ADDRGP4 $1952
JUMPV
LABELV $1951
line 3338
;3337:		else
;3338:		{
line 3339
;3339:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3341
;3340:
;3341:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1956
line 3342
;3342:				PC_SourceError(handle, "end of file inside script");
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1958
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3343
;3343:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1940
JUMPV
LABELV $1956
line 3346
;3344:			}
;3345:
;3346:			if (*token.string == '}') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1959
line 3347
;3347:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1940
JUMPV
LABELV $1959
line 3349
;3348:			}
;3349:			if (*token.string == ';' || *token.string == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $1966
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1962
LABELV $1966
line 3350
;3350:				continue;
ADDRGP4 $1947
JUMPV
LABELV $1962
line 3352
;3351:			}
;3352:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, token.string);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1052
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1040
ADDRLP4 1052
INDIRP4
ASGNP4
line 3353
;3353:		}
LABELV $1952
line 3355
;3354:
;3355:		if (!key) {
ADDRLP4 1040
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $1968
line 3356
;3356:			PC_SourceError(handle, "unknown script keyword %s", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1970
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3357
;3357:			continue;
ADDRGP4 $1947
JUMPV
LABELV $1968
line 3360
;3358:		}
;3359:
;3360:		if (!cvar_update(handle, key->cvar)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 1040
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ARGP4
ADDRLP4 1048
ADDRGP4 cvar_update
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1972
line 3361
;3361:			PC_SourceError(handle, "couldn't parse script keyword %s", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1974
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3362
;3362:			return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1940
JUMPV
LABELV $1972
line 3364
;3363:		}
;3364:	}
LABELV $1947
line 3321
ADDRGP4 $1946
JUMPV
line 3365
;3365:	return qfalse;
CNSTI4 0
RETI4
LABELV $1940
endproc script_Parse 1056 12
export parseColorItem
proc parseColorItem 1064 12
line 3369
;3366:}
;3367:
;3368:
;3369:qboolean parseColorItem(int handle, float array_colors[4][4]) {
line 3374
;3370:	pc_token_t token;
;3371:	cvarTest_keywordHash_t *key;
;3372:	int colorIdx;
;3373:
;3374:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $1977
line 3375
;3375:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1976
JUMPV
LABELV $1977
line 3378
;3376:	}
;3377:
;3378:	if (*token.string != '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $1979
line 3379
;3379:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1976
JUMPV
LABELV $1979
line 3382
;3380:	}
;3381:
;3382:	colorIdx = 0;
ADDRLP4 1040
CNSTI4 0
ASGNI4
ADDRGP4 $1983
JUMPV
LABELV $1982
line 3384
;3383:
;3384:	while (1) {
line 3386
;3385:		// we can't unread token, so we check last token on parse error
;3386:		if (itemEnd)
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $1985
line 3387
;3387:		{
line 3388
;3388:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3389
;3389:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1976
JUMPV
LABELV $1985
line 3392
;3390:		}
;3391:
;3392:		if (needCacheToken)
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $1987
line 3393
;3393:		{
line 3394
;3394:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1052
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 59
EQI4 $1991
ADDRLP4 1052
INDIRI4
CNSTI4 44
NEI4 $1989
LABELV $1991
line 3395
;3395:				continue;
ADDRGP4 $1983
JUMPV
LABELV $1989
line 3397
;3396:			}
;3397:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, cacheTokenStr);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1056
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1044
ADDRLP4 1056
INDIRP4
ASGNP4
line 3398
;3398:			resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3399
;3399:		}
ADDRGP4 $1988
JUMPV
LABELV $1987
line 3401
;3400:		else
;3401:		{
line 3402
;3402:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3404
;3403:
;3404:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1052
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
NEI4 $1992
line 3405
;3405:				PC_SourceError(handle, "end of file inside hud file");
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1994
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3406
;3406:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1976
JUMPV
LABELV $1992
line 3409
;3407:			}
;3408:
;3409:			if (*token.string == '}') { // exit the loop
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $1995
line 3410
;3410:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $1976
JUMPV
LABELV $1995
line 3413
;3411:			}
;3412:
;3413:			if (*token.string == ';' || *token.string == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $2002
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $1998
LABELV $2002
line 3414
;3414:				continue;
ADDRGP4 $1983
JUMPV
LABELV $1998
line 3417
;3415:			}
;3416:
;3417:			if (strcmp("color", token.string) == 0) {
ADDRGP4 $2005
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1056
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
NEI4 $2003
line 3418
;3418:				if (!PC_Color_Parse(handle, &array_colors[colorIdx])) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 1040
INDIRI4
CNSTI4 4
LSHI4
ADDRFP4 4
INDIRP4
ADDP4
ARGP4
ADDRLP4 1060
ADDRGP4 PC_Color_Parse
CALLI4
ASGNI4
ADDRLP4 1060
INDIRI4
CNSTI4 0
NEI4 $2007
line 3419
;3419:					Com_Printf("Parse color item error <%s>\n", token.string);
ADDRGP4 $2009
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3420
;3420:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $1976
JUMPV
LABELV $2007
line 3422
;3421:				}
;3422:				colorIdx++;
ADDRLP4 1040
ADDRLP4 1040
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3423
;3423:			}
LABELV $2003
line 3424
;3424:		}
LABELV $1988
line 3425
;3425:	}
LABELV $1983
line 3384
ADDRGP4 $1982
JUMPV
line 3426
;3426:	return qfalse;
CNSTI4 0
RETI4
LABELV $1976
endproc parseColorItem 1064 12
proc parse_one_gameType_icons 12 8
line 3430
;3427:}
;3428:
;3429:
;3430:static qboolean parse_one_gameType_icons(int handle, int GameTypeIdx) {
line 3432
;3431:	const char *s;
;3432:	if (!PC_String_Parse(handle, &s)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 4
ADDRGP4 PC_String_Parse
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
NEI4 $2012
line 3433
;3433:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2011
JUMPV
LABELV $2012
line 3436
;3434:	}
;3435:
;3436:	cgs.media.gameTypeShader[GameTypeIdx] = trap_R_RegisterShaderNoMip(s);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 trap_R_RegisterShaderNoMip
CALLI4
ASGNI4
ADDRFP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+148752+300
ADDP4
ADDRLP4 8
INDIRI4
ASGNI4
line 3437
;3437:	return qtrue;
CNSTI4 1
RETI4
LABELV $2011
endproc parse_one_gameType_icons 12 8
export parse_gameType_icons
proc parse_gameType_icons 1064 12
line 3441
;3438:}
;3439:
;3440:// parse GameTypeIcons
;3441:qboolean parse_gameType_icons(int handle) {
line 3446
;3442:	pc_token_t token;
;3443:	cvarTest_keywordHash_t *key;
;3444:	int GameTypeIdx;
;3445:
;3446:	if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $2017
line 3447
;3447:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2016
JUMPV
LABELV $2017
line 3450
;3448:	}
;3449:
;3450:	if (*token.string != '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
EQI4 $2019
line 3451
;3451:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2016
JUMPV
LABELV $2019
line 3454
;3452:	}
;3453:
;3454:	GameTypeIdx = 0;
ADDRLP4 1040
CNSTI4 0
ASGNI4
ADDRGP4 $2023
JUMPV
LABELV $2022
line 3456
;3455:
;3456:	while (1) {
line 3458
;3457:		// we can't unread token, so we check last token on parse error
;3458:		if (itemEnd)
ADDRGP4 itemEnd
INDIRI4
CNSTI4 0
EQI4 $2025
line 3459
;3459:		{
line 3460
;3460:			itemEnd = qfalse;
ADDRGP4 itemEnd
CNSTI4 0
ASGNI4
line 3461
;3461:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2016
JUMPV
LABELV $2025
line 3464
;3462:		}
;3463:
;3464:		if (needCacheToken)
ADDRGP4 needCacheToken
INDIRI4
CNSTI4 0
EQI4 $2027
line 3465
;3465:		{
line 3466
;3466:			if (*cacheTokenStr == ';' || *cacheTokenStr == ',') {
ADDRLP4 1052
ADDRGP4 cacheTokenStr
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 59
EQI4 $2031
ADDRLP4 1052
INDIRI4
CNSTI4 44
NEI4 $2029
LABELV $2031
line 3467
;3467:				continue;
ADDRGP4 $2023
JUMPV
LABELV $2029
line 3469
;3468:			}
;3469:			key = cvarTest_KeywordHash_Find(cvarTest_KeywordHash, cacheTokenStr);
ADDRGP4 cvarTest_KeywordHash
ARGP4
ADDRGP4 cacheTokenStr
INDIRP4
ARGP4
ADDRLP4 1056
ADDRGP4 cvarTest_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1044
ADDRLP4 1056
INDIRP4
ASGNP4
line 3470
;3470:			resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3471
;3471:		}
ADDRGP4 $2028
JUMPV
LABELV $2027
line 3473
;3472:		else
;3473:		{
line 3474
;3474:			memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3476
;3475:
;3476:			if (!trap_PC_ReadToken(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1052
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
NEI4 $2032
line 3477
;3477:				PC_SourceError(handle, "end of file inside hud file");
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $1994
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3478
;3478:				return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2016
JUMPV
LABELV $2032
line 3481
;3479:			}
;3480:
;3481:			if (*token.string == '}') { // exit the loop
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $2034
line 3482
;3482:				return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2016
JUMPV
LABELV $2034
line 3485
;3483:			}
;3484:
;3485:			if (*token.string == ';' || *token.string == ',') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
EQI4 $2041
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
NEI4 $2037
LABELV $2041
line 3486
;3486:				continue;
ADDRGP4 $2023
JUMPV
LABELV $2037
line 3489
;3487:			}
;3488:
;3489:			if (strcmp("background", token.string) == 0) {
ADDRGP4 $1862
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1056
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
NEI4 $2042
line 3490
;3490:				if (!parse_one_gameType_icons(handle, GameTypeIdx)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 1040
INDIRI4
ARGI4
ADDRLP4 1060
ADDRGP4 parse_one_gameType_icons
CALLI4
ASGNI4
ADDRLP4 1060
INDIRI4
CNSTI4 0
NEI4 $2045
line 3491
;3491:					Com_Printf("GameTypeIcons parse error\n");
ADDRGP4 $2047
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3492
;3492:					return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2016
JUMPV
LABELV $2045
line 3494
;3493:				}
;3494:				GameTypeIdx++;
ADDRLP4 1040
ADDRLP4 1040
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3495
;3495:			}
LABELV $2042
line 3496
;3496:		}
LABELV $2028
line 3497
;3497:	}
LABELV $2023
line 3456
ADDRGP4 $2022
JUMPV
line 3498
;3498:	return qfalse;
CNSTI4 0
RETI4
LABELV $2016
endproc parse_gameType_icons 1064 12
proc parse_specifics 36 12
line 3501
;3499:}
;3500:
;3501:static qboolean parse_specifics(int handle, pc_token_t *token) {
line 3505
;3502:	specifics_keywordHash_t *key;
;3503:
;3504:	// Check if non-HUD part
;3505:	key = specifics_items_KeywordHash_Find(specifics_KeywordHash, token->string);
ADDRGP4 specifics_KeywordHash
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 specifics_items_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 3506
;3506:	if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2049
line 3507
;3507:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2049
line 3510
;3508:	}
;3509:
;3510:	if (strcmp("SetCvar", token->string) == 0) {
ADDRGP4 $1815
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 8
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
NEI4 $2051
line 3511
;3511:		script_Parse(handle);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 script_Parse
CALLI4
pop
line 3512
;3512:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2051
line 3514
;3513:	}
;3514:	else if (strcmp("INFO", token->string) == 0) {
ADDRGP4 $1814
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 12
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $2053
line 3516
;3515:		// 'INFO' properties are only needed in UIGAME 
;3516:		skipItem(handle);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 skipItem
CALLI4
pop
line 3517
;3517:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2053
line 3519
;3518:	}
;3519:	else if (strcmp("HealthColors", token->string) == 0) {
ADDRGP4 $1348
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $2055
line 3520
;3520:		parseColorItem(handle, health_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 health_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3521
;3521:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2055
line 3523
;3522:	}
;3523:	else if (strcmp("ArmorColors", token->string) == 0) {
ADDRGP4 $1349
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $2057
line 3524
;3524:		parseColorItem(handle, armor_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 armor_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3525
;3525:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2057
line 3527
;3526:	}
;3527:	else if (strcmp("AmmoColors", token->string) == 0) {
ADDRGP4 $1350
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 24
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $2059
line 3528
;3528:		parseColorItem(handle, ammo_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 ammo_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3529
;3529:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2059
line 3531
;3530:	}
;3531:	else if (strcmp("TeamsColors", token->string) == 0) {
ADDRGP4 $1351
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 28
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $2061
line 3532
;3532:		parseColorItem(handle, teams_colors);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 teams_colors
ARGP4
ADDRGP4 parseColorItem
CALLI4
pop
line 3533
;3533:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2061
line 3535
;3534:	}
;3535:	else if (strcmp("GameTypeIcons", token->string) == 0) {
ADDRGP4 $1816
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 32
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $2063
line 3536
;3536:		parse_gameType_icons(handle);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 parse_gameType_icons
CALLI4
pop
line 3537
;3537:		return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2048
JUMPV
LABELV $2063
line 3539
;3538:	}
;3539:	else {
line 3540
;3540:		PC_SourceError(handle, "unknown specific_items keyword %s \n", token->string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $2065
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3541
;3541:		return qfalse;
CNSTI4 0
RETI4
LABELV $2048
endproc parse_specifics 36 12
proc parse_dynamics 12 8
line 3547
;3542:	}
;3543:}
;3544:
;3545:static const struct item_t EmptyItem;
;3546:
;3547:static qboolean parse_dynamics(int handle, pc_token_t *token) {
line 3551
;3548:	dyn_items_keywordHash_t *key;
;3549:
;3550:	// Check if non-HUD part
;3551:	key = dyn_items_KeywordHash_Find(dyn_KeywordHash, token->string);
ADDRGP4 dyn_KeywordHash
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 dyn_items_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 3552
;3552:	if (!key) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2067
line 3553
;3553:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2066
JUMPV
LABELV $2067
line 3555
;3554:	}
;3555:	else {
line 3556
;3556:		dyn_itemArray[dyn_itemCount] = EmptyItem;
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ADDRGP4 EmptyItem
INDIRB
ASGNB 1212
line 3559
;3557:
;3558:		// in order to find parent index
;3559:		dyn_itemArray[dyn_itemCount].order = itemCount;
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray+1024
ADDP4
ADDRGP4 itemCount
INDIRI4
ASGNI4
line 3562
;3560:
;3561:		// keep item name (may be overwritten by name property)
;3562:		strcpy(dyn_itemArray[dyn_itemCount].item_name, token->string);
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
CNSTI4 16
ADDP4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 3565
;3563:
;3564:		// associate with index, by using pointer
;3565:		*key->idx = dyn_itemCount;
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ADDRGP4 dyn_itemCount
INDIRI4
ASGNI4
line 3568
;3566:
;3567:		// item matched, parse its properties
;3568:		itemProperties_Parse(&dyn_itemArray[dyn_itemCount], handle);
ADDRGP4 dyn_itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 dyn_itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 itemProperties_Parse
CALLI4
pop
line 3570
;3569:
;3570:		dyn_itemCount++;
ADDRLP4 8
ADDRGP4 dyn_itemCount
ASGNP4
ADDRLP4 8
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3571
;3571:		return qtrue;
CNSTI4 1
RETI4
LABELV $2066
endproc parse_dynamics 12 8
export HUDitems_Parse
proc HUDitems_Parse 1072 12
line 3576
;3572:	}
;3573:}
;3574:
;3575:
;3576:qboolean HUDitems_Parse( int handle ) {
line 3581
;3577:	pc_token_t token;
;3578:	items_keywordHash_t *key;
;3579:
;3580:	// clear the HUD items arrays
;3581:	memset(&itemArray, 0, sizeof(itemArray));
ADDRGP4 itemArray
ARGP4
CNSTI4 0
ARGI4
CNSTI4 310272
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3582
;3582:	memset(&dyn_itemArray, 0, sizeof(dyn_itemArray));
ADDRGP4 dyn_itemArray
ARGP4
CNSTI4 0
ARGI4
CNSTI4 310272
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3583
;3583:	itemCount = dyn_itemCount = 0;
ADDRLP4 1044
CNSTI4 0
ASGNI4
ADDRGP4 dyn_itemCount
ADDRLP4 1044
INDIRI4
ASGNI4
ADDRGP4 itemCount
ADDRLP4 1044
INDIRI4
ASGNI4
ADDRGP4 $2072
JUMPV
LABELV $2071
line 3585
;3584:
;3585:	while (1) {
line 3586
;3586:		memset(&token, 0, sizeof(pc_token_t));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1040
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3588
;3587:
;3588:		if ( !trap_PC_ReadToken( handle, &token ) ) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1048
ADDRGP4 trap_PC_ReadToken
CALLI4
ASGNI4
ADDRLP4 1048
INDIRI4
CNSTI4 0
NEI4 $2074
line 3589
;3589:			if ( *token.string == '#' )
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 35
NEI4 $2076
line 3590
;3590:				return qfalse; // stop on preprocessor error
CNSTI4 0
RETI4
ADDRGP4 $2070
JUMPV
LABELV $2076
line 3592
;3591:			
;3592:			return qtrue; // EOF
CNSTI4 1
RETI4
ADDRGP4 $2070
JUMPV
LABELV $2074
line 3595
;3593:		}
;3594:
;3595:		if (*token.string == '}') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 125
NEI4 $2079
line 3596
;3596:			return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $2070
JUMPV
LABELV $2079
line 3599
;3597:		}
;3598:
;3599:		if (*token.string == '{') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 123
NEI4 $2082
line 3600
;3600:			continue;
ADDRGP4 $2072
JUMPV
LABELV $2082
line 3603
;3601:		}
;3602:		// std separators
;3603:		else if (*token.string == ',' || *token.string == ';') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 44
EQI4 $2089
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 59
NEI4 $2085
LABELV $2089
line 3604
;3604:			continue;
ADDRGP4 $2072
JUMPV
LABELV $2085
line 3607
;3605:		}
;3606:		// CPMA compatibility (not anymore compatible)
;3607:		else if (*token.string == '!') {
ADDRLP4 0+16
INDIRI1
CVII4 1
CNSTI4 33
NEI4 $2090
line 3608
;3608:			continue;
ADDRGP4 $2072
JUMPV
LABELV $2090
line 3611
;3609:		}
;3610:
;3611:		if (parse_specifics(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1052
ADDRGP4 parse_specifics
CALLI4
ASGNI4
ADDRLP4 1052
INDIRI4
CNSTI4 0
EQI4 $2093
line 3612
;3612:			continue;
ADDRGP4 $2072
JUMPV
LABELV $2093
line 3615
;3613:		}
;3614:
;3615:		if (parse_dynamics(handle, &token)) {
ADDRFP4 0
INDIRI4
ARGI4
ADDRLP4 0
ARGP4
ADDRLP4 1056
ADDRGP4 parse_dynamics
CALLI4
ASGNI4
ADDRLP4 1056
INDIRI4
CNSTI4 0
EQI4 $2095
line 3616
;3616:			continue;
ADDRGP4 $2072
JUMPV
LABELV $2095
line 3619
;3617:		}
;3618:
;3619:		key = items_KeywordHash_Find(items_KeywordHash, token.string);
ADDRGP4 items_KeywordHash
ARGP4
ADDRLP4 0+16
ARGP4
ADDRLP4 1060
ADDRGP4 items_KeywordHash_Find
CALLP4
ASGNP4
ADDRLP4 1040
ADDRLP4 1060
INDIRP4
ASGNP4
line 3621
;3620:
;3621:		if ( !key ) {
ADDRLP4 1040
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2098
line 3622
;3622:			PC_SourceError(handle, "unknown HUD keyword item %s \n", token.string);
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 $2100
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 PC_SourceError
CALLV
pop
line 3623
;3623:			continue;
ADDRGP4 $2072
JUMPV
LABELV $2098
line 3625
;3624:		}
;3625:		else {
line 3626
;3626:			itemArray[itemCount] = EmptyItem;
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ADDRGP4 EmptyItem
INDIRB
ASGNB 1212
line 3629
;3627:
;3628:			// in order to find parent index
;3629:			itemArray[itemCount].order = itemCount;
ADDRLP4 1064
ADDRGP4 itemCount
INDIRI4
ASGNI4
ADDRLP4 1064
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray+1024
ADDP4
ADDRLP4 1064
INDIRI4
ASGNI4
line 3632
;3630:
;3631:			// keep item name (may be overwritten by name property)
;3632:			strcpy(itemArray[itemCount].item_name, token.string);
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ARGP4
ADDRLP4 0+16
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 3635
;3633:			
;3634:			// item matched, parse its properties
;3635:			itemProperties_Parse(&itemArray[itemCount], handle);
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray
ADDP4
ARGP4
ADDRFP4 0
INDIRI4
ARGI4
ADDRGP4 itemProperties_Parse
CALLI4
pop
line 3638
;3636:
;3637:			// use pointer to associate specific draw function with item
;3638:			itemArray[itemCount].DrawItem = *key->draw_item;
ADDRGP4 itemCount
INDIRI4
CNSTI4 1212
MULI4
ADDRGP4 itemArray+1208
ADDP4
ADDRLP4 1040
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ASGNP4
line 3640
;3639:
;3640:			itemCount++;
ADDRLP4 1068
ADDRGP4 itemCount
ASGNP4
ADDRLP4 1068
INDIRP4
ADDRLP4 1068
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 3641
;3641:		}
line 3642
;3642:	}
LABELV $2072
line 3585
ADDRGP4 $2071
JUMPV
line 3643
;3643:	return qfalse;
CNSTI4 0
RETI4
LABELV $2070
endproc HUDitems_Parse 1072 12
export HUD_FullParse
proc HUD_FullParse 20 8
line 3647
;3644:}
;3645:
;3646:
;3647:qboolean HUD_FullParse( const char *filePath ) {
line 3651
;3648:	int handle;
;3649:	qboolean res;
;3650:
;3651:	resetTokenCache();
ADDRGP4 resetTokenCache
CALLV
pop
line 3653
;3652:
;3653:	Com_Printf("<%s> loading... \n", filePath);
ADDRGP4 $2106
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3655
;3654:
;3655:	handle = trap_PC_LoadSource( filePath );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 trap_PC_LoadSource
CALLI4
ASGNI4
ADDRLP4 0
ADDRLP4 8
INDIRI4
ASGNI4
line 3657
;3656:
;3657:	if ( !handle ) {
ADDRLP4 0
INDIRI4
CNSTI4 0
NEI4 $2107
line 3658
;3658:		Com_Printf("HUD file not found <%s>\n", filePath);
ADDRGP4 $2109
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 Com_Printf
CALLV
pop
line 3659
;3659:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2105
JUMPV
LABELV $2107
line 3662
;3660:	}
;3661:	
;3662:	res = HUDitems_Parse( handle );
ADDRLP4 0
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 HUDitems_Parse
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 12
INDIRI4
ASGNI4
line 3664
;3663:
;3664:	if (res) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $2110
line 3665
;3665:		loadedHUDfilePath = String_Alloc(filePath);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 String_Alloc
CALLP4
ASGNP4
ADDRGP4 loadedHUDfilePath
ADDRLP4 16
INDIRP4
ASGNP4
line 3666
;3666:	}
LABELV $2110
line 3668
;3667:
;3668:	trap_PC_FreeSource(handle);
ADDRLP4 0
INDIRI4
ARGI4
ADDRGP4 trap_PC_FreeSource
CALLI4
pop
line 3669
;3669:	return res;
ADDRLP4 4
INDIRI4
RETI4
LABELV $2105
endproc HUD_FullParse 20 8
export CG_CheckHUD
proc CG_CheckHUD 1036 12
line 3680
;3670:}
;3671:
;3672:
;3673:/*
;3674:=================
;3675:CG_Load_Selected_HUD()
;3676:read cvar_t 'cg_hudFiles'
;3677:and load HUD
;3678:=================
;3679:*/
;3680:qboolean CG_CheckHUD( void ) {
line 3684
;3681:	char buff[1024];
;3682:	char *hudSet;
;3683:
;3684:	memset(buff, 0, sizeof(buff));
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1024
ARGI4
ADDRGP4 memset
CALLP4
pop
line 3686
;3685:
;3686:	trap_Cvar_VariableStringBuffer("cg_hudFiles", buff, sizeof(buff));
ADDRGP4 $2113
ARGP4
ADDRLP4 0
ARGP4
CNSTI4 1024
ARGI4
ADDRGP4 trap_Cvar_VariableStringBuffer
CALLV
pop
line 3687
;3687:	hudSet = buff;
ADDRLP4 1024
ADDRLP4 0
ASGNP4
line 3688
;3688:	if (hudSet[0] == '\0') {
ADDRLP4 1024
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $2114
line 3689
;3689:		hudSet = DEFAULT_HUD;
ADDRLP4 1024
ADDRGP4 $2116
ASGNP4
line 3690
;3690:	}
LABELV $2114
line 3693
;3691:
;3692:	// don't load anything if same HUD
;3693:	if ( strcmp(loadedHUDfilePath, hudSet) == 0 ) {
ADDRGP4 loadedHUDfilePath
INDIRP4
ARGP4
ADDRLP4 1024
INDIRP4
ARGP4
ADDRLP4 1028
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 1028
INDIRI4
CNSTI4 0
NEI4 $2117
line 3694
;3694:		return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $2112
JUMPV
LABELV $2117
line 3698
;3695:	}
;3696:
;3697:	// load HUD
;3698:	return HUD_FullParse( hudSet );
ADDRLP4 1024
INDIRP4
ARGP4
ADDRLP4 1032
ADDRGP4 HUD_FullParse
CALLI4
ASGNI4
ADDRLP4 1032
INDIRI4
RETI4
LABELV $2112
endproc CG_CheckHUD 1036 12
export String_Init
proc String_Init 4 0
line 3707
;3699:}
;3700:
;3701:
;3702:/*
;3703:=================
;3704:String_Init
;3705:=================
;3706:*/
;3707:void String_Init(void) {
line 3709
;3708:	int i;
;3709:	for (i = 0; i < HASH_TABLE_SIZE; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $2120
line 3710
;3710:		strHandle[i] = NULL;
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 strHandle
ADDP4
CNSTP4 0
ASGNP4
line 3711
;3711:	}
LABELV $2121
line 3709
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2048
LTI4 $2120
line 3712
;3712:	strHandleCount = 0;
ADDRGP4 strHandleCount
CNSTI4 0
ASGNI4
line 3713
;3713:	strPoolIndex = 0;
ADDRGP4 strPoolIndex
CNSTI4 0
ASGNI4
line 3714
;3714:	UI_InitMemory();
ADDRGP4 UI_InitMemory
CALLV
pop
line 3717
;3715:	// done once, but as we want to go fast,
;3716:	// we use keyword hash tables
;3717:	items_SetupKeywordHash();
ADDRGP4 items_SetupKeywordHash
CALLV
pop
line 3718
;3718:	specifics_items_SetupKeywordHash();
ADDRGP4 specifics_items_SetupKeywordHash
CALLV
pop
line 3719
;3719:	dyn_items_SetupKeywordHash();
ADDRGP4 dyn_items_SetupKeywordHash
CALLV
pop
line 3720
;3720:	prop_SetupKeywordHash();
ADDRGP4 prop_SetupKeywordHash
CALLV
pop
line 3721
;3721:	flag_SetupKeywordHash();
ADDRGP4 flag_SetupKeywordHash
CALLV
pop
line 3722
;3722:	cvarTest_SetupKeywordHash();
ADDRGP4 cvarTest_SetupKeywordHash
CALLV
pop
line 3723
;3723:	GT_Vis_SetupKeywordHash();
ADDRGP4 GT_Vis_SetupKeywordHash
CALLV
pop
line 3724
;3724:	value_SetupKeywordHash();
ADDRGP4 value_SetupKeywordHash
CALLV
pop
line 3725
;3725:}
LABELV $2119
endproc String_Init 4 0
data
align 4
LABELV $2125
address $2126
export String_Alloc
code
proc String_Alloc 40 8
line 3733
;3726:
;3727:
;3728:/*
;3729:=================
;3730:String_Alloc
;3731:=================
;3732:*/
;3733:const char *String_Alloc( const char *p ) {
line 3739
;3734:	int len;
;3735:	unsigned hash;
;3736:	stringDef_t *str, *last;
;3737:	static const char *staticNULL = "";
;3738:
;3739:	if (p == NULL) {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2127
line 3740
;3740:		return NULL;
CNSTP4 0
RETP4
ADDRGP4 $2124
JUMPV
LABELV $2127
line 3743
;3741:	}
;3742:
;3743:	if (*p == 0) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $2129
line 3744
;3744:		return staticNULL;
ADDRGP4 $2125
INDIRP4
RETP4
ADDRGP4 $2124
JUMPV
LABELV $2129
line 3747
;3745:	}
;3746:
;3747:	hash = hashForString(p);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 hashForString
CALLU4
ASGNU4
ADDRLP4 8
ADDRLP4 16
INDIRU4
ASGNU4
line 3749
;3748:
;3749:	str = strHandle[hash];
ADDRLP4 0
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 strHandle
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $2132
JUMPV
LABELV $2131
line 3750
;3750:	while (str) {
line 3751
;3751:		if (strcmp(p, str->str) == 0) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strcmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $2134
line 3752
;3752:			return str->str;
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
RETP4
ADDRGP4 $2124
JUMPV
LABELV $2134
line 3754
;3753:		}
;3754:		str = str->next;
ADDRLP4 0
ADDRLP4 0
INDIRP4
INDIRP4
ASGNP4
line 3755
;3755:	}
LABELV $2132
line 3750
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2131
line 3757
;3756:
;3757:	len = strlen(p);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 20
INDIRI4
ASGNI4
line 3758
;3758:	if (len + strPoolIndex + 1 < STRING_POOL_SIZE) {
ADDRLP4 12
INDIRI4
ADDRGP4 strPoolIndex
INDIRI4
ADDI4
CNSTI4 1
ADDI4
CNSTI4 65536
GEI4 $2136
line 3759
;3759:		int ph = strPoolIndex;
ADDRLP4 24
ADDRGP4 strPoolIndex
INDIRI4
ASGNI4
line 3760
;3760:		strcpy(&strPool[strPoolIndex], p);
ADDRGP4 strPoolIndex
INDIRI4
ADDRGP4 strPool
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 3761
;3761:		strPoolIndex += len + 1;
ADDRLP4 28
ADDRGP4 strPoolIndex
ASGNP4
ADDRLP4 28
INDIRP4
ADDRLP4 28
INDIRP4
INDIRI4
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ADDI4
ASGNI4
line 3763
;3762:
;3763:		str = strHandle[hash];
ADDRLP4 0
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 strHandle
ADDP4
INDIRP4
ASGNP4
line 3764
;3764:		last = str;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRGP4 $2139
JUMPV
LABELV $2138
line 3765
;3765:		while (str && str->next) {
line 3766
;3766:			last = str;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
line 3767
;3767:			str = str->next;
ADDRLP4 0
ADDRLP4 0
INDIRP4
INDIRP4
ASGNP4
line 3768
;3768:		}
LABELV $2139
line 3765
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $2141
ADDRLP4 0
INDIRP4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2138
LABELV $2141
line 3770
;3769:
;3770:		str = HUD_Alloc(sizeof(stringDef_t));
CNSTI4 8
ARGI4
ADDRLP4 36
ADDRGP4 HUD_Alloc
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 36
INDIRP4
ASGNP4
line 3771
;3771:		if (!str) {
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $2142
line 3772
;3772:			return NULL;
CNSTP4 0
RETP4
ADDRGP4 $2124
JUMPV
LABELV $2142
line 3774
;3773:		}
;3774:		str->next = NULL;
ADDRLP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 3775
;3775:		str->str = &strPool[ph];
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 24
INDIRI4
ADDRGP4 strPool
ADDP4
ASGNP4
line 3776
;3776:		if (last) {
ADDRLP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $2144
line 3777
;3777:			last->next = str;
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRP4
ASGNP4
line 3778
;3778:		}
ADDRGP4 $2145
JUMPV
LABELV $2144
line 3779
;3779:		else {
line 3780
;3780:			strHandle[hash] = str;
ADDRLP4 8
INDIRU4
CNSTI4 2
LSHU4
ADDRGP4 strHandle
ADDP4
ADDRLP4 0
INDIRP4
ASGNP4
line 3781
;3781:		}
LABELV $2145
line 3782
;3782:		return &strPool[ph];
ADDRLP4 24
INDIRI4
ADDRGP4 strPool
ADDP4
RETP4
ADDRGP4 $2124
JUMPV
LABELV $2136
line 3784
;3783:	}
;3784:	return NULL;
CNSTP4 0
RETP4
LABELV $2124
endproc String_Alloc 40 8
bss
align 4
LABELV EmptyItem
skip 1212
export prop_KeywordHash
align 4
LABELV prop_KeywordHash
skip 2048
export dyn_KeywordHash
align 4
LABELV dyn_KeywordHash
skip 2048
export specifics_KeywordHash
align 4
LABELV specifics_KeywordHash
skip 2048
export items_KeywordHash
align 4
LABELV items_KeywordHash
skip 2048
export GT_Vis_KeywordHash
align 4
LABELV GT_Vis_KeywordHash
skip 2048
export value_KeywordHash
align 4
LABELV value_KeywordHash
skip 2048
export flag_KeywordHash
align 4
LABELV flag_KeywordHash
skip 2048
export cvarTest_KeywordHash
align 4
LABELV cvarTest_KeywordHash
skip 2048
export cacheTokenStr
align 4
LABELV cacheTokenStr
skip 4
export propertyEnd
align 4
LABELV propertyEnd
skip 4
export itemEnd
align 4
LABELV itemEnd
skip 4
export needCacheToken
align 4
LABELV needCacheToken
skip 4
align 4
LABELV strHandle
skip 8192
align 1
LABELV strPool
skip 65536
align 4
LABELV outOfMemory
skip 4
align 4
LABELV allocPoint
skip 4
align 1
LABELV memoryPool
skip 131072
export loadedHUDfilePath
align 4
LABELV loadedHUDfilePath
skip 4
import trap_R_AddLinearLightToScene
import trap_R_AddRefEntityToScene2
import linearLight
import intShaderTime
import CG_NewParticleArea
import initparticles
import CG_ParticleExplosion
import CG_ParticleMisc
import CG_ParticleDust
import CG_ParticleSparks
import CG_ParticleBulletDebris
import CG_ParticleSnowFlurry
import CG_AddParticleShrapnel
import CG_ParticleSmoke
import CG_ParticleSnow
import CG_AddParticles
import CG_ClearParticles
import trap_GetEntityToken
import trap_getCameraInfo
import trap_startCamera
import trap_loadCamera
import trap_SnapVector
import trap_CIN_SetExtents
import trap_CIN_DrawCinematic
import trap_CIN_RunCinematic
import trap_CIN_StopCinematic
import trap_CIN_PlayCinematic
import trap_Key_GetKey
import trap_Key_SetCatcher
import trap_Key_GetCatcher
import trap_Key_IsDown
import trap_R_RegisterFont
import trap_MemoryRemaining
import testPrintFloat
import testPrintInt
import trap_SetUserCmdValue
import trap_GetUserCmd
import trap_GetCurrentCmdNumber
import trap_GetServerCommand
import trap_GetSnapshot
import trap_GetCurrentSnapshotNumber
import trap_GetGameState
import trap_GetGlconfig
import trap_R_inPVS
import trap_R_RemapShader
import trap_R_LerpTag
import trap_R_ModelBounds
import trap_R_DrawStretchPic
import trap_R_SetColor
import trap_R_RenderScene
import trap_R_LightForPoint
import trap_R_AddAdditiveLightToScene
import trap_R_AddLightToScene
import trap_R_AddPolysToScene
import trap_R_AddPolyToScene
import trap_R_AddRefEntityToScene
import trap_R_ClearScene
import trap_R_RegisterShaderNoMip
import trap_R_RegisterShader
import trap_R_RegisterSkin
import trap_R_RegisterModel
import trap_R_LoadWorldMap
import trap_S_StopBackgroundTrack
import trap_S_StartBackgroundTrack
import trap_S_RegisterSound
import trap_S_Respatialize
import trap_S_UpdateEntityPosition
import trap_S_AddRealLoopingSound
import trap_S_AddLoopingSound
import trap_S_ClearLoopingSounds
import trap_S_StartLocalSound
import trap_S_StopLoopingSound
import trap_S_StartSound
import trap_CM_MarkFragments
import trap_CM_TransformedCapsuleTrace
import trap_CM_TransformedBoxTrace
import trap_CM_CapsuleTrace
import trap_CM_BoxTrace
import trap_CM_TransformedPointContents
import trap_CM_PointContents
import trap_CM_TempBoxModel
import trap_CM_InlineModel
import trap_CM_NumInlineModels
import trap_CM_LoadMap
import trap_UpdateScreen
import trap_SendClientCommand
import trap_RemoveCommand
import trap_AddCommand
import trap_RealTime
import trap_SendConsoleCommand
import trap_FS_Seek
import trap_FS_FCloseFile
import trap_FS_Write
import trap_FS_Read
import trap_FS_FOpenFile
import trap_Args
import trap_Argv
import trap_Argc
import trap_Cvar_VariableStringBuffer
import trap_Cvar_Set
import trap_Cvar_Update
import trap_Cvar_Register
import trap_Milliseconds
import trap_Error
import trap_Print
import CG_CheckChangedPredictableEvents
import CG_TransitionPlayerState
import CG_Respawn
import CG_PlayBufferedVoiceChats
import CG_VoiceChatLocal
import CG_LoadVoiceChats
import CG_ShaderStateChanged
import CG_SetConfigValues
import CG_ParseSysteminfo
import CG_ParseServerinfo
import CG_ExecuteNewServerCommands
import CG_InitConsoleCommands
import CG_ConsoleCommand
import CG_ScoreboardClick
import CG_DrawOldTourneyScoreboard
import CG_DrawOldScoreboard
import CG_DrawInformation
import CG_LoadingClient
import CG_LoadingItem
import CG_LoadingString
import CG_ProcessSnapshots
import CG_MakeExplosion
import CG_Bleed
import CG_BigExplode
import CG_GibPlayer
import CG_ScorePlum
import CG_SpawnEffect
import CG_BubbleTrail
import CG_SmokePuff
import CG_AddLocalEntities
import CG_AllocLocalEntity
import CG_InitLocalEntities
import CG_ImpactMark
import CG_AddMarks
import CG_InitMarkPolys
import CG_OutOfAmmoChange
import CG_DrawWeaponSelect_V
import CG_DrawWeaponSelect_H
import CG_AddPlayerWeapon
import CG_AddViewWeapon
import CG_GrappleTrail
import CG_RailTrail
import CG_Bullet
import CG_ShotgunFire
import CG_MissileHitPlayer
import CG_MissileHitWall
import CG_FireWeapon
import CG_RegisterItemVisuals
import CG_RegisterWeapon
import CG_Weapon_f
import CG_PrevWeapon_f
import CG_NextWeapon_f
import CG_PositionRotatedEntityOnTag
import CG_PositionEntityOnTag
import CG_AdjustPositionForMover
import CG_Beam
import CG_AddPacketEntities
import CG_SetEntitySoundPosition
import CG_PainEvent
import CG_EntityEvent
import CG_PlaceString
import CG_CheckEvents
import CG_PlayDroppedEvents
import CG_LoadDeferredPlayers
import CG_PredictPlayerState
import CG_Trace
import CG_PointContents
import CG_BuildSolidList
import CG_CustomSound
import CG_NewClientInfo
import CG_AddRefEntityWithPowerups
import CG_ResetPlayerEntity
import CG_Player
import CG_TrackClientTeamChange
import CG_ForceModelChange
import CG_ShowResponseHead
import CG_Draw3DModel
import CG_Text_Height
import CG_Text_Width
import CG_Text_Paint
import CG_DrawTeamBackground
import CG_DrawFlagModel
import CG_DrawActive
import CG_DrawHead
import CG_CenterPrint
import CG_AddLagometerSnapshotInfo
import CG_AddLagometerFrameInfo
import teamChat2
import teamChat1
import systemChat
import drawTeamOverlayModificationCount
import numSortedTeamPlayers
import sortedTeamPlayers
import CG_SelectFont
import CG_LoadFonts
import CG_DrawString
import CG_DrawTopBottom
import CG_DrawSides
import CG_DrawRect
import UI_DrawProportionalString
import CG_GetColorForHealth
import CG_ColorForHealth
import CG_TileClear
import CG_TeamColor
import CG_FadeColorTime
import CG_FadeColor
import CG_DrawStrlen
import CG_DrawStringExt
import CG_DrawGradientPic
import CG_DrawPic
import CG_FillScreen
import CG_FillRect
import CG_AdjustFrom640
import CG_DrawActiveFrame
import CG_AddBufferedSound
import CG_ZoomUp_f
import CG_ZoomDown_f
import CG_TestModelPrevSkin_f
import CG_TestModelNextSkin_f
import CG_TestModelPrevFrame_f
import CG_TestModelNextFrame_f
import CG_TestGun_f
import CG_TestModel_f
import CG_SetScoreCatcher
import CG_BuildSpectatorString
import CG_SetScoreSelection
import CG_RankRunFrame
import CG_EventHandling
import CG_MouseEvent
import CG_KeyEvent
import CG_LoadMenus
import CG_LastAttacker
import CG_CrosshairPlayer
import CG_UpdateCvars
import CG_StartMusic
import CG_Error
import CG_Printf
import CG_Argv
import CG_ConfigString
import eventnames
import cg_followKiller
import cg_fovAdjust
import cg_deadBodyDarken
import cg_teamColors
import cg_teamModel
import cg_enemyColors
import cg_enemyModel
import cg_hitSounds
import cg_currentSelectedPlayer
import cg_trueLightning
import cg_oldPlasma
import cg_oldRocket
import cg_oldRail
import cg_noProjectileTrail
import cg_noTaunt
import cg_bigFont
import cg_smallFont
import cg_cameraMode
import cg_timescale
import cg_timescaleFadeSpeed
import cg_timescaleFadeEnd
import cg_cameraOrbitDelay
import cg_cameraOrbit
import cg_smoothClients
import cg_scorePlum
import cg_noVoiceText
import cg_noVoiceChats
import cg_teamChatsOnly
import cg_drawFriend
import cg_deferPlayers
import cg_predictItems
import cg_blood
import cg_paused
import cg_buildScript
import cg_forceModel
import cg_stats
import cg_teamChatHeight
import cg_teamChatTime
import cg_drawSpeed
import cg_drawAttacker
import cg_drawPing
import cg_lagometer
import cg_thirdPerson
import cg_thirdPersonAngle
import cg_thirdPersonRange
import cg_zoomFov
import cg_fov
import cg_simpleItems
import cg_ignore
import cg_autoswitch
import cg_tracerLength
import cg_tracerWidth
import cg_tracerChance
import cg_viewsize
import cg_drawGun
import cg_gun_z
import cg_gun_y
import cg_gun_x
import cg_gun_frame
import cg_brassTime
import cg_addMarks
import cg_footsteps
import cg_showmiss
import cg_noPlayerAnims
import cg_nopredict
import cg_errorDecay
import cg_railTrailRadius
import cg_railTrailTime
import cg_debugEvents
import cg_debugPosition
import cg_debugAnim
import cg_animSpeed
import cg_draw2D
import cg_drawStatus
import cg_crosshairHealth
import cg_crosshairSize
import cg_crosshairY
import cg_crosshairX
import cg_drawWeaponSelect
import cg_teamOverlayUserinfo
import cg_drawTeamOverlay
import cg_drawRewards
import cg_drawCrosshairNames
import cg_drawCrosshair
import cg_drawAmmoWarning
import cg_drawIcons
import cg_draw3dIcons
import cg_drawSnapshot
import cg_drawFPS
import cg_drawTimer
import cg_gibs
import cg_shadows
import cg_swingSpeed
import cg_bobroll
import cg_bobpitch
import cg_bobup
import cg_runroll
import cg_runpitch
import cg_centertime
import cg_markPolys
import cg_items
import cg_weapons
import cg_entities
import cg
import cgs
import CG_DrawAttacker_icon
import CG_DrawTeamPlayerPowerup
import CG_Draw_Icon_Ammo
import CG_Draw_Icon_Armor
import CG_DrawStatusBarHead
import playerTeam
import getPlayerHealth
import getPlayerLocation
import getTeamPlayerName
export FPS
align 4
LABELV FPS
skip 4
export TeamOverlay_Sel_idx
align 4
LABELV TeamOverlay_Sel_idx
skip 4
export ServerMsg_idx
align 4
LABELV ServerMsg_idx
skip 4
export ItemMsg_idx
align 4
LABELV ItemMsg_idx
skip 4
import Attacker_idx
export KillMsg_idx
align 4
LABELV KillMsg_idx
skip 4
export WarmFightMsg_idx
align 4
LABELV WarmFightMsg_idx
skip 4
export IcoPowerUp_idx
align 4
LABELV IcoPowerUp_idx
skip 4
export WeapListSelName_idx
align 4
LABELV WeapListSelName_idx
skip 4
export IcoWeapListSel_idx
align 4
LABELV IcoWeapListSel_idx
skip 4
export IcoWeapList_idx
align 4
LABELV IcoWeapList_idx
skip 4
import item_Keywords
export dyn_itemCount
align 4
LABELV dyn_itemCount
skip 4
export dyn_itemArray
align 4
LABELV dyn_itemArray
skip 310272
import itemCount
import itemArray
export teams_colors
align 4
LABELV teams_colors
skip 64
export ammo_colors
align 4
LABELV ammo_colors
skip 64
export armor_colors
align 4
LABELV armor_colors
skip 64
export health_colors
align 4
LABELV health_colors
skip 64
import BigEndian
import replace1
import Q_stradd
import Q_strcpy
import BG_StripColor
import BG_CleanName
import DecodedString
import EncodedString
import strtok
import Q_stristr
import BG_sprintf
import BG_PlayerTouchesItem
import BG_PlayerStateToEntityStateExtraPolate
import BG_PlayerStateToEntityState
import BG_TouchJumpPad
import BG_AddPredictableEventToPlayerstate
import BG_EvaluateTrajectoryDelta
import BG_EvaluateTrajectory
import BG_CanItemBeGrabbed
import BG_FindItemForHoldable
import BG_FindItemForPowerup
import BG_FindItemForWeapon
import BG_FindItem
import bg_numItems
import bg_itemlist
import Pmove
import PM_UpdateViewAngles
import Com_Printf
import Com_Error
import Info_NextPair
import Info_ValidateKeyValue
import Info_Validate
import Info_SetValueForKey_Big
import Info_SetValueForKey
import Info_ValueForKey
import va
import Q_CleanStr
import Q_PrintStrlen
import Q_strcat
import Q_strncpyz
import Q_strrchr
import Q_strupr
import Q_strlwr
import Q_stricmpn
import Q_strncmp
import Q_stricmp
import Q_isalpha
import Q_isupper
import Q_islower
import Q_isprint
import locase
import trap_PC_FreeSource
import trap_PC_LoadSource
import trap_PC_ReadToken
import trap_PC_SourceFileAndLine
import Com_sprintf
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import SkipRestOfLine
import SkipBracedSection
import COM_MatchToken
import Com_Split
import COM_ParseSep
import Com_InitSeparators
import SkipTillSeparators
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_DefaultExtension
import COM_StripExtension
import COM_SkipPath
import Com_Clamp
import PerpendicularVector
import AngleVectors
import MatrixMultiply
import MakeNormalVectors
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoxOnPlaneSide
import SetPlaneSignbits
import AxisCopy
import AxisClear
import AnglesToAxis
import vectoangles
import Q_crandom
import Q_random
import Q_rand
import Q_acos
import Q_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampShort
import ClampChar
import Q_rsqrt
import Q_fabs
import axisDefault
import vec3_origin
import g_color_table
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import bytedirs
import Hunk_Alloc
import acos
import fabs
import abs
import tan
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import memcpy
import memset
import memmove
import Q_sscanf
import ED_vsprintf
import atoi
import atof
import toupper
import tolower
import strncpy
import strstr
import strchr
import strcmp
import strcpy
import strcat
import strlen
import rand
import srand
import qsort
lit
align 1
LABELV $2126
byte 1 0
align 1
LABELV $2116
byte 1 104
byte 1 117
byte 1 100
byte 1 47
byte 1 104
byte 1 117
byte 1 100
byte 1 95
byte 1 99
byte 1 108
byte 1 97
byte 1 115
byte 1 115
byte 1 105
byte 1 99
byte 1 46
byte 1 99
byte 1 102
byte 1 103
byte 1 0
align 1
LABELV $2113
byte 1 99
byte 1 103
byte 1 95
byte 1 104
byte 1 117
byte 1 100
byte 1 70
byte 1 105
byte 1 108
byte 1 101
byte 1 115
byte 1 0
align 1
LABELV $2109
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 32
byte 1 60
byte 1 37
byte 1 115
byte 1 62
byte 1 10
byte 1 0
align 1
LABELV $2106
byte 1 60
byte 1 37
byte 1 115
byte 1 62
byte 1 32
byte 1 108
byte 1 111
byte 1 97
byte 1 100
byte 1 105
byte 1 110
byte 1 103
byte 1 46
byte 1 46
byte 1 46
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $2100
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $2065
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 115
byte 1 112
byte 1 101
byte 1 99
byte 1 105
byte 1 102
byte 1 105
byte 1 99
byte 1 95
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 115
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $2047
byte 1 71
byte 1 97
byte 1 109
byte 1 101
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 101
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 10
byte 1 0
align 1
LABELV $2009
byte 1 80
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 101
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 32
byte 1 60
byte 1 37
byte 1 115
byte 1 62
byte 1 10
byte 1 0
align 1
LABELV $2005
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1994
byte 1 101
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 115
byte 1 105
byte 1 100
byte 1 101
byte 1 32
byte 1 104
byte 1 117
byte 1 100
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $1974
byte 1 99
byte 1 111
byte 1 117
byte 1 108
byte 1 100
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1970
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1958
byte 1 101
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 115
byte 1 105
byte 1 100
byte 1 101
byte 1 32
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 0
align 1
LABELV $1928
byte 1 99
byte 1 111
byte 1 117
byte 1 108
byte 1 100
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1924
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 107
byte 1 101
byte 1 121
byte 1 119
byte 1 111
byte 1 114
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1912
byte 1 101
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 105
byte 1 110
byte 1 115
byte 1 105
byte 1 100
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 0
align 1
LABELV $1885
byte 1 116
byte 1 101
byte 1 97
byte 1 109
byte 1 95
byte 1 112
byte 1 108
byte 1 97
byte 1 121
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1884
byte 1 99
byte 1 97
byte 1 112
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $1883
byte 1 103
byte 1 114
byte 1 97
byte 1 100
byte 1 105
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $1882
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $1881
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 103
byte 1 110
byte 1 0
align 1
LABELV $1880
byte 1 109
byte 1 97
byte 1 114
byte 1 103
byte 1 105
byte 1 110
byte 1 0
align 1
LABELV $1879
byte 1 115
byte 1 104
byte 1 97
byte 1 100
byte 1 111
byte 1 119
byte 1 0
align 1
LABELV $1878
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 111
byte 1 114
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 97
byte 1 108
byte 1 0
align 1
LABELV $1877
byte 1 112
byte 1 117
byte 1 108
byte 1 115
byte 1 101
byte 1 83
byte 1 99
byte 1 97
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $1876
byte 1 118
byte 1 105
byte 1 115
byte 1 105
byte 1 98
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $1875
byte 1 116
byte 1 105
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $1874
byte 1 98
byte 1 108
byte 1 105
byte 1 110
byte 1 107
byte 1 0
align 1
LABELV $1873
byte 1 102
byte 1 105
byte 1 108
byte 1 108
byte 1 0
align 1
LABELV $1872
byte 1 97
byte 1 110
byte 1 99
byte 1 104
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1871
byte 1 98
byte 1 97
byte 1 99
byte 1 107
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1870
byte 1 102
byte 1 111
byte 1 114
byte 1 101
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1869
byte 1 112
byte 1 97
byte 1 114
byte 1 97
byte 1 109
byte 1 0
align 1
LABELV $1868
byte 1 102
byte 1 111
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $1867
byte 1 102
byte 1 111
byte 1 110
byte 1 116
byte 1 115
byte 1 105
byte 1 122
byte 1 101
byte 1 0
align 1
LABELV $1866
byte 1 116
byte 1 101
byte 1 120
byte 1 116
byte 1 97
byte 1 108
byte 1 105
byte 1 103
byte 1 110
byte 1 0
align 1
LABELV $1865
byte 1 118
byte 1 101
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 97
byte 1 108
byte 1 98
byte 1 97
byte 1 114
byte 1 0
align 1
LABELV $1864
byte 1 99
byte 1 118
byte 1 97
byte 1 114
byte 1 84
byte 1 101
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $1863
byte 1 105
byte 1 99
byte 1 111
byte 1 110
byte 1 51
byte 1 68
byte 1 0
align 1
LABELV $1862
byte 1 98
byte 1 97
byte 1 99
byte 1 107
byte 1 103
byte 1 114
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 0
align 1
LABELV $1861
byte 1 114
byte 1 101
byte 1 99
byte 1 116
byte 1 0
align 1
LABELV $1860
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $1838
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 79
byte 1 118
byte 1 101
byte 1 114
byte 1 108
byte 1 97
byte 1 121
byte 1 95
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $1837
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 95
byte 1 80
byte 1 111
byte 1 119
byte 1 101
byte 1 114
byte 1 85
byte 1 112
byte 1 0
align 1
LABELV $1836
byte 1 83
byte 1 101
byte 1 114
byte 1 118
byte 1 101
byte 1 114
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1835
byte 1 87
byte 1 97
byte 1 114
byte 1 109
byte 1 117
byte 1 112
byte 1 70
byte 1 105
byte 1 103
byte 1 104
byte 1 116
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1834
byte 1 73
byte 1 116
byte 1 101
byte 1 109
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1833
byte 1 75
byte 1 105
byte 1 108
byte 1 108
byte 1 77
byte 1 101
byte 1 115
byte 1 115
byte 1 97
byte 1 103
byte 1 101
byte 1 0
align 1
LABELV $1832
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 76
byte 1 105
byte 1 115
byte 1 116
byte 1 95
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 78
byte 1 97
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $1831
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 95
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 76
byte 1 105
byte 1 115
byte 1 116
byte 1 95
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $1830
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 95
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 76
byte 1 105
byte 1 115
byte 1 116
byte 1 0
align 1
LABELV $1816
byte 1 71
byte 1 97
byte 1 109
byte 1 101
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 0
align 1
LABELV $1815
byte 1 83
byte 1 101
byte 1 116
byte 1 67
byte 1 118
byte 1 97
byte 1 114
byte 1 0
align 1
LABELV $1814
byte 1 73
byte 1 78
byte 1 70
byte 1 79
byte 1 0
align 1
LABELV $1800
byte 1 69
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 32
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 99
byte 1 97
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 39
byte 1 99
byte 1 97
byte 1 112
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 39
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1794
byte 1 69
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 32
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 99
byte 1 97
byte 1 110
byte 1 39
byte 1 116
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 114
byte 1 111
byte 1 112
byte 1 101
byte 1 114
byte 1 116
byte 1 121
byte 1 32
byte 1 39
byte 1 103
byte 1 114
byte 1 97
byte 1 100
byte 1 105
byte 1 101
byte 1 110
byte 1 116
byte 1 39
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1783
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 99
byte 1 118
byte 1 97
byte 1 114
byte 1 32
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1768
byte 1 72
byte 1 85
byte 1 68
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $1762
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 46
byte 1 32
byte 1 80
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 32
byte 1 109
byte 1 117
byte 1 115
byte 1 116
byte 1 32
byte 1 98
byte 1 101
byte 1 32
byte 1 112
byte 1 108
byte 1 97
byte 1 99
byte 1 101
byte 1 100
byte 1 32
byte 1 98
byte 1 101
byte 1 102
byte 1 111
byte 1 114
byte 1 101
byte 1 32
byte 1 116
byte 1 104
byte 1 101
byte 1 32
byte 1 105
byte 1 116
byte 1 101
byte 1 109
byte 1 46
byte 1 10
byte 1 0
align 1
LABELV $1704
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 80
byte 1 76
byte 1 65
byte 1 89
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1703
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 83
byte 1 72
byte 1 79
byte 1 87
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 73
byte 1 78
byte 1 70
byte 1 79
byte 1 0
align 1
LABELV $1702
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 83
byte 1 80
byte 1 69
byte 1 67
byte 1 84
byte 1 65
byte 1 84
byte 1 79
byte 1 82
byte 1 0
align 1
LABELV $1701
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 95
byte 1 79
byte 1 82
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1700
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 83
byte 1 80
byte 1 69
byte 1 67
byte 1 0
align 1
LABELV $1699
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1698
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 0
align 1
LABELV $1697
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 70
byte 1 82
byte 1 69
byte 1 69
byte 1 90
byte 1 69
byte 1 0
align 1
LABELV $1696
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 67
byte 1 84
byte 1 70
byte 1 0
align 1
LABELV $1695
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 84
byte 1 68
byte 1 77
byte 1 0
align 1
LABELV $1694
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 70
byte 1 70
byte 1 65
byte 1 0
align 1
LABELV $1693
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 71
byte 1 84
byte 1 95
byte 1 84
byte 1 79
byte 1 85
byte 1 82
byte 1 78
byte 1 65
byte 1 77
byte 1 69
byte 1 78
byte 1 84
byte 1 0
align 1
LABELV $1692
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 95
byte 1 80
byte 1 76
byte 1 65
byte 1 89
byte 1 0
align 1
LABELV $1678
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 80
byte 1 76
byte 1 65
byte 1 89
byte 1 69
byte 1 82
byte 1 83
byte 1 95
byte 1 78
byte 1 66
byte 1 95
byte 1 84
byte 1 69
byte 1 65
byte 1 77
byte 1 0
align 1
LABELV $1677
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 78
byte 1 65
byte 1 77
byte 1 69
byte 1 0
align 1
LABELV $1676
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 76
byte 1 79
byte 1 67
byte 1 65
byte 1 84
byte 1 73
byte 1 79
byte 1 78
byte 1 0
align 1
LABELV $1675
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 84
byte 1 73
byte 1 77
byte 1 69
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1674
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 67
byte 1 65
byte 1 80
byte 1 84
byte 1 85
byte 1 82
byte 1 69
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1673
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 70
byte 1 82
byte 1 65
byte 1 71
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1672
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 67
byte 1 65
byte 1 80
byte 1 70
byte 1 82
byte 1 65
byte 1 71
byte 1 95
byte 1 76
byte 1 73
byte 1 77
byte 1 73
byte 1 84
byte 1 0
align 1
LABELV $1671
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 78
byte 1 65
byte 1 80
byte 1 83
byte 1 72
byte 1 79
byte 1 84
byte 1 0
align 1
LABELV $1670
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 70
byte 1 79
byte 1 76
byte 1 76
byte 1 79
byte 1 87
byte 1 95
byte 1 78
byte 1 65
byte 1 77
byte 1 69
byte 1 0
align 1
LABELV $1669
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 80
byte 1 69
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1668
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 70
byte 1 80
byte 1 83
byte 1 0
align 1
LABELV $1667
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 72
byte 1 79
byte 1 76
byte 1 68
byte 1 65
byte 1 66
byte 1 76
byte 1 69
byte 1 95
byte 1 73
byte 1 84
byte 1 69
byte 1 77
byte 1 0
align 1
LABELV $1666
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 84
byte 1 73
byte 1 77
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1665
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 67
byte 1 79
byte 1 82
byte 1 69
byte 1 0
align 1
LABELV $1664
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 87
byte 1 69
byte 1 65
byte 1 80
byte 1 79
byte 1 78
byte 1 0
align 1
LABELV $1663
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 0
align 1
LABELV $1662
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 65
byte 1 82
byte 1 77
byte 1 79
byte 1 82
byte 1 0
align 1
LABELV $1661
byte 1 86
byte 1 65
byte 1 76
byte 1 95
byte 1 72
byte 1 69
byte 1 65
byte 1 76
byte 1 84
byte 1 72
byte 1 0
align 1
LABELV $1639
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 70
byte 1 73
byte 1 82
byte 1 73
byte 1 78
byte 1 71
byte 1 0
align 1
LABELV $1638
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 80
byte 1 73
byte 1 67
byte 1 75
byte 1 85
byte 1 80
byte 1 95
byte 1 73
byte 1 84
byte 1 69
byte 1 77
byte 1 0
align 1
LABELV $1637
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 80
byte 1 79
byte 1 87
byte 1 69
byte 1 82
byte 1 85
byte 1 80
byte 1 95
byte 1 49
byte 1 0
align 1
LABELV $1636
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 95
byte 1 84
byte 1 65
byte 1 75
byte 1 69
byte 1 78
byte 1 0
align 1
LABELV $1635
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 95
byte 1 84
byte 1 65
byte 1 75
byte 1 69
byte 1 78
byte 1 0
align 1
LABELV $1634
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 66
byte 1 76
byte 1 73
byte 1 78
byte 1 75
byte 1 0
align 1
LABELV $1633
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 68
byte 1 73
byte 1 83
byte 1 67
byte 1 79
byte 1 78
byte 1 78
byte 1 69
byte 1 67
byte 1 84
byte 1 69
byte 1 68
byte 1 0
align 1
LABELV $1632
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 90
byte 1 69
byte 1 82
byte 1 79
byte 1 95
byte 1 86
byte 1 65
byte 1 76
byte 1 85
byte 1 69
byte 1 0
align 1
LABELV $1631
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 87
byte 1 65
byte 1 82
byte 1 77
byte 1 85
byte 1 80
byte 1 0
align 1
LABELV $1630
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 79
byte 1 85
byte 1 84
byte 1 95
byte 1 79
byte 1 70
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 0
align 1
LABELV $1629
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 76
byte 1 79
byte 1 87
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 95
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 0
align 1
LABELV $1628
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 80
byte 1 77
byte 1 70
byte 1 95
byte 1 70
byte 1 79
byte 1 76
byte 1 76
byte 1 79
byte 1 87
byte 1 0
align 1
LABELV $1627
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 76
byte 1 79
byte 1 67
byte 1 65
byte 1 76
byte 1 95
byte 1 83
byte 1 69
byte 1 82
byte 1 86
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1626
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 73
byte 1 78
byte 1 95
byte 1 77
byte 1 69
byte 1 78
byte 1 85
byte 1 0
align 1
LABELV $1625
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 78
byte 1 69
byte 1 86
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1624
byte 1 86
byte 1 73
byte 1 83
byte 1 95
byte 1 73
byte 1 78
byte 1 95
byte 1 83
byte 1 67
byte 1 79
byte 1 82
byte 1 69
byte 1 0
align 1
LABELV $1547
byte 1 110
byte 1 117
byte 1 109
byte 1 98
byte 1 101
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1527
byte 1 109
byte 1 101
byte 1 110
byte 1 117
byte 1 115
byte 1 99
byte 1 114
byte 1 101
byte 1 101
byte 1 110
byte 1 50
byte 1 0
align 1
LABELV $1524
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 65
byte 1 84
byte 1 84
byte 1 65
byte 1 67
byte 1 75
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1521
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 80
byte 1 79
byte 1 87
byte 1 69
byte 1 82
byte 1 85
byte 1 80
byte 1 0
align 1
LABELV $1518
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 79
byte 1 82
byte 1 68
byte 1 69
byte 1 82
byte 1 0
align 1
LABELV $1515
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 65
byte 1 77
byte 1 77
byte 1 79
byte 1 0
align 1
LABELV $1512
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 65
byte 1 82
byte 1 77
byte 1 79
byte 1 82
byte 1 0
align 1
LABELV $1509
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 72
byte 1 69
byte 1 65
byte 1 68
byte 1 95
byte 1 65
byte 1 78
byte 1 73
byte 1 77
byte 1 0
align 1
LABELV $1506
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 72
byte 1 69
byte 1 65
byte 1 68
byte 1 0
align 1
LABELV $1503
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 82
byte 1 69
byte 1 68
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 0
align 1
LABELV $1500
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 66
byte 1 76
byte 1 85
byte 1 69
byte 1 95
byte 1 70
byte 1 76
byte 1 65
byte 1 71
byte 1 0
align 1
LABELV $1497
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 72
byte 1 79
byte 1 76
byte 1 68
byte 1 65
byte 1 66
byte 1 76
byte 1 69
byte 1 95
byte 1 73
byte 1 84
byte 1 69
byte 1 77
byte 1 0
align 1
LABELV $1494
byte 1 73
byte 1 67
byte 1 79
byte 1 78
byte 1 95
byte 1 71
byte 1 65
byte 1 77
byte 1 69
byte 1 95
byte 1 84
byte 1 89
byte 1 80
byte 1 69
byte 1 0
align 1
LABELV $1454
byte 1 116
byte 1 114
byte 1 117
byte 1 101
byte 1 0
align 1
LABELV $1450
byte 1 102
byte 1 97
byte 1 108
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $1411
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 101
byte 1 114
byte 1 114
byte 1 111
byte 1 114
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $1353
byte 1 82
byte 1 101
byte 1 100
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1352
byte 1 66
byte 1 108
byte 1 117
byte 1 101
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $1351
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 115
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1350
byte 1 65
byte 1 109
byte 1 109
byte 1 111
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1349
byte 1 65
byte 1 114
byte 1 109
byte 1 111
byte 1 114
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1348
byte 1 72
byte 1 101
byte 1 97
byte 1 108
byte 1 116
byte 1 104
byte 1 67
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 115
byte 1 0
align 1
LABELV $1332
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 67
byte 1 114
byte 1 111
byte 1 115
byte 1 115
byte 1 104
byte 1 97
byte 1 105
byte 1 114
byte 1 0
align 1
LABELV $1331
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 65
byte 1 109
byte 1 109
byte 1 111
byte 1 87
byte 1 97
byte 1 114
byte 1 110
byte 1 105
byte 1 110
byte 1 103
byte 1 0
align 1
LABELV $1330
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 82
byte 1 101
byte 1 119
byte 1 97
byte 1 114
byte 1 100
byte 1 115
byte 1 0
align 1
LABELV $1329
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 83
byte 1 116
byte 1 97
byte 1 116
byte 1 117
byte 1 115
byte 1 0
align 1
LABELV $1328
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 83
byte 1 110
byte 1 97
byte 1 112
byte 1 115
byte 1 104
byte 1 111
byte 1 116
byte 1 0
align 1
LABELV $1327
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 80
byte 1 105
byte 1 110
byte 1 103
byte 1 0
align 1
LABELV $1326
byte 1 99
byte 1 103
byte 1 95
byte 1 108
byte 1 97
byte 1 103
byte 1 111
byte 1 109
byte 1 101
byte 1 116
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1325
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 84
byte 1 105
byte 1 109
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1324
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 83
byte 1 112
byte 1 101
byte 1 101
byte 1 100
byte 1 0
align 1
LABELV $1323
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 70
byte 1 80
byte 1 83
byte 1 0
align 1
LABELV $1322
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 51
byte 1 100
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 0
align 1
LABELV $1321
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 73
byte 1 99
byte 1 111
byte 1 110
byte 1 115
byte 1 0
align 1
LABELV $1320
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 67
byte 1 114
byte 1 111
byte 1 115
byte 1 115
byte 1 104
byte 1 97
byte 1 105
byte 1 114
byte 1 78
byte 1 97
byte 1 109
byte 1 101
byte 1 115
byte 1 0
align 1
LABELV $1319
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 84
byte 1 101
byte 1 97
byte 1 109
byte 1 79
byte 1 118
byte 1 101
byte 1 114
byte 1 108
byte 1 97
byte 1 121
byte 1 0
align 1
LABELV $1318
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 65
byte 1 116
byte 1 116
byte 1 97
byte 1 99
byte 1 107
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $1317
byte 1 99
byte 1 103
byte 1 95
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 87
byte 1 101
byte 1 97
byte 1 112
byte 1 111
byte 1 110
byte 1 83
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 0
align 1
LABELV $1297
byte 1 101
byte 1 120
byte 1 112
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 32
byte 1 105
byte 1 110
byte 1 116
byte 1 101
byte 1 103
byte 1 101
byte 1 114
byte 1 32
byte 1 98
byte 1 117
byte 1 116
byte 1 32
byte 1 102
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 10
byte 1 0
align 1
LABELV $1272
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 44
byte 1 32
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 32
byte 1 37
byte 1 100
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $1263
byte 1 72
byte 1 85
byte 1 68
byte 1 95
byte 1 65
byte 1 108
byte 1 108
byte 1 111
byte 1 99
byte 1 58
byte 1 32
byte 1 70
byte 1 97
byte 1 105
byte 1 108
byte 1 117
byte 1 114
byte 1 101
byte 1 46
byte 1 32
byte 1 79
byte 1 117
byte 1 116
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 109
byte 1 101
byte 1 109
byte 1 111
byte 1 114
byte 1 121
byte 1 33
byte 1 0
align 1
LABELV $1157
byte 1 37
byte 1 50
byte 1 105
byte 1 0
align 1
LABELV $1143
byte 1 116
byte 1 105
byte 1 109
byte 1 101
byte 1 58
byte 1 37
byte 1 105
byte 1 32
byte 1 115
byte 1 110
byte 1 97
byte 1 112
byte 1 58
byte 1 37
byte 1 105
byte 1 32
byte 1 99
byte 1 109
byte 1 100
byte 1 58
byte 1 37
byte 1 105
byte 1 0
align 1
LABELV $1135
byte 1 37
byte 1 105
byte 1 102
byte 1 112
byte 1 115
byte 1 0
align 1
LABELV $1132
byte 1 37
byte 1 105
byte 1 58
byte 1 37
byte 1 48
byte 1 50
byte 1 105
byte 1 0
align 1
LABELV $1131
byte 1 37
byte 1 105
byte 1 58
byte 1 37
byte 1 105
byte 1 58
byte 1 37
byte 1 48
byte 1 50
byte 1 105
byte 1 0
align 1
LABELV $1116
byte 1 37
byte 1 105
byte 1 0
align 1
LABELV $1113
byte 1 37
byte 1 115
byte 1 0
align 1
LABELV $1110
byte 1 37
byte 1 49
byte 1 46
byte 1 48
byte 1 105
byte 1 117
byte 1 112
byte 1 115
byte 1 0
align 1
LABELV $1109
byte 1 37
byte 1 49
byte 1 46
byte 1 48
byte 1 105
byte 1 0
align 1
LABELV $958
byte 1 69
byte 1 118
byte 1 101
byte 1 114
byte 1 121
byte 1 111
byte 1 110
byte 1 101
byte 1 0
align 1
LABELV $955
byte 1 37
byte 1 100
byte 1 0
align 1
LABELV $954
byte 1 99
byte 1 103
byte 1 95
byte 1 115
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 80
byte 1 108
byte 1 97
byte 1 121
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $953
byte 1 99
byte 1 103
byte 1 95
byte 1 115
byte 1 101
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 80
byte 1 108
byte 1 97
byte 1 121
byte 1 101
byte 1 114
byte 1 78
byte 1 97
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $915
byte 1 99
byte 1 109
byte 1 100
byte 1 32
byte 1 118
byte 1 116
byte 1 101
byte 1 108
byte 1 108
byte 1 32
byte 1 37
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $911
byte 1 116
byte 1 101
byte 1 97
byte 1 109
byte 1 116
byte 1 97
byte 1 115
byte 1 107
byte 1 32
byte 1 37
byte 1 105
byte 1 10
byte 1 0
align 1
LABELV $906
byte 1 99
byte 1 109
byte 1 100
byte 1 32
byte 1 118
byte 1 115
byte 1 97
byte 1 121
byte 1 95
byte 1 116
byte 1 101
byte 1 97
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $900
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 102
byte 1 108
byte 1 97
byte 1 103
byte 1 99
byte 1 97
byte 1 114
byte 1 114
byte 1 105
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $899
byte 1 111
byte 1 110
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 99
byte 1 97
byte 1 114
byte 1 114
byte 1 105
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $897
byte 1 114
byte 1 101
byte 1 116
byte 1 117
byte 1 114
byte 1 110
byte 1 102
byte 1 108
byte 1 97
byte 1 103
byte 1 0
align 1
LABELV $896
byte 1 111
byte 1 110
byte 1 103
byte 1 101
byte 1 116
byte 1 102
byte 1 108
byte 1 97
byte 1 103
byte 1 0
align 1
LABELV $894
byte 1 99
byte 1 97
byte 1 109
byte 1 112
byte 1 0
align 1
LABELV $893
byte 1 111
byte 1 110
byte 1 99
byte 1 97
byte 1 109
byte 1 112
byte 1 0
align 1
LABELV $891
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 49
byte 1 48
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 49
byte 1 48
byte 1 0
align 1
LABELV $890
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $889
byte 1 111
byte 1 110
byte 1 102
byte 1 111
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 0
align 1
LABELV $887
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 57
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 57
byte 1 0
align 1
LABELV $886
byte 1 112
byte 1 97
byte 1 116
byte 1 114
byte 1 111
byte 1 108
byte 1 0
align 1
LABELV $885
byte 1 111
byte 1 110
byte 1 112
byte 1 97
byte 1 116
byte 1 114
byte 1 111
byte 1 108
byte 1 0
align 1
LABELV $883
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 56
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 56
byte 1 0
align 1
LABELV $882
byte 1 100
byte 1 101
byte 1 102
byte 1 101
byte 1 110
byte 1 100
byte 1 0
align 1
LABELV $881
byte 1 111
byte 1 110
byte 1 100
byte 1 101
byte 1 102
byte 1 101
byte 1 110
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $879
byte 1 43
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 55
byte 1 59
byte 1 32
byte 1 119
byte 1 97
byte 1 105
byte 1 116
byte 1 59
byte 1 32
byte 1 45
byte 1 98
byte 1 117
byte 1 116
byte 1 116
byte 1 111
byte 1 110
byte 1 55
byte 1 0
align 1
LABELV $878
byte 1 111
byte 1 102
byte 1 102
byte 1 101
byte 1 110
byte 1 115
byte 1 101
byte 1 0
align 1
LABELV $877
byte 1 111
byte 1 110
byte 1 111
byte 1 102
byte 1 102
byte 1 101
byte 1 110
byte 1 115
byte 1 101
byte 1 0
